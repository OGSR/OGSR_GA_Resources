-- -*- mode: lua; coding: windows-1251-dos -*-

-----------------------------------------------------------------------
--- task_manager.script
--- Менеджер рандомных квестов
--- Правки: KamikaZze, Mixser OGS - Evolution Team 2010; kstn 
--- внесенные изменения: рандомные награды за квесты, полная статистика
-----------------------------------------------------------------------

function attach( sm )
	sm:subscribe({ signal = "on_task", fun = this.on_task })
	sm:subscribe({ signal = "on_save", fun = this.save })
	sm:subscribe({ signal = "on_load", fun = this.load })
end

function on_task(_task, _objective, _state)
	task_callback(_task:get_id(), _objective:get_idx(), _state)
	if _objective:get_idx() == 0 then
		if _state == task.fail then
			news_manager.send_task(db.actor, "fail", _task, _objective)
		elseif _state == task.completed then
			reward_by_task(_task)
			news_manager.send_task(db.actor, "complete", _task, _objective)
		else
			news_manager.send_task(db.actor, "new", _task, _objective)
		end
	else
		if _task:get_objective(0):get_state() == task.in_progress then
			news_manager.send_task(db.actor, "update", _task, _objective)
		end
	end
end

local random_task = nil

local parent_by_story = {
	[003] = "trader",
	[500] = "barman",
	[902] = "ecolog",
	[507] = "dolg",
	[707] = "freedom",
	[006] = "wolf",
	[004] = "shustriy",
	[510] = "drunk_dolg",
	[504] = "hunter",
	[518] = "zastava_commander",
	[506] = "petrenko",
	[607] = "lisiy",
	[515] = "mercenary"
}

local story_by_parent = {}
for k,v in pairs(parent_by_story) do
	story_by_parent[v] = k
end

local return_task_by_type = {
	eliminate_lager = "return_for_reward",
	defend_lager = "return_for_reward",
	kill_stalker = "return_for_reward",
	artefact = "return_for_reward_bring",
	monster_part = "return_for_reward_bring",
	find_item = "return_for_reward_bring"
}

local hirers = {
	["nil"] = "%c[default]",
	["redline"] = "%c[160,255,-170,-170]",
	["trader"] = "%c[255,160,160,160]"..game.translate_string("escape_trader_name")..": ",
	["barman"] = "%c[255,160,160,160]"..game.translate_string("bar_barmen_name")..": ",
	["ecolog"] = "%c[255,160,160,160]"..game.translate_string("yan_saharov_name").." ["..game.translate_string("ecolog").."]: ",
	["dolg"] = "%c[255,160,160,160]"..game.translate_string("bar_kvest_make_meet_dolg_freedom_text3_task").." ["..game.translate_string("ogse_duty_text").."]: ",
	["freedom"] = "%c[255,160,160,160]"..game.translate_string("svoboda_leader_name").." ["..game.translate_string("univ_comm_names_freedom_text").."]: ",
	["wolf"] = "%c[255,160,160,160]"..game.translate_string("esc_wolf_name")..": ",
	["shustriy"] = "%c[255,160,160,160]"..game.translate_string("esc_shustryi_name")..": ",
	["drunk_dolg"] = "%c[255,160,160,160]"..game.translate_string("bar_drunk_name").." ["..game.translate_string("ogse_duty_text").."]: ",
	["hunter"] = "%c[255,160,160,160]"..game.translate_string("bar_hunter_name")..": ",
	["zastava_commander"] = "%c[255,160,160,160]"..game.translate_string("zastava_commander_name_text").." ["..game.translate_string("ogse_duty_text").."]: ",
	["petrenko"] = "%c[255,160,160,160]"..game.translate_string("sar2_petrenko_name").." ["..game.translate_string("ogse_duty_text").."]: ",
	["lisiy"] = "%c[255,160,160,160]"..game.translate_string("bar_lisiy_name")..": ",
	["mercenary"] = "%c[255,160,160,160]"..game.translate_string("bar_informer_name")..": ",
	["dolg0"] = "%c[255,160,160,160]["..game.translate_string("ogse_duty_text").."]: ",
	["fanat"] = "%c[255,160,160,160]"..game.translate_string("esc_fanat_name")..": ",
	["demon"] = "%c[255,160,160,160]"..game.translate_string("gar_hellcar_name")..": ",
	["fox"] = "%c[255,160,160,160]"..game.translate_string("esc_fox_name")..": ",
	["serg"] = "%c[255,160,160,160]"..game.translate_string("gar_seryi_name")..": ",
	["krot"] = "%c[255,160,160,160]"..game.translate_string("agr_krot_name")..": ",
	["bullet"] = "%c[255,160,160,160]"..game.translate_string("val_pulia_name").." ["..game.translate_string("ogse_duty_text").."]: ",
	["krug"] = "%c[255,160,160,160]"..game.translate_string("rostok_kruglov").." ["..game.translate_string("ecolog").."]: ",
	["skull"] = "%c[255,160,160,160]"..game.translate_string("mil_Dolg_specnaz_cherep_name").." ["..game.translate_string("ogse_duty_text").."]: ",
	["max"] = "%c[255,160,160,160]"..game.translate_string("svoboda_master_max_name").." ["..game.translate_string("univ_comm_names_freedom_text").."]: ",
	["zmot"] = "%c[255,160,160,160]"..game.translate_string("svoboda_trader_name").." ["..game.translate_string("univ_comm_names_freedom_text").."]: "
}

class "CRandomTask"
function CRandomTask:__init()
	self.sm = ogse_signals.get_mgr()
	self.sm:subscribe({ signal = "on_first_update", self = self, fun = self.on_first_update })
	--' На конструкторе вычитываем LTX и создаем заготовки квестов.
	self.task_phrase_id = 100

	--' Итерируемся по всем настройкам фраз
	if not sys_ini:section_exist("list") then
		abort("There is no section [list] in task_manager.ltx")
	end
	local n = sys_ini:line_count("list")
	local id, value = "",""
	local category = ""

	--' начальная установка
	self.task_info = {}
	
	for i=0,n-1 do
		result, id, value	= sys_ini:r_line("list",i)
		
		if not sys_ini:section_exist(id) then
			abort("There is no section [%s] in task_manager.ltx", id)
		end		

		self.task_info[tostring(id)]			= {}
		local curr_task_info					= self.task_info[tostring(id)]
		
		if not sys_ini:line_exist(id, "type") then
			abort("Task manager error: no type in section [%s]", id)
		end

		curr_task_info.type			= sys_ini:r_string(id, "type")			

		curr_task_info.name			= id
		if sys_ini:line_exist(id, "hirer") then
			curr_task_info.hirer = sys_ini:r_string(id, "hirer")
		else
			curr_task_info.hirer = "nil"
		end
		if sys_ini:line_exist(id, "story") then
			curr_task_info.story = sys_ini:r_string(id, "story")
		else
			curr_task_info.story = "nil"
		end
		if sys_ini:line_exist(id, "parent") then
			curr_task_info.parent		= sys_ini:r_string(id, "parent")
			curr_task_info.complex_type = curr_task_info.type .. "_" .. self.task_info[id].parent
		else
			curr_task_info.parent		= "nil"
			curr_task_info.complex_type = curr_task_info.type
		end
		if sys_ini:line_exist(id, "target") then
			curr_task_info.target		= sys_ini:r_string(id, "target")
		end
		if sys_ini:line_exist(id, "info") then
			curr_task_info.info			= sys_ini:r_string(id, "info")
		end
		if sys_ini:line_exist(id, "text") then
			curr_task_info.text			= sys_ini:r_string(id, "text")
		end
		if sys_ini:line_exist(id, "description") then
			curr_task_info.description	= sys_ini:r_string(id, "description")				
		end
		curr_task_info.time				= utils.cfg_get_number(sys_ini, id, "time", nil, false)

		curr_task_info.idle_time		= utils.cfg_get_number(sys_ini, id, "idle_time", nil, false, 24*60*60) --' Время между выдачами задания (в игровых секундах)
	
		if sys_ini:line_exist(id, "init_condition") then
			curr_task_info.init_condition = xr_logic.parse_condlist(db.actor_proxy, "task_manager", "init_condition", sys_ini:r_string(id, "init_condition"))
		end

		local sss = utils.cfg_get_string(sys_ini, id, "reward_item", nil, false, "")
		if sss ~= nil then
			curr_task_info.reward_item = parse_names(sss) 
		end
		curr_task_info.reward_money = utils.cfg_get_number(sys_ini, id, "reward_money", nil, false)		
	
		if sys_ini:line_exist(id, "community") then
			curr_task_info.community = sys_ini:r_string(id, "community")
		end		

		curr_task_info.reward_rank			= utils.cfg_get_number(sys_ini, id, "reward_rank", nil, false, 0)
		curr_task_info.reward_reputation	= utils.cfg_get_number(sys_ini, id, "reward_reputation", nil, false)
		curr_task_info.reward_relation		= parse_key_value(utils.cfg_get_string(sys_ini, id, "reward_relation", nil, false, ""))
		
		if sys_ini:line_exist(id, "condlist") then
			curr_task_info.condlist			= xr_logic.parse_condlist(db.actor_proxy, "task_manager", "condlist", sys_ini:r_string(id, "condlist"))
		else
			curr_task_info.condlist			= xr_logic.parse_condlist(db.actor_proxy, "task_manager", "condlist", "true")
		end		
	
		curr_task_info.need_return			= utils.cfg_get_bool(sys_ini, id, "need_return", nil, false, true)

		curr_task_info.init_phrase_id		= self:gen_phrase_id()
		curr_task_info.desc_phrase_id		= self:gen_phrase_id()
		curr_task_info.yes_phrase_id		= self:gen_phrase_id()
		curr_task_info.no_phrase_id			= self:gen_phrase_id()

		--' По умолчанию квест доступен для выдачи
		curr_task_info.enabled				= true
		--' Доступен ли квест по своим свойствам. По умолчанию всегда недоступен.
		--' Этот параметр зависит от наличия целей для квестов и того срабатывает ли прекондишн квеста
		curr_task_info.enabled_props		= false

		--' Статус квеста, может быть: "normal", "selected", "completed", "refused", "failed", "rewarded"
		curr_task_info.status				= "normal"
	end

	--' Создание дополнительных ассоциативных таблиц для облегчения поиска
	self.task_id_by_type = {}
	self.task_id_by_parent = {}
	self.task_id_by_yes_phrase_id = {}
	self.task_id_by_desc_phrase_id = {}
	self.task_id_by_init_phrase_id = {}
	self.active_task_by_type = {}
	self.task_id_self_inited = {}
	for k,v in pairs(self.task_info) do
		--' По типу квеста
		if self.task_id_by_type[v.type] == nil then
			self.task_id_by_type[v.type] = {}
		end
		table.insert(self.task_id_by_type[v.type], k)

		--' По типу вендора
		if self.task_id_by_parent[v.parent] == nil then
			self.task_id_by_parent[v.parent] = {}
		end
		table.insert(self.task_id_by_parent[v.parent], k)

		--' По id фразы согласия на квест
		self.task_id_by_yes_phrase_id[tostring(v.yes_phrase_id)] = k
		--
		self.task_id_by_desc_phrase_id[v.desc_phrase_id] = k
		--' По id фразы выдачи квеста.
		self.task_id_by_init_phrase_id[tostring(v.init_phrase_id)] = k
		--' По самовыдаваемости
		if v.init_condition ~= nil then
			table.insert(self.task_id_self_inited, k)
			if not self.subscribed then
				self.subscribed = {
					signal = "on_update", self = self, fun = self.actor_update,
					queued = true
				}
				self.sm:subscribe( self.subscribed )
			end
		end
	end
end
--' Сохранение
function CRandomTask:save()
	local tasks = {}
	for k,v in pairs(self.task_info) do
		table.insert(
			tasks,
			{
				k,
				v.enabled,
				v.enabled_props,
				v.status,
				v.selected_target or 4294967295,
				v.last_task_time or game.CTime()
			}
		)
	end
	--log3("[%s] Saving tasks: %s", script_name(), tasks)
	ogse.save_var(
		script_name() .. ".tasks", tasks, "array_template",
		{ "string", "bool", "bool", "string", "u32", "time" }
	)
	--
	local active = {}
	for k,v in pairs(self.active_task_by_type) do
		table.insert( active, { k, v } )
	end
	--log3("[%s] Saving active tasks: %s", script_name(), active)
	ogse.save_var(
		script_name() .. ".active", active, "array_template",
		{ "string", "string" }
	)
end
--' Загрузка
function CRandomTask:load()
	local tasks = ogse.load_var_safe( script_name() .. ".tasks" )
	--log3("[%s] Loaded tasks: %s", script_name(), tasks)
	for _, t in ipairs( tasks ) do
		local id = table.remove( t, 1 )
		local info = self.task_info[id]
		info.enabled = table.remove( t, 1 )
		info.enabled_props = table.remove( t, 1 )
		info.status = table.remove( t, 1 )
		local selected_target = table.remove( t, 1 )
		if selected_target ~= 4294967295 then
			info.selected_target = selected_target
		end
		info.last_task_time = table.remove( t, 1 )
		-- здесь адский баг. Активный selected_target может быть _только_ у выданных квестов, в остальном случае там -1.
		-- Тут проверяем активность таска. Параллельно правим еще в функции проверки завершенности таска на всякий случай.
		if info.type == "defend_lager" and info.selected_target then     
			local defend_object = alife():object(info.selected_target)                                  
			local sm_ini = defend_object:spawn_ini()                                                                  
			info.defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
		end                                                                                                         
	end
	--
	local active = ogse.load_var( script_name() .. ".active" )
	--log3("[%s] Looaded active tasks: %s", script_name(), active)
	for _, t in ipairs( active ) do
		local id = table.remove( t, 1 )
		self.active_task_by_type[id] = table.remove( t, 1 )
	end
end
--' Генератор уникальных ID для фраз
function CRandomTask:gen_phrase_id()
	self.task_phrase_id = self.task_phrase_id + 1
	return tostring(self.task_phrase_id)
end
--' Возвращает идентификатор вендора, с которым мы говорим
function CRandomTask:get_parent(npc)
	return parent_by_story[npc:story_id()] or abort("Task manager error: wrong parent story_id: [%s]", npc:story_id())
end
--' Может ли вендор выдать квест
function CRandomTask:parent_can_task(actor, npc, p1, p2, p3)
	local parent = self:get_parent(npc)
	local avail = false
	self:task_avail(actor, npc, nil, nil, nil, "reset")

	if self.task_id_by_parent[parent] ~= nil then -- вставлено с целью отладки KamikaZze 18/02/2009
		for k,v in pairs(self.task_id_by_parent[parent]) do
			if self:task_avail(actor, npc, nil, nil, self.task_info[v].init_phrase_id, true) then
				avail = true
			end
		end
	elseif self.task_id_by_parent[parent] == nil then
		avail = false
	end

	return avail
end
--' Есть ли у игрока хоть одно задание от данного вендора
function CRandomTask:active_parent_task(actor, npc)
	local parent = self:get_parent(npc)
	for k,v in pairs(self.active_task_by_type) do

		if self.task_info[v].parent == parent and
		  (self.task_info[v].status == "selected" or
		   self.task_info[v].status == "completed")
		then
			return true
		end				
	end
	return false
end
--' Есть ли игрока завершенные задания (которые осталось только сдать)
function has_item_to_bring(task_desc)
	if task_desc.type == "find_item" or task_desc.type == "artefact" or task_desc.type == "monster_part" then
		if db.actor:object(task_desc.target) then
			return true
		else
			return false
		end
	else
		return true
	end	
end

function CRandomTask:have_completed_job(actor, npc)
	local parent = self:get_parent(npc)
	for k,v in pairs(self.active_task_by_type) do

		--if self.task_info[v].parent == parent and
--self.task_info[v].status == "completed"
		local task_desc = self.task_info[v]
		if task_desc.parent == parent and task_desc.status == "completed" then
			return has_item_to_bring(task_desc)
		end		
	end
	return false
end
--' Выдача квеста игроку
function CRandomTask:action_give_task(actor, npc, p1, p2)
	local task = CGameTask()
	

	local task_desc = self.task_info[self.task_id_by_yes_phrase_id[p2]]
--[[	
	-- Генерим наполнение списков заранее... Mixser
	local rt = ogse_random_task_reward.random_task_reward(task_desc.parent, self.task_id_by_yes_phrase_id[p2])
	
	if rt.random_task_reward_accept == 1 then
		rt:generate_reward_complect()
	end
--]]	
	task:load(task_desc.complex_type)
	task:set_title(task_desc.type)

	local oo = task:get_objective(0)
	oo:set_article_id(task_desc.description)
	
	local objective = SGameTaskObjective(task,1)
	objective:set_description(task_desc.name)
	--' Выбираем текущую цель квеста
	if task_desc.target_objects ~= nil then
		self.task_info[self.task_id_by_yes_phrase_id[p2]].selected_target = task_desc.target_objects[math.random(table.getn(task_desc.target_objects))]
	end
	--
	if task_desc.selected_target then
		ASSERT( alife():object(task_desc.selected_target), "object with id [%s] not found!", task_desc.selected_target)
	end
	--
	if task_desc.type == "eliminate_lager" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("eliminate_lager_location")
		objective:set_object_id(task_desc.selected_target) -- вроде как id целевого объекта, определяет координаты метки.
	elseif task_desc.type == "defend_lager" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("defend_lager_location")
		objective:set_object_id(task_desc.selected_target)

		local defend_object = alife():object(task_desc.selected_target)
		local sm_ini = defend_object:spawn_ini()
		self.task_info[self.task_id_by_yes_phrase_id[p2]].defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
	elseif task_desc.type == "kill_stalker" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("kill_stalker_location")
		objective:set_object_id(task_desc.selected_target)
	elseif task_desc.type == "find_item" then
		objective:set_map_hint(task_desc.text)
		objective:set_map_location("find_item_location")
		objective:set_object_id(task_desc.selected_target)
	end
	objective:add_complete_func("task_manager.task_complete")
	task:add_objective(objective)

	if task_desc.need_return then
		objective = SGameTaskObjective(task,2)
		objective:set_description(return_task_by_type[task_desc.type])

		objective:set_map_hint(return_task_by_type[task_desc.type])
		objective:set_map_location("blue_location")
		objective:set_object_id(alife():story_object(story_by_parent[task_desc.parent]).id)
		task:add_objective(objective)
	end

	local time = 0
	if task_desc.time ~= nil then
		time = task_desc.time * 1000
	end
	db.actor:give_task(task,time,false)

	self.task_info[self.task_id_by_yes_phrase_id[p2]].status = "selected"
	self.active_task_by_type[task_desc.complex_type] = self.task_id_by_yes_phrase_id[p2]
	--
	--' дизаблим все остальные задания данного типа, так как игрок не может одновременно обладать двумя заданиями одного типа.
	for k,v in pairs(self.task_info) do
		if v.complex_type == task_desc.complex_type then
			v.enabled = false
		end
	end
-- Мирное получение Форта-15 у майора Кузнецова по заданию Сидоровича
-- проверяем, является ли предмет фортом-15, и если да, выдаём инфопоршень
	if task_desc.target == "wpn_fort_unic" then
		db.actor:give_info_portion("find_fort_m1")
	end
-- проверяем, является ли предмет фортом-15, и если да, выдаём инфопоршень
-- Мирное получение Форта-15 у майора Кузнецова по заданию Сидоровича
end
--' Отказ игроком от квеста
function CRandomTask:action_refuse_task(actor, npc, p1, p2)
	local task_desc = self.task_info[self.task_id_by_yes_phrase_id[p2]]

	self.task_info[self.task_id_by_yes_phrase_id[p2]].status = "refused"
	self.task_info[self.active_task_by_type[task_desc.complex_type]].selected_target = nil
	--
	--' Делаем доступными все задания данного типа
	for k,v in pairs(self.task_info) do
		if v.complex_type == task_desc.complex_type then
			v.enabled = true
		end
	end
end
--' Проверяем, не выполнен ли таск
function CRandomTask:task_complete(p1, p2)
	if db.actor == nil then
		return false
	end

	local sel_task = self.task_info[self.active_task_by_type[p1]]
	if sel_task == nil then
		abort("WRONG RANDOM TASK %s %s", tostring(p1), tostring(p2))
	end

	if p2 == 0 then
		if not sel_task.need_return and sel_task.status == "completed" then
			self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
			return true
		end
		if sel_task.status == "rewarded" then
			self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
			return true
		end
	end

	if p2 == 1 then
		if string.find(p1, "eliminate_lager") ~= nil then
			local oo = alife():object(sel_task.selected_target)
			-- KD (26.12.2016): неправильно по сути считать общее население смарта. Надо проверять тех, кто был назначен на работу и пришел на нее
			if oo and oo.gulag:get_population_comed() == 0 then
				self.task_info[self.active_task_by_type[p1]].status = "completed"
				if self.task_info[self.active_task_by_type[p1]].info then
					db.actor:give_info_portion(self.task_info[self.active_task_by_type[p1]].info)
				end
				return true
			end
		elseif string.find(p1, "defend_lager") ~= nil then
			--' Квест выполнен потому что рейд прекратился
			if sel_task.defend_target and xr_gulag.getGulagState(sel_task.defend_target) == 0 then
				self.task_info[self.active_task_by_type[p1]].status = "completed"
				return true
			end
		elseif string.find(p1, "kill_stalker") ~= nil then
			local oo = alife():object(sel_task.selected_target)
			if oo and oo:alive() == false then
				self.task_info[self.active_task_by_type[p1]].status = "completed"
				return true
			elseif not oo then	
				self.task_info[self.active_task_by_type[p1]].status = "refused"
				return true						
			end
		elseif string.find(p1, "artefact") or string.find(p1, "monster_part") or string.find(p1, "find_item") then
			if db.actor:object(sel_task.target) ~= nil then
				self.task_info[self.active_task_by_type[p1]].status = "completed"
				return true
			end
		end
	end
	
	return false
end
--' Проверяем, не профейлен ли таск
function CRandomTask:task_fail(p1, p2)
	if p2 == 0 then
		local sel_task = self.task_info[self.active_task_by_type[p1]]
		
		if sel_task == nil then
			abort("WRONG RANDOM TASK %s %s", tostring(p1), tostring(p2))
		end

		--' Проверяем что жив, выдавший квест.
		local parent = alife():story_object(story_by_parent[sel_task.parent])
		if parent == nil or (parent.alive ~= nil and not parent:alive()) then
			self.task_info[self.active_task_by_type[p1]].status = "failed"
			self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
			return true		
		end

		if sel_task.status == "refused" or sel_task.status == "failed" then
			self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
			return true
		end
		if string.find(p1, "defend_lager") ~= nil then
			if alife():object(sel_task.selected_target).gulag:get_population_comed() == 0 then
				self.task_info[self.active_task_by_type[p1]].status = "failed"
				self.task_info[self.active_task_by_type[p1]].last_task_time = game.get_game_time()
				return true
			end
		end
	end
	return false
end
--' Обнуление переменных при завершении или провале таска
function CRandomTask:task_callback(p1, p2, state)
	if p2 ~= 0 then
		return
	end

	if self.active_task_by_type[p1] == nil then
		return
	end

	if state == task.completed or state == task.fail then
		self.task_info[self.active_task_by_type[p1]].status = "normal"

		--' восстановление других заданий данного типа
		for k,v in pairs(self.task_info) do
			if v.complex_type == self.task_info[self.active_task_by_type[p1]].complex_type then
				v.enabled = true
			end
		end
		self.active_task_by_type[p1] = nil	
	end
end
--' Выводит список доступных квестов
function CRandomTask:action_task_show(npc, actor)
	local parent = self:get_parent(npc)	
	for k,v in pairs(self.task_id_by_parent[parent]) do		
		if self:task_avail(actor, npc, nil, nil, self.task_info[v].init_phrase_id, false) then
			local task_texture, task_rect = get_texture_info("ui_icons_task_"..self.task_info[v].type, "ui_iconsTotal_locations")
			db.actor:give_talk_message(game.translate_string(self.task_info[v].name), task_texture, task_rect,"other_iconed_answer_item")
		end
	end
end
--' Проверка доступен ли текущий таск для выдачи
function CRandomTask:task_avail(actor, npc, p1, p2, p3, calculate)
	local task_desc = self.task_info[self.task_id_by_init_phrase_id[p3]]

	if calculate == "reset" then		
		return
	elseif calculate == true then --Если calculate == true то нужно проверять check_task_props, инача просто вернуть значения.
		self:check_task_props(self.task_id_by_init_phrase_id[p3])
	end

	return task_desc.enabled and task_desc.enabled_props and task_desc.init_condition == nil
end
--' Проверка свойств таска
function CRandomTask:check_task_props(task_id)
	--' Проверка по активным заданиям данного типа у вендора.
	if self.active_task_by_type[self.task_info[task_id].complex_type] ~= nil then
		self.task_info[task_id].enabled_props = false
		return
	end

	--' Проверка по кондлисту
	if xr_logic.pick_section_from_condlist(db.actor, db.actor, self.task_info[task_id].condlist) == nil then
		self.task_info[task_id].enabled_props = false
		return
	end
	
	--' Проверка по таймауту
	if self.task_info[task_id].last_task_time ~= nil and
		game.get_game_time():diffSec(self.task_info[task_id].last_task_time) < self.task_info[task_id].idle_time
	then
		self.task_info[task_id].enabled_props = false
		return
	end

	--' проверка по таргету
	if self.task_info[task_id].type == "eliminate_lager" then
		if self.task_info[task_id].target_objects == nil then
			self.task_info[task_id].enabled_props = false
			return
		end
		for k,v in pairs(self.task_info[task_id].target_objects) do
			local gulag = alife():object(v).gulag
			if gulag:get_population_comed() > 0 then
				self.task_info[task_id].enabled_props = true
				return 
			end
		end
		self.task_info[task_id].enabled_props = false
	elseif self.task_info[task_id].type == "defend_lager" then
		if self.task_info[task_id].target_objects == nil then
			self.task_info[task_id].enabled_props = false
			return
		end
		for k,v in pairs(self.task_info[task_id].target_objects) do
			local defend_object = alife():object(v)
			local sm_ini = defend_object:spawn_ini()
			local defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
			if xr_gulag.getGulagState(defend_target) == 1 then
				self.task_info[task_id].enabled_props = true
				return
			end
		end
		self.task_info[task_id].enabled_props = false
	elseif self.task_info[task_id].type == "kill_stalker" then
		local sim = alife()
		for id, sobj in alife():objects() do --KRodin: лучше немного тормозов тут, чем регистрация 100500 объектов из se_* при каждой загрузке сейва
			if sobj:clsid() == clsid.script_stalker and sobj:alive() and sobj:profile_name() == self.task_info[task_id].target then
				if not self.task_info[task_id].target_objects then self.task_info[task_id].target_objects = {} end
				table.insert(self.task_info[task_id].target_objects, id)
				self.task_info[task_id].enabled_props = true
				return
			end
		end
		self.task_info[task_id].enabled_props = false
	elseif self.task_info[task_id].type == "find_item" then
		local sim = alife()
		for id, sobj in alife():objects() do --KRodin: лучше немного тормозов тут, чем регистрация 100500 объектов из se_* при каждой загрузке сейва
			if sobj:section_name() == self.task_info[task_id].target then
				--Нужно игнорировать предметы, которые находяться у вендоров.
				local ignore = false
				if sobj.parent_id then
					for kk,vv in pairs(parent_by_story) do
						local parent = sim:story_object(kk)
						if parent and sobj.parent_id == parent.id then
							ignore = true
						end
					end
				end
				--
				if not ignore then
					if not self.task_info[task_id].target_objects then self.task_info[task_id].target_objects = {} end
					table.insert(self.task_info[task_id].target_objects, id)
					self.task_info[task_id].enabled_props = true
					return
				end
			end
		end
--KRodin: добавил поддержку волшебных рюкзаков
		for _, k in ipairs( ogse_unist.get_all_names() ) do
			local id = string.match( k, "^dsh_rukzak%.([^.]+)%.sections$" )
			if id then
				id = tonumber( id )
				if dsh_rukzak.is_item_in_rukzak(id, self.task_info[task_id].target) then
					if not self.task_info[task_id].target_objects then self.task_info[task_id].target_objects = {} end
					table.insert(self.task_info[task_id].target_objects, id)
					self.task_info[task_id].enabled_props = true
					return
				end
			end
		end
--
		self.task_info[task_id].enabled_props = false
	else
		self.task_info[task_id].enabled_props = true
	end
end
--' Проверяем можем ли мы сейчас выдать какой либо самоинициализующийся таск
function CRandomTask:actor_update()
	self.sm:reschedule( math.random(1000, 1500) )
	for k,v in pairs(self.task_id_self_inited) do
		if self.task_info[v].status == "normal" then
			self:check_task_props(v)
			if self.task_info[v].enabled_props == true and
			   self.task_info[v].enabled == true and
			   xr_logic.pick_section_from_condlist(db.actor, db.actor, self.task_info[v].init_condition) ~= nil
			then
				--' Нужно автоматически выдать квест
				self:action_give_task(db.actor, nil, nil, self.task_info[v].yes_phrase_id)
			end
		end
	end
end
--' Проверяется является ли текущий таск выданным игроку
function CRandomTask:active_task(actor, npc, p1, p2, p3)
	return (self.task_info[self.task_id_by_init_phrase_id[p3]].status == "selected"
		or (self.task_info[self.task_id_by_init_phrase_id[p3]].status == "completed" and not has_item_to_bring(self.task_info[self.task_id_by_init_phrase_id[p3]])))
end
--' Создается диалог актера, в котором будут выдаваться задания.
function CRandomTask:init_task_dialog(dlg, parent)
	local phr = dlg:AddPhrase("tm_seek_new_job","0","",-10000)
	local phrase_script = phr:GetPhraseScript()

	phr = dlg:AddPhrase("tm_"..parent.."_list_job","1","0",-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddAction("task_manager.action_task_show")
	phrase_script:AddPrecondition("task_manager.precondition_vendor_can_task")
		
	phr = dlg:AddPhrase("tm_"..parent.."_has_no_job","2","0",-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddPrecondition("task_manager.precondition_vendor_cannot_task")
	
	for k,v in pairs(self.task_id_by_parent[parent]) do
		phr = dlg:AddPhrase(self.task_info[v].name, tostring(self.task_info[v].init_phrase_id), "1", -10000)		
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddPrecondition("task_manager.precondition_task_avail")

		phr = dlg:AddPhrase(self.task_info[v].text, tostring(self.task_info[v].desc_phrase_id), tostring(self.task_info[v].init_phrase_id), -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.show_reward")

		phr = dlg:AddPhrase("tm_seek_job_yes", tostring(self.task_info[v].yes_phrase_id), tostring(self.task_info[v].desc_phrase_id), -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_give_task")

		phr = dlg:AddPhrase("tm_seek_job_no", tostring(self.task_info[v].no_phrase_id), tostring(self.task_info[v].desc_phrase_id), -10000)
	end

	dlg:AddPhrase("tm_seek_job_abandon","3","1",-10000)
end


--' Функция, в которой будет выдаваться вещевая награда за выполненные квесты
function CRandomTask:task_reward(npc, actor, p1, p2)
	local parent = self:get_parent(npc)	
	for k,v in pairs(self.active_task_by_type) do	
		local task_desc = self.task_info[v]
		if task_desc.status == "completed" and task_desc.parent == parent then
			--' Забираем у игрока квестовый предмет.
			local can_finish = true
			if task_desc.type == "artefact" then
				if db.actor:object(task_desc.target) == nil then
					can_finish = false
				else
					dialogs.relocate_item_section(npc, task_desc.target, "out")
				end
			elseif task_desc.type == "monster_part" then
				if db.actor:object(task_desc.target) == nil then
					can_finish = false
				else
					dialogs.relocate_item_section(npc, task_desc.target, "out")
				end
			elseif task_desc.type == "find_item" then
				if db.actor:object(task_desc.target) == nil then
					can_finish = false
				else
					dialogs.relocate_item_section(npc, task_desc.target, "out")
-- Мирное получение Форта-15 у майора Кузнецова по заданию Сидоровича
-- проверяем, является ли предмет фортом-15, и если да, удаляем инфопоршень
					if task_desc.target == "wpn_fort_unic" then
						db.actor:disable_info_portion("find_fort_m1") 
					end
-- проверяем, является ли предмет фортом-15, и если да, удаляем инфопоршень
-- Мирное получение Форта-15 у майора Кузнецова по заданию Сидоровича
				end
			end
			
	
			if can_finish == true then
				self.task_info[v].status = "rewarded"
				
				-- Вызываем список вещей для отображения. Mixser
				
				local rt = ogse_random_task_reward.random_task_reward(task_desc.parent, v)
				
				if rt.random_task_reward_accept == 1 and rt.difficult_list[v] then
					ui_ogse_random_reward_choose_item.random_reward_get_hud(npc, v)
					task_desc.reward_money = nil
					task_desc.reward_item = nil
				end
				
				rt = nil -- чистим неиспользуемое
				
				if task_desc.reward_money ~= nil then
					dialogs.relocate_money(npc, task_desc.reward_money, "in")
				end
				
				if task_desc.reward_item ~= nil then
					for kk,vv in pairs(task_desc.reward_item) do
						dialogs.relocate_item_section(npc, vv, "in")
					end
				end
				

				if task_desc.reward_reputation ~= nil then
					--log1("REPA: "..tostring(db.actor:character_reputation()))
					--log1("REPA REV "..tostring(task_desc.reward_reputation))
					--log1("REPA DELTA "..tostring(db.actor:character_reputation() + task_desc.reward_reputation))
					db.actor:change_character_reputation(task_desc.reward_reputation)
					--log1("REPA OUT "..tostring(db.actor:character_reputation()))
				end

				if task_desc.reward_relation ~= nil then
					for kk,vv in pairs(task_desc.reward_relation) do
						relation_registry.change_community_goodwill (kk, db.actor:id(), tonumber(vv))
					end
				end

				if task_desc.reward_rank ~= nil then
					local task=hirers[task_desc.parent]..hirers[task_desc.story]..game.translate_string(task_desc.name)
					actor_stats.add_points("quests", task, 1, task_desc.reward_rank)
					db.actor:set_character_rank(db.actor:character_rank() + task_desc.reward_rank)
				end
			end
		end	
	end
end
--' Функция, в которой будет выдаваться вещевая награда за выполненные сторилайновые квесты
function CRandomTask:task_reward_storyline(task)
	local task_desc = self.task_info[task:get_id()]
	if task_desc == nil or task_desc.type ~= "storyline" then
		return
	end

	if task_desc.reward_reputation ~= nil then
		--log1("REPA: "..tostring(db.actor:character_reputation()))
		--log1("REPA REV "..tostring(task_desc.reward_reputation))
		--log1("REPA DELTA "..tostring(db.actor:character_reputation() + task_desc.reward_reputation))	
		db.actor:change_character_reputation(task_desc.reward_reputation)
		--log1("REPA OUT "..tostring(db.actor:character_reputation()))
	end

	if task_desc.reward_relation ~= nil then
		for kk,vv in pairs(task_desc.reward_relation) do
			relation_registry.change_community_goodwill(kk, db.actor:id(), tonumber(vv))
		end
	end

	if task_desc.reward_rank ~= nil then
		local task=hirers[task_desc.hirer]..hirers[task_desc.story]..game.translate_string(task_desc.name)
		actor_stats.add_points("quests", task, 1, task_desc.reward_rank)
		db.actor:set_character_rank(db.actor:character_rank() + task_desc.reward_rank)
	end
end
--' Создается диалог актера, в котором будут приниматься задания
function CRandomTask:init_reward_dialog(dlg, parent)
	local phr = dlg:AddPhrase("tm_reward_job","0","",-10000)
	local phrase_script = phr:GetPhraseScript()

	phr = dlg:AddPhrase("tm_"..parent.."_job_complete", "1", "0", -10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddAction("task_manager.action_task_reward")
	phrase_script:AddPrecondition("task_manager.precondition_have_completed_job")
			
	phr = dlg:AddPhrase("tm_"..parent.."_job_ask", "2", "0", -10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddPrecondition("task_manager.precondition_dont_have_completed_job")

	
	-- Список возможных квестов трейдера.
	for k,v in pairs(self.task_id_by_parent[parent]) do
		phr = dlg:AddPhrase(self.task_info[v].name, tostring(self.task_info[v].init_phrase_id), "2", -10000)
		phrase_script = phr:GetPhraseScript()		
		phrase_script:AddPrecondition("task_manager.precondition_active_task")
		
		phr = dlg:AddPhrase("tm_"..parent.."_job_what", tostring(self.task_info[v].desc_phrase_id), tostring(self.task_info[v].init_phrase_id), -10000)
		
		phr = dlg:AddPhrase("tm_job_refuse", tostring(self.task_info[v].yes_phrase_id), tostring(self.task_info[v].desc_phrase_id), -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_refuse_task")
			
		phr = dlg:AddPhrase("tm_job_nothing", tostring(self.task_info[v].no_phrase_id), tostring(self.task_info[v].desc_phrase_id),-10000)
	end

end

function CRandomTask:on_first_update()
	for _, type in ipairs({"eliminate_lager", "defend_lager"}) do
		for k,v in pairs(self.task_id_by_type[type]) do
			local name = self.task_info[v].target
			local sobj = name and alife():object(name)
			if sobj and sobj:clsid() == clsid.smart_terrain then
				if type == "defend_lager" then
					local sm_ini = sobj:spawn_ini()
					self.task_info[v].defend_target = utils.cfg_get_number(sm_ini, "random_task", "defend_target", nil, true)
					if not self.task_info[v].defend_target then
						goto CONTINUE
					end
				end
				if not self.task_info[v].target_objects then self.task_info[v].target_objects = {} end
				table.insert(self.task_info[v].target_objects, sobj.id)
				::CONTINUE::
			end
		end
	end
end

function get_random_task()
	if not random_task then
		random_task = CRandomTask()
	end
	return random_task
end


function init_trader_task_dialog(...)
	get_random_task():init_task_dialog(..., "trader")
end
function init_barman_task_dialog(...)
	get_random_task():init_task_dialog(..., "barman")
end
function init_ecolog_task_dialog(...)
	get_random_task():init_task_dialog(..., "ecolog")
end
function init_dolg_task_dialog(...)
	get_random_task():init_task_dialog(..., "dolg")
end
function init_freedom_task_dialog(...)
	get_random_task():init_task_dialog(..., "freedom")
end


function init_shustriy_task_dialog(...)
	get_random_task():init_task_dialog(..., "shustriy")
end
function init_lisiy_task_dialog(...)
	get_random_task():init_task_dialog(..., "lisiy")
end
function init_hunter_task_dialog(...)
	get_random_task():init_task_dialog(..., "hunter")
end
function init_drunk_dolg_task_dialog(...)
	get_random_task():init_task_dialog(..., "drunk_dolg")
end
function init_petrenko_task_dialog(...)
	get_random_task():init_task_dialog(..., "petrenko")
end
function init_wolf_task_dialog(...)
	get_random_task():init_task_dialog(..., "wolf")
end
function init_zastava_commander_task_dialog(...)
	get_random_task():init_task_dialog(..., "zastava_commander")
end
function init_mercenary_task_dialog(...)
	get_random_task():init_task_dialog(..., "mercenary")
end


function init_trader_reward_dialog(...)
	get_random_task():init_reward_dialog(..., "trader")
end
function init_barman_reward_dialog(...)
	get_random_task():init_reward_dialog(..., "barman")
end
function init_ecolog_reward_dialog(...)
	get_random_task():init_reward_dialog(..., "ecolog")
end
function init_dolg_reward_dialog(...)
	get_random_task():init_reward_dialog(..., "dolg")
end
function init_freedom_reward_dialog(...)
	get_random_task():init_reward_dialog(..., "freedom")
end


function init_shustriy_reward_dialog(...)
	get_random_task():init_reward_dialog(..., "shustriy")
end
function init_lisiy_reward_dialog(...)
	get_random_task():init_reward_dialog(..., "lisiy")
end
function init_hunter_reward_dialog(...)
	get_random_task():init_reward_dialog(..., "hunter")
end
function init_drunk_dolg_reward_dialog(...)
	get_random_task():init_reward_dialog(..., "drunk_dolg")
end
function init_petrenko_reward_dialog(...)
	get_random_task():init_reward_dialog(..., "petrenko")
end
function init_wolf_reward_dialog(...)
	get_random_task():init_reward_dialog(..., "wolf")
end
function init_zastava_commander_reward_dialog(...)
	get_random_task():init_reward_dialog(..., "zastava_commander")
end
function init_mercenary_reward_dialog(...)
	get_random_task():init_reward_dialog(..., "mercenary")
end

function wolf_is_on_cordon()
	return level.name() == "l01_escape"
end
function wolf_is_on_military()
	return level.name() == "l07_military"
end
function has_active_vendor_task(...)
	return get_random_task():active_parent_task(...)
end
function precondition_task_avail(...)
	return get_random_task():task_avail(...)
end
function precondition_active_task(...)
	return get_random_task():active_task(...)
end

function precondition_vendor_can_task(npc, actor, ...)
	return get_random_task():parent_can_task(actor, npc, ...)
end
function precondition_vendor_cannot_task(...)
	return not precondition_vendor_can_task(...)
end
function precondition_have_completed_job(npc, actor)
	return get_random_task():have_completed_job(actor, npc)
end
function precondition_dont_have_completed_job(...)
	return not precondition_have_completed_job(...)
end

function action_task_show(...)
	get_random_task():action_task_show(...)
end
function action_give_task(...)
	get_random_task():action_give_task(...)
end
function action_refuse_task(...)
	get_random_task():action_refuse_task(...)
end
function action_task_reward(...)
	get_random_task():task_reward(...)
end
function reward_by_task(...)	
	get_random_task():task_reward_storyline(...)
end

function task_complete(...)
	return get_random_task():task_complete(...)
end
function task_fail(...)
	return get_random_task():task_fail(...)
end
function task_callback(...)
	return get_random_task():task_callback(...)
end

function save()
	get_random_task():save()
end
function load()
	get_random_task():load()
end

function show_reward(actor, npc, p1, p2)
	local item_texture, item_rect = get_texture_info("ui_iconsTotal_find_item")
	local task_details = get_random_task().task_info[get_random_task().task_id_by_desc_phrase_id[p2]]
	if task_details == nil then return end
	if not task_details.reward_item and not task_details.reward_money then return end
	--
	local rt = ogse_random_task_reward.random_task_reward( task_details.parent, get_random_task().task_id_by_desc_phrase_id[p2] )
	if rt.random_task_reward_accept == 1 and rt.difficult_list[get_random_task().task_id_by_desc_phrase_id[p2]] then
		return
	end
	--
	db.actor:give_talk_message(game.translate_string("show_reward"), item_texture, item_rect, "other_iconed_answer_item")
	--
	if task_details.reward_item then
		local rwd = {}
		for _, sect in ipairs(task_details.reward_item) do
			rwd[sect] = not rwd[sect] and 1 or rwd[sect] + 1
		end
		for sect, num in pairs(rwd) do
			db.actor:give_talk_message(
				( num > 1 and num .. " x " or "" ) .. dsh.strip_quotes( game.translate_string( get_string( sect, "inv_name" ) ) )
				, item_texture, item_rect, "other_iconed_answer_item"
			)
		end
	end
	--
	if task_details.reward_money then 
		local money_texture, money_rect = get_texture_info("ui_iconsTotal_found_money")
		db.actor:give_talk_message(task_details.reward_money .. " RU", money_texture, money_rect, "other_iconed_answer_item")
	end
end
