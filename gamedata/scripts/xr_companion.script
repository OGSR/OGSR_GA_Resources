-- -*- mode: lua; coding: windows-1251-dos -*-

----------------------------------------------------------------------------------------------------
-- Companion
----------------------------------------------------------------------------------------------------
-- Разработчик: Serhiy Vynnychenko (narrator@gsc-game.kiev.ua)
-- Доработки: Andrey Fidrya (Zmey) af@svitonline.com
----------------------------------------------------------------------------------------------------
-- Реанимация схемы для применения в релизной версии, доработка: KamikaZze kamikazze-ru@yandex.ru
-- Идея системы телепортации: Malandrinus
----------------------------------------------------------------------------------------------------
-- Версия 2.25 -- боевка сделана отдельной схемой и вынесена полностью в отдельный скрипт
----------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------
-- Возможные коммунити актора:
-- actor			- одиночка
-- actor_dolg		- долговец
-- actor_freedom	- свободовец
-- actor_zombied	- зомбированный
-- actor_prebandit	- помощник бандитов
-- bandit			- бандит
-- mil_stalker		- военсталкер
----------------------------------------------------------------------------------------------------

local sm = ogse_signals.get_mgr()
local subscribed

function subscribe(id)
	if not subscribed then
		subscribed = {
			{ signal = "on_update",			fun = this.check_in_car },
			{ signal = "on_npc_spawn",		fun = this.on_npc_spawn },
			{ signal = "on_npc_death",		fun = this.companion_death },
		}
		for _, v in pairs(subscribed) do
			sm:subscribe(v)
		end
		--log3("--[%s] subscribed signals", script_name())
	end
	xr_combat_companion.subscribe(id)
end

function unsubscribe(id)
	if subscribed and next(companions) == nil then
		for _, v in pairs(subscribed) do
			sm:unsubscribe(v)
		end
		subscribed = nil
		--log3("~~[%s] UNsubscribed signals", script_name())
	end
	xr_combat_companion.unsubscribe(id)
end

function on_npc_spawn( obj )
	if xr_companion.is_companion( obj:id() ) then
		local new_str = game.translate_string("companion_signal1")
		new_str = new_str.." "
		new_str = new_str..obj:character_name()
		new_str = new_str.." "
		new_str = new_str..game.translate_string("companion_signal2")
		db.actor:give_game_news(new_str, "ui\\ui_iconsTotal", Frect():set(0,235,83,47), 0, 15000)
	end
end

----------------------------------------------------------------------------------------------------
number_of_companions = 0
companions = {}

local prohibit_rpg_7 = true

local desired_distance = 3
local min_distance = 1.5
local max_distance = 25 -- дальше этого расстояния напарник будет бежать к вам забыв про врагов

local keep_state_min_time = 1000 -- переключившись в состояние (бег, ходьба, спринт), не переключаться в другое N ms

local dist_walk = 5 -- < dist_run
local dist_run = 15
-- otherwise - sprint

local sound_wait = {
	"weather,state",
	-- если когда-то появятся ещё звуковые темы, их можно поставить сюда
}
local sound_prob = 0.2
local testing_sound = false

-- Модели поведения:
beh_walk_simple = 0
beh_walk_low_aggr = 8
beh_walk_ignore = 2

beh_crouch_simple = 1
beh_crouch_low_aggr = 9
beh_crouch_ignore = 4

beh_wait_simple = 3
beh_wait_low_aggr = 10
beh_wait_ignore = 5

beh_hide_simple = 6
beh_hide_low_aggr = 11
beh_hide_ignore = 7

--beh_wait_near = 4
--beh_walk_near = 1

local range_normal = 150
local fov_normal = 360

local mt_stand = 0
local mt_walk = 1
local mt_run = 2
local mt_sprint = 3

local keep_state_until = time_global()
local last_state = {}
local assist_point = {}
local locked_vertexes 		= {}		-- занятые вертексы
local talking_time = 5000
local talking_npc = {}

being_attacked = false --KRodin: хм, а при нескольких напарниках оно нормально работает? Если будут проблемы - завести массив и там этот флаг хранить для каждого.
--actor_attacked = false --нигде не меняется

-----------------------------------------------------
--- каких групп бывают напарники
-----------------------------------------------------
local suitable_communities = {
	["stalker"] = true,
	["quest_stalker"] = true,
	["dolg"] = true,
	["freedom"] = true,
	["zombied"] = true,
	["bandit"] = true,
	["actor_prebandit"] = true,
	["mil_stalker"] = true,
}

-----------------------------------------------------
-- Типы боеприпасов
-- 1 - пистолетный
-- 2 - дробовой
-- 3 - промежуточный
-- 4 - винтовочный
-- 5 - тяжелое оружие
-----------------------------------------------------
local ammo_types = {
[1]						= {
	[1] = "9x18",
	[2] = "9x19",
	[3] = "7.62x25",
	[4] = "11.43x23",
	[5] = "arbolt"
},
[2]						= {
	[1] = "12x7"
},
[3]						= {
	[1] = "5.45x39",
	[2] = "5.56x45",
	[3] = "7.62x39",
	[4] = "9x39"
},
[4]						= {
	[1] = "7.62x54",
	[2] = "gauss",
	[3] = "8.6x70"
},
[5] 					= {
	[1] = "vog",
	[2] = "m20",
	[3] = "og-7",
	[4] = "flame"
}
}
-----------------------------------------------------
-- Классы оружия
-- первая цифра тип патрона
-- вторая цифра флаг наличия авт. режима огня
-----------------------------------------------------
weapon_class = {
[10] = "pistol",
[11] = "submashinegun",
[20] = "shotgun",
[21] = "assault_shotgun",
[30] = "carbine",
[31] = "assault_rifle",
[40] = "sniper_rifle",
[41] = "mashinegun",
[50] = "grenade_launcher",
[51] = "flamethrower"

}
-----------------------------------------------------
-- список оружия по классам - пришлось сделать потому,
-- что функции чтения ini не могу считывать родительские
-- параметры, как это ни странно
-----------------------------------------------------
local weapons_list = {

-- пистолеты
["wpn_pm"]				= 10,
["wpn_pb"]				= 10,
["wpn_fort"]			= 10,
["wpn_stechkin"]		= 10,
["wpn_hpsa"]			= 10,
["wpn_beretta"]			= 10,
["wpn_fiveseven"]		= 10,
["wpn_glock"]	    	= 10,
["wpn_grach"]	    	= 10,
["wpn_gsh18"]	    	= 10,
["wpn_walther"]			= 10,
["wpn_sr1m"]	    	= 10,
["wpn_usp"]				= 10,
["wpn_sig220"]	    	= 10,
["wpn_colt1911"]		= 10,
["wpn_desert_eagle"]	= 10,

--Дробовики
["wpn_bm16"]			= 20,
["wpn_bm16_full"]		= 20,
["wpn_toz34"]			= 20,
["wpn_toz34_full"]		= 20,
["wpn_saiga12"]			= 20,

--ПП
["wpn_bizon"]			= 11,
["wpn_mp5"]				= 11,
["wpn_p90"]				= 11,
["wpn_ump45"]			= 11,

--Штурмовые
["wpn_abakan"]			= 31,
["wpn_ak74u"]			= 31,
["wpn_ak74"]			= 31,
["wpn_ak101"]			= 31,
["wpn_l85"]				= 31,
["wpn_groza"]			= 31,
["wpn_sig550"]			= 31,
["wpn_sig552"]			= 31,
["wpn_val"]				= 31,

--Снайперки
["wpn_vintorez"]		= 40,
["wpn_svu"]				= 40,
["wpn_svd"]				= 40,
["wpn_gauss"]			= 40,

--Тяжелое
["wpn_rpg7"]				= 50,
}
-----------------------------------------------------
-- Получение оружия по параметрам из таблицы
-----------------------------------------------------
function get_parameters_from_table(weapon_sect)
	if weapons_list[weapon_sect] then
		return weapons_list[weapon_sect]
	else	
		for k,v in pairs(weapons_list) do
			if string.find(weapon_sect, k) then
				return v
			end
		end
		return 0
	end
end
-----------------------------------------------------
-- в этой табличке хранится выбранный тип оружия для напарника в виде companion_weapon[npc:id()] = "выбранный_тип"
-- разрешение использовать любое оружие == "anything"
-----------------------------------------------------
local companion_weapon = {}
-----------------------------------------------------
-- в этой табличке хранится список типов оружия которые есть у напарника
-- структура:
-- companion_has = {
	-- [ид_компаньона] = {
		-- pistol = true,
		-- submashinegun = true,
		-- shotgun = true,
		-- assault_shotgun = false,
		-- carbine = false,
		-- assault_rifle = false,
		-- sniper_rifle = false,
		-- mashinegun = false,
		-- grenade_launcher = false,
		-- flamethrower = false		
	-- }
-- }
-----------------------------------------------------
local companion_has = {}
-----------------------------------------------------
-- Селектор вооружения (будет работать только с менеджером вооружений)
-----------------------------------------------------
function check_weapon(weapon_section, npc_id)
	if weapon_section and npc_id then
		if not companion_weapon[npc_id] or (companion_weapon[npc_id] and companion_weapon[npc_id] == "anything") then
			return true
		end
		if string.find(weapon_section, "grenade") or string.find(weapon_section, "knife") then
			return true
		end		
		local ammo_type = 0
		local fire_mode = 5
		local stop_flag = 0
		local w_cl = 0
		w_cl = get_parameters_from_table(weapon_section)
		if w_cl == 0 then
			log1("!!!ERROR - Companion weapon selector cannot find ammo class or mode for "..weapon_section.."!!! Will use configs instead!")
			if sys_ini:line_exist(weapon_section, "ammo_class") then
				local ammo = sys_ini:r_string(weapon_section, "ammo_class")
				for k, v in pairs(ammo_types) do
					local search_patterns = v
					if search_patterns then
						for kk, vv in pairs(search_patterns) do
							if string.find(ammo, vv) then
								ammo_type = k
								stop_flag = 1
								break
							end
						end
					end
					if stop_flag == 1 then
						break
					end
				end
			end			
			if sys_ini:line_exist(weapon_section, "fire_modes") then
				local fm = sys_ini:r_string(weapon_section, "fire_modes")
				if string.find(fm,"-1") then
					fire_mode = 1 -- автоматическое оружие
				else	
					fire_mode = 0
				end
			end			
			w_cl = tonumber(tostring(ammo_type)..tostring(fire_mode))
		end
		-- get_parameters_from_table
		local current_weapon_class = weapon_class[w_cl]
		if current_weapon_class then
			local comp_weap = companion_weapon[npc_id]
			if comp_weap ~= current_weapon_class then
				return false
			else
				return true
			end
		else
			log1("!!!ERROR - Companion weapon selector cannot find weapon_class for WPN "..weapon_section.." ammo "..tostring(ammo_type).." and fire_mode "..tostring(fire_mode).."!!!")
			return false
		end
	end
	return false
end

-----------------------------------------------------
-- Заполнение типов оружия которые есть в наличии
-----------------------------------------------------
function no_best_enemy(actor, npc)
	-- local enemy = npc:best_enemy()
	-- if not enemy then return true else return false end
	return true
end

function search_for_weapons(actor, npc)
	companion_has = {}
	companion_has[npc:id()] = {
		pistol = false,
		submashinegun = false,
		shotgun = false,
		assault_shotgun = false,
		carbine = false,
		assault_rifle = false,
		sniper_rifle = false,
		mashinegun = false,
		grenade_launcher = false,
		flamethrower = false		
	}
	npc:iterate_inventory(search_weapon,npc)
	local item_in_slot_1 = npc:item_in_slot(1)
	local item_in_slot_2 = npc:item_in_slot(2)
	if item_in_slot_1 then
		search_weapon(npc, item_in_slot_1)
	end
	if item_in_slot_2 then
		search_weapon(npc, item_in_slot_2)
	end
end
-----------------------------------------------------
-- Итератор поиска
-----------------------------------------------------
function search_weapon(npc, item)
	local ammo = 0
	local mode = 5
	local stop_flag = 0
	if npc and item and item:is_weapon_magazined() then
		local weapon_section = item:section()
		if string.find(weapon_section, "grenade") then
			return
		end
		local w_cl = 0
		w_cl = get_parameters_from_table(weapon_section)
		if w_cl == 0 then
			log1("!!!ERROR - Companion weapon selector cannot find ammo class or mode for "..weapon_section.."!!!")
			if sys_ini:line_exist(weapon_section, "ammo_class") then
				local ammo_string = sys_ini:r_string(weapon_section, "ammo_class")
				for k, v in pairs(ammo_types) do
					local search_patterns = v
					if search_patterns then
						for kk, vv in pairs(search_patterns) do
							if string.find(ammo_string, vv) then
								ammo = k
								stop_flag = 1
								break
							end
						end
					end
					if stop_flag == 1 then
						break
					end
				end
			end		
			if sys_ini:line_exist(weapon_section, "fire_modes") then
				local fm = sys_ini:r_string(weapon_section, "fire_modes")
				if string.find(fm,"-1") then
					mode = 1
				else	
					mode = 0
				end		
			end
			w_cl = tonumber(tostring(ammo)..tostring(mode))
		end
		--log1("FOUND "..weapon_section.." CLASS "..w_cl)
		if weapon_class[w_cl] then
			if not companion_has[npc:id()] then
				companion_has[npc:id()] = {
					pistol = false,
					submashinegun = false,
					shotgun = false,
					assault_shotgun = false,
					carbine = false,
					assault_rifle = false,
					sniper_rifle = false,
					mashinegun = false,
					grenade_launcher = false,
					flamethrower = false		
				}
			end
			if weapon_class[w_cl] == "pistol" then
				companion_has[npc:id()].pistol = true
			elseif weapon_class[w_cl] == "submashinegun" then
				companion_has[npc:id()].submashinegun = true
			elseif weapon_class[w_cl] == "shotgun" then
				companion_has[npc:id()].shotgun = true
			elseif weapon_class[w_cl] == "assault_shotgun" then
				companion_has[npc:id()].assault_shotgun = true
			elseif weapon_class[w_cl] == "carbine" then
				companion_has[npc:id()].carbine = true
			elseif weapon_class[w_cl] == "assault_rifle" then
				companion_has[npc:id()].assault_rifle = true
			elseif weapon_class[w_cl] == "sniper_rifle" then
				companion_has[npc:id()].sniper_rifle = true
			elseif weapon_class[w_cl] == "mashinegun" then
				companion_has[npc:id()].mashinegun = true
			elseif weapon_class[w_cl] == "grenade_launcher" then
				companion_has[npc:id()].grenade_launcher = true
			elseif weapon_class[w_cl] == "flamethrower" then
				companion_has[npc:id()].flamethrower = true
			end
		else
			log1("!!!ERROR - Companion weapon selector cannot find weapon_class for WPN "..weapon_section.." ammo "..tostring(ammo).." and fire_mode "..tostring(mode).."!!!")
		end
	end
end
-----------------------------------------------------
-- Приказы на смену оружия
-----------------------------------------------------
----------------------------------
local function update_wmgr(npc) --Принудительное обновление оружейного менеджера
	local st = rx_ai.get_storage( npc:id() )
	if st and st.wm then
		st.wm.refresh_weapon_list = true
	end
end
----------------------------------
function set_weapon_anyting(actor, npc)
	if npc then
		companion_weapon[npc:id()] = "anything"
		save_var_companion(npc:id(),"weapon_behavior",companion_weapon[npc:id()])
		update_wmgr(npc)
	end
end
function set_weapon_pistol(actor, npc)
	if npc then
		companion_weapon[npc:id()] = "pistol"
		save_var_companion(npc:id(),"weapon_behavior",companion_weapon[npc:id()])
		update_wmgr(npc)
	end
end
function set_weapon_submashinegun(actor, npc)
	if npc then
		companion_weapon[npc:id()] = "submashinegun"
		save_var_companion(npc:id(),"weapon_behavior",companion_weapon[npc:id()])
		update_wmgr(npc)
	end
end
function set_weapon_shotgun(actor, npc)
	if npc then
		companion_weapon[npc:id()] = "shotgun"
		save_var_companion(npc:id(),"weapon_behavior",companion_weapon[npc:id()])
		update_wmgr(npc)
	end
end
function set_weapon_assault_shotgun(actor, npc)
	if npc then
		companion_weapon[npc:id()] = "assault_shotgun"
		save_var_companion(npc:id(),"weapon_behavior",companion_weapon[npc:id()])
		update_wmgr(npc)
	end
end
function set_weapon_carbine(actor, npc)
	if npc then
		companion_weapon[npc:id()] = "carbine"
		save_var_companion(npc:id(),"weapon_behavior",companion_weapon[npc:id()])
		update_wmgr(npc)
	end
end
function set_weapon_assault_rifle(actor, npc)
	if npc then
		companion_weapon[npc:id()] = "assault_rifle"
		save_var_companion(npc:id(),"weapon_behavior",companion_weapon[npc:id()])
		update_wmgr(npc)
	end
end
function set_weapon_sniper_rifle(actor, npc)
	if npc then
		companion_weapon[npc:id()] = "sniper_rifle"
		save_var_companion(npc:id(),"weapon_behavior",companion_weapon[npc:id()])
		update_wmgr(npc)
	end
end
function set_weapon_mashinegun(actor, npc)
	if npc then
		companion_weapon[npc:id()] = "mashinegun"
		save_var_companion(npc:id(),"weapon_behavior",companion_weapon[npc:id()])
		update_wmgr(npc)
	end
end
function set_weapon_grenade_launcher(actor, npc)
	if npc then
		companion_weapon[npc:id()] = "grenade_launcher"
		save_var_companion(npc:id(),"weapon_behavior",companion_weapon[npc:id()])
		update_wmgr(npc)
	end
end
function set_weapon_flamethrower(actor, npc)
	if npc then
		companion_weapon[npc:id()] = "flamethrower"
		save_var_companion(npc:id(),"weapon_behavior",companion_weapon[npc:id()])
		update_wmgr(npc)
	end
end
-----------------------------------------------------
-- Прекондишены оружейных фраз
-----------------------------------------------------
function has_pistol(actor, npc)
	if companion_has[npc:id()] and companion_has[npc:id()].pistol == true then
		return true
	elseif companion_has[npc:id()].pistol == false then
		return false
	else
		--log1("!!!ERROR - Companion weapon selector wasn't fill table companion_has !!!")
		return false
	end
end
function has_submashinegun(actor, npc)
	if companion_has[npc:id()] and companion_has[npc:id()].submashinegun == true then
		return true
	elseif companion_has[npc:id()].submashinegun == false then
		return false
	else
		--log1("!!!ERROR - Companion weapon selector wasn't fill table companion_has !!!")
		return false
	end
end
function has_shotgun(actor, npc)
	if companion_has[npc:id()] and companion_has[npc:id()].shotgun == true then
		return true
	elseif companion_has[npc:id()].shotgun == false then
		return false
	else
		--log1("!!!ERROR - Companion weapon selector wasn't fill table companion_has !!!")
		return false
	end
end
function has_assault_shotgun(actor, npc)
	if companion_has[npc:id()] and companion_has[npc:id()].assault_shotgun == true then
		return true
	elseif companion_has[npc:id()].assault_shotgun == false then
		return false
	else
		--log1("!!!ERROR - Companion weapon selector wasn't fill table companion_has !!!")
		return false
	end
end
function has_carbine(actor, npc)
	if companion_has[npc:id()] and companion_has[npc:id()].carbine == true then
		return true
	elseif companion_has[npc:id()].carbine == false then
		return false
	else
		--log1("!!!ERROR - Companion weapon selector wasn't fill table companion_has !!!")
		return false
	end
end
function has_assault_rifle(actor, npc)
	if companion_has[npc:id()] and companion_has[npc:id()].assault_rifle == true then
		return true
	elseif companion_has[npc:id()].assault_rifle == false then
		return false
	else
		--log1("!!!ERROR - Companion weapon selector wasn't fill table companion_has !!!")
		return false
	end
end
function has_sniper_rifle(actor, npc)
	if companion_has[npc:id()] and companion_has[npc:id()].sniper_rifle == true then
		return true
	elseif companion_has[npc:id()].sniper_rifle == false then
		return false
	else
		--log1("!!!ERROR - Companion weapon selector wasn't fill table companion_has !!!")
		return false
	end
end
function has_mashinegun(actor, npc)
	if companion_has[npc:id()] and companion_has[npc:id()].mashinegun == true then
		return true
	elseif companion_has[npc:id()].mashinegun == false then
		return false
	else
		--log1("!!!ERROR - Companion weapon selector wasn't fill table companion_has !!!")
		return false
	end
end
function has_grenade_launcher(actor, npc)
	if companion_has[npc:id()] and companion_has[npc:id()].grenade_launcher == true and not prohibit_rpg_7 then
		return true
	elseif companion_has[npc:id()].grenade_launcher == false then
		return false
	else
		--log1("!!!ERROR - Companion weapon selector wasn't fill table companion_has !!!")
		return false
	end
end
function has_flamethrower(actor, npc)
	if companion_has[npc:id()] and companion_has[npc:id()].flamethrower == true then
		return true
	elseif companion_has[npc:id()].flamethrower == false then
		return false
	else
		--log1("!!!ERROR - Companion weapon selector wasn't fill table companion_has !!!")
		return false
	end
end

-----------------------------------------------------
-- Система телепортации
-----------------------------------------------------
-- Принцип работы:
-- 1) Актор на уровне, схема "следуй за мной" -- запретить уход в оффлайн
-- 2) Актор на уровне, схема "жди тут" -- не принимать задания алайфа, стоять на месте
-- 3) Актор на уровне, в машине, схема "следуй за мной" -- выводим в офф и телепортируем за актором
-- 4) Актор на другом уровне, схема "следуй за мной" -- телепортируем за актором
-- 5) Актор на другом уровне, схема "жди тут" -- не принимать задания алайфа, стоять на месте
-----------------------------------------------------
-- teleport_on_actor_level - Телепортация напарника на другую локацию, использует добавленную в движок teleport_object (точнее она там была, и её восстановили)
-----------------------------------------------------
-- check_in_car - проверка в машине ли ГГ
-----------------------------------------------------
-- Функция для перехода с локации на локацию
-----------------------------------------------------
function teleport_on_actor_level(npc_id, s_npc)
	if level.name() ~= object_level_name(s_npc) then
		local actor = db.actor
		-- недурно бы телепортнуться
		local gvid = alife():actor().m_game_vertex_id 
		local lvid = alife():actor().m_level_vertex_id
		local pos = alife():actor().position
		pos.x = pos.x + 5
		pos.z = pos.z -- + 2
		alife():teleport_object(npc_id, pos, lvid, gvid)
	end
end
-----------------------------------------------------
-- Проверка на сидение в машине
-----------------------------------------------------
function is_inside_my_car()
	local car = ogse_car_control.current_car
	if car then -- если ГГ уже в машине
		local is_inside = 0
		for id, _ in pairs(companions) do
			local inside = load_var_companion(id,"in_car","false")
			local last_car = tonumber(load_var_companion(id,"last_car",0))
			if inside == "true" and tonumber(car:id()) == tonumber(last_car) then
				is_inside = 1
			end
		end
		if is_inside == 1 then
			return true
		else
			return false
		end
	else	
		return false
	end
	return false
end

function check_in_car()
	sm:reschedule( math.random(2000, 3000) )

	local car = ogse_car_control.current_car
	if car then
		-- выводим в оффлайн
		for id, _ in pairs(companions) do
				local w_level = load_var_companion(id,"w_lvl",nil)
				local icon = load_var_companion(id,"last_car",nil)
				if not w_level or w_level == "" or w_level == "nil" then
					local npc = level.object_by_id(id)
					if npc and car then
						local s_npc = alife():object(id)
						if s_npc then
							teleport_on_actor_level(id, s_npc) --Если напарник на другой локации, телепортируем его
							local distance = npc:position():distance_to(car:position())  
							local inside = load_var_companion(id,"in_car","false")
							if distance > 7 and inside == "false" then
								return
							end
							-- вывели
							s_npc.force_offline = true
							if not icon then
								s_npc:visible_for_map(false)
								if level.map_has_object_spot( car:id(), "alife_presentation_companion" ) ~= 1 then
									level_tasks.add_location_by_id( car:id(), "alife_presentation_companion", game.translate_string("it_is_your_companion_text") )
								end
								save_var_companion(id,"last_car",car:id())
								save_var_companion(id,"in_car","true")
							end
						else	
							log1("ERROR! Cannot get companion s_obj!")
						end
					end	
				end
		end
	else
		-- обратно в онлайн
		for id, _ in pairs(companions) do
			if not level.object_by_id(id) then
				local w_level = load_var_companion(id,"w_lvl",nil)
				local s_npc = alife():object(id)
				if s_npc and (not w_level or w_level == "" or w_level == "nil") then
					teleport_on_actor_level(id, s_npc) --Если напарник на другой локации, телепортируем его
					local pos = alife():actor().position
					local last_car = tonumber(load_var_companion(id,"last_car",0))
					pos.x = pos.x + 4
					pos.z = pos.z + 4
					s_npc.m_game_vertex_id = alife():actor().m_game_vertex_id
					s_npc.m_level_vertex_id = alife():actor().m_level_vertex_id
					s_npc.position = pos					
					s_npc.force_offline = nil
					if last_car ~= 0 then
						if level.map_has_object_spot( last_car, "alife_presentation_companion" ) == 1 then
							level_tasks.remove_location_by_id( last_car, "alife_presentation_companion" )
						end
						s_npc:visible_for_map(true)
						save_var_companion(id,"in_car","false")
					end
					save_var_companion(id,"last_car",nil)
				end
			end
		end
	end
end
-----------------------------------------------------
-- Функции сохранения и выгрузки из хранилища
-----------------------------------------------------
-- Переменные напарника в хранилища
-----------------------------------------------------
-- is_companion - компаньон ли сейчас
-- companion_behavior - номер модели поведения
-- actor_level - текущий уровень актора
-- orig_community - родное коммунити
-- friendship_status - родное отношение к ГГ
-- actor_rep - репа актора (на будущее)
-- actor_debt - долг актора (на будущее)
-----------------------------------------------------

function community_by_actor(actor_comm)

	local return_community = "stalker"

	if actor_comm then
		if actor_comm == "actor" then
			return_community = "stalker"
		elseif actor_comm == "actor_dolg" then
			return_community = "dolg"
		elseif actor_comm == "actor_freedom" then
			return_community = "freedom"	
		elseif actor_comm == "bandit" then
			return_community = "bandit"		
		elseif actor_comm == "actor_prebandit" then
			return_community = "actor_prebandit"	
		elseif actor_comm == "actor_zombied" then
			return_community = "zombied"	
		elseif actor_comm == "mil_stalker" then
			return_community = "mil_stalker"			
		end
	
	end
	
	return return_community
end

function set_community_by_actor()
	for id, _ in pairs(companions) do
		ASSERT(alife():object(id), "") --Такого быть не должно
		level.client_spawn_manager():add( id, -1, function(id, obj) --Вместо сохраняемого таймера лучше сделать так, если даже не сработает - вроде как не страшно. Напарник даже если враг - атаковать актора всё равно не должен.
			obj:set_character_community(community_by_actor(db.actor:character_community()), 0, 0)
		end )
	end
end

function save_var_companion(npc, var_name, var_value)

	if not npc or not var_name then return end
	local sobj = alife():object(npc)
	
	if sobj then
		
		if sobj.s_storage and sobj.s_storage ~= "_" then
			local npc_data = m_netpk.custom_data(sobj.s_storage)
			npc_data = npc_data:getTable()
			
			if not npc_data.companion_data then
				npc_data.companion_data = {}
			end
			
			npc_data.companion_data[var_name] = var_value
			local data_parsed = m_netpk.custom_data(npc_data)
			sobj.s_storage = data_parsed:getString()
			-- log1("V2 COMP VAR SAVED: "..tostring(var_name).." value "..tostring(var_value))
		else
			local npc_data = {}
			npc_data.companion_data = {}
			npc_data.companion_data[var_name] = var_value
			local data_parsed = m_netpk.custom_data(npc_data)
			sobj.s_storage = data_parsed:getString()
			-- log1("V1 COMP VAR SAVED: "..tostring(var_name).." value "..tostring(var_value))
		end

		-- log1("COMP SYNCHRONIZED!")
	
	end

end

function load_var_companion(npc, var_name, def_value)

	if not npc or not var_name then return end
	local sobj = alife():object(npc)
	
	if sobj and sobj.s_storage and sobj.s_storage ~= "_" then

		local npc_data = m_netpk.custom_data(sobj.s_storage)
		npc_data = npc_data:getTable()
		
		if npc_data.companion_data and npc_data.companion_data[var_name] then
			-- log1("COMP VAR RET: "..tostring(var_name).." value "..tostring(npc_data.companion_data[var_name]))
			return npc_data.companion_data[var_name]
		else	
			return def_value or nil
		end
		
	else	
		return def_value or nil
	end	

end

function init_danger_settings(npc)

	local storage = db.storage[npc:id()]
	local danger_settings = storage.danger
	
	storage.ignore_types = nil
	storage.ignore_types = {}
	storage.ignore_types["corpse"] = true 
	storage.ignore_types["sound"] = true
	
	npc:set_custom_panic_threshold(0.0)	
	
	if not danger_settings then
		storage.danger = {}
		danger_settings = storage.danger
	end
	
	danger_settings.ignore_distance			= 50
	danger_settings.ignore_distance_grenade	= 15
	danger_settings.ignore_distance_corpse	= 10
	danger_settings.ignore_distance_hit		= 80
	danger_settings.ignore_distance_sound		= 50

	danger_settings.danger_inertion_time_grenade	= 10000
	danger_settings.danger_inertion_time_corpse	= 5000
	danger_settings.danger_inertion_time_hit		= 10000
	danger_settings.danger_inertion_time_sound	= 5000
	danger_settings.danger_inertion_time_ricochet	= 10000	
	
end

----------------------------------------------------------------------------------------------------------------------

function companion_death(npc)
	if npc and is_companion(npc:id()) then
	
		local storage = db.storage[npc:id()]
		if storage then
			local scheme = storage.companion
			if scheme then
				scheme.enabled = false
			end
		end	
		
		number_of_companions = number_of_companions - 1
		companions[npc:id()] = nil
		
		level_tasks.remove_location_by_id(npc:id(), "alife_presentation_companion")
		
		local dead_friends = tonumber(ogse.load_variable("dead_fr", 0))
		dead_friends = dead_friends + 1
		ogse.save_variable("dead_fr", dead_friends)		
		
		if dead_friends < 4 then
			db.actor:give_game_news(game.translate_string("companion_messages").." "..npc:character_name().." "..game.translate_string("companion_died"), "ui\\ui_iconsTotal", Frect():set(0,235,83,47), 0, 15000)
		else
			db.actor:give_game_news(game.translate_string("companion_messages").." "..npc:character_name().." "..game.translate_string("companion_died_bad"), "ui\\ui_iconsTotal", Frect():set(0,235,83,47), 0, 15000)
		end

		unsubscribe(npc:id())
	end
end

function get_max_weapon_range(npc)
	if npc then
		local act_item = npc:active_item()
		if act_item and act_item:is_weapon() then
			local sect = act_item:section()
			if sys_ini:line_exist(sect, "max_radius") then
				local radius = sys_ini:r_s32(sect, "max_radius")
				return radius
			end
		else	
			return 0
		end
	else	
		return 0
	end
end

local last_weapon = {}

function check_lost_weapon(npc)
	local act_item = npc:active_item()
	if act_item and act_item:is_weapon() then
		if not last_weapon[npc:id()] then
			-- запуск - ещё нет никакого оружия
			last_weapon[npc:id()] = act_item:id()
		else
			-- уже сохранено значение оружия
			local last_weapon_obj = level.object_by_id(last_weapon[npc:id()])
			if last_weapon_obj then
				-- последнее оружие существует
				if act_item:id() == last_weapon[npc:id()] then
					-- и оно у нас в руках
					return false, nil, nil
				end				
				local parent = last_weapon_obj:parent()
				if parent then
					if parent:id() == npc:id() then
						-- оружие наше, просто не в руках банально
						last_weapon[npc:id()] = act_item:id()
						return false, nil, nil
					else
						-- кто-то забрал его уже, бесполезно трепыхаться
						last_weapon[npc:id()] = nil
						return false, nil, nil					
					end
				else
					-- проебали, надо подобрать
					-- log1("!!XR_COMP_LOST_WEAPON_1")
					return true, last_weapon_obj:level_vertex_id(), last_weapon_obj:id()
				end			
			else
				-- последнее оружие уже НЕ существует
				last_weapon[npc:id()] = nil
				return false, nil, nil
			end		
		end
	elseif not act_item then	
		if last_weapon[npc:id()] then
			local last_weapon_obj = level.object_by_id(last_weapon[npc:id()])
			if last_weapon_obj then
				local parent = last_weapon_obj:parent()
				if parent then
					if parent:id() == npc:id() then
						-- оружие наше, просто не в руках банально
						return false, nil, nil
					else
						-- кто-то забрал его уже, бесполезно трепыхаться
						last_weapon[npc:id()] = nil
						return false, nil, nil					
					end
				else
					-- проебали, надо подобрать
					-- log1("!!XR_COMP_LOST_WEAPON_2")
					return true, last_weapon_obj:level_vertex_id(), last_weapon_obj:id()
				end	
			else
				-- последнее оружие уже НЕ существует
				last_weapon[npc:id()] = nil
				return false, nil, nil
			end		
		end		
	end
	return false, nil, nil
end

----------------------------------------------------------------------------------------------------------------------

function beh_walk(mode, npc)
if db.actor:dont_has_info("dar_samogon_trance") then

	--log1("COMP_EXEC_GO "..tostring(npc:name()).." ACT "..tostring(mode))

	if not npc:alive() or xr_wounded.is_wounded(npc) then
		return
	end

	local stor = db.storage[npc:id()].companion

	local actor = db.actor
	local select_new_pt = false
	
	locked_vertexes[db.actor:id()] = db.actor:level_vertex_id()
	
	if (mode == "ignore" or mode == "ignore_c") then
		xr_combat_companion.dont_touch_us = true
	end
	
	local range = npc:range()
	local fov = npc:fov()	
	if range ~= range_normal or fov ~= fov_normal then
		npc:set_range(range_normal)
		npc:set_fov(fov_normal)
	end	
	
	local dist_from_self_to_actor = npc:position():distance_to(actor:position())
	local dist_from_assist_pt_to_actor
	
	local flag_actor_behind = false
	local dangerang = 1
	local ang = horz_angle(device().cam_dir, npc:position():sub(device().cam_pos))
	local tgt = ang > -dangerang and ang < dangerang
	if tgt then
		-- ГГ смотрит на напарника
		flag_actor_behind = true
	end	
	
	if assist_point[npc:id()] then
		dist_from_assist_pt_to_actor = level.vertex_position(assist_point[npc:id()]):distance_to(actor:position())
	else
		dist_from_assist_pt_to_actor = nil
	end
	
	if (dist_from_self_to_actor >= desired_distance and
	   (not dist_from_assist_pt_to_actor or
	    dist_from_assist_pt_to_actor >= desired_distance * 2)) then
		assist_point[npc:id()] = select_position(npc, stor)
		if not assist_point[npc:id()] then
			select_new_pt = true
		end
	elseif dist_from_self_to_actor <= 2 and flag_actor_behind then	
		assist_point[npc:id()] = select_position_get_away(npc, stor)
		if not assist_point[npc:id()] then
			select_new_pt = true
		end		
	end
	
	local weap_lost, vtx, lost_id = check_lost_weapon(npc)
	if weap_lost then
		select_new_pt = false
		assist_point[npc:id()] = vtx
		local last_weapon_obj = level.object_by_id(lost_id)
		if last_weapon_obj and npc:position():distance_to(last_weapon_obj:position()) <= 1.3 then
			last_weapon_obj:transfer_item(last_weapon_obj,npc)
		end
	end		
	
	-- 1. Если мы находимся за большим радиусом - необходимо выбрать новую точку
	if select_new_pt then
		assist_point[npc:id()] = select_position(npc, stor)
		if not assist_point[npc:id()] then
			return
		end
	elseif not assist_point[npc:id()] then
		return
	end
	
	if assist_point[npc:id()] then
		locked_vertexes[npc:id()] = assist_point[npc:id()]
	end

	-- 2. Двигаемся на точку: если точка далеко - бежим, иначе идем

	npc:set_detail_path_type(move.curve)
	npc:set_path_type(game_object.level_path)
	utils.send_to_nearest_accessible_vertex(npc, assist_point[npc:id()])
	
	local dist_to_assist_pt = level.vertex_position(assist_point[npc:id()]):distance_to(npc:position())

	local new_state

	if npc:level_vertex_id() == assist_point[npc:id()] then
		-- Уже пришли на точку отхода, разрешить еще раз начать отход
		-- (случай, когда игрок подошел слишком близко к ассистенту)
		if (mode == "simple" or mode == "simple_la") then
			new_state = "guard"
		elseif mode == "ignore" then
			new_state = "wait"			
		elseif (mode == "simple_c" or mode == "simple_c_la") then	
			new_state = "hide"
		elseif mode == "ignore_c" then
			new_state = "hide_no_wpn"
		end
	else
		local t = time_global()
		if t >= keep_state_until then
			keep_state_until = t + keep_state_min_time

			if dist_to_assist_pt <= dist_walk then
				if (mode == "simple" or mode == "simple_la") then
					new_state = "patrol"
				elseif mode == "ignore" then
					new_state = "walk"
				elseif (mode == "simple_c" or mode == "simple_c_la") then
					new_state = "sneak"
				elseif mode == "ignore_c" then
					new_state = "sneak_no_wpn"
				end				
			elseif dist_to_assist_pt <= dist_run then
				if (mode == "simple" or mode == "simple_la") then
					new_state = "rush"
				elseif mode == "ignore" then
					new_state = "run"		
				elseif (mode == "simple_c" or mode == "simple_c_la") then	
					new_state = "sneak_run"
				elseif mode == "ignore_c" then
					new_state = "sneak_run_no_wpn"
				end				
			else
				if (mode == "simple" or mode == "simple_la") then
					new_state = "sprint_p"
				elseif mode == "ignore" then
					new_state = "run_p"		
				elseif (mode == "simple_c" or mode == "simple_c_la") then
					new_state = "sneak_run"
				elseif mode == "ignore_c" then
					new_state = "sneak_run_no_wpn"
				end						
			end
		end
	end
	
	if new_state then
		state_mgr.set_state( script_name(), npc, new_state)
		last_state[npc:id()] = new_state
	elseif last_state[npc:id()] then
		state_mgr.set_state( script_name(), npc, last_state[npc:id()])
	end 

	-- 4. Если стоим на точке - петь песенки и прочую херню
	if (mode == "simple" or mode == "ignore" or mode == "simple_la") then
		local silence_interval = math.random(30000,55000)
		if testing_sound then
			silence_interval = 6000
		end
		if math.random() < sound_prob then
			if not talking_npc[npc:id()] then
				xr_sound.set_sound(npc, sound_wait[math.random(1,#sound_wait)])
				talking_npc[npc:id()] = time_global()
			elseif talking_npc[npc:id()] then	
				local period = time_global() - talking_npc[npc:id()]
				if period < 5000 then
					xr_sound.set_sound(npc, sound_wait[math.random(1,#sound_wait)])
				elseif period >= 5000 and period < silence_interval then
					xr_sound.set_sound(npc, nil)
				elseif period >= silence_interval then	
					xr_sound.set_sound(npc, sound_wait[math.random(1,#sound_wait)])
					talking_npc[npc:id()] = time_global()
				end				
			end
		end
	elseif (mode == "simple_c" or mode == "ignore_c" or mode == "simple_c_la") then	
		xr_sound.set_sound(npc, nil) 
	end							
end
end

function beh_wait(mode, npc)

	--log1("COMP_EXEC_WAIT "..tostring(npc:name()).." ACT "..tostring(mode))

	if not npc:alive() or xr_wounded.is_wounded(npc) then
		return
	end

	local actor = db.actor

	if (mode == "ignore" or mode == "ignore_c") then
		xr_combat_companion.dont_touch_us = true
	end
	
	local new_state 
	
	if (mode == "simple" or mode == "simple_la") then
		new_state = "guard"
	elseif mode == "ignore" then
		new_state = "wait"		
	elseif (mode == "simple_c" or mode == "simple_c_la") then
		new_state = "hide"
	elseif mode == "ignore_c" then
		new_state =	"hide_no_wpn"
	end			

	if new_state then
		state_mgr.set_state( script_name(), npc, new_state)
		last_state[npc:id()] = new_state
	elseif last_state[npc:id()] then
		state_mgr.set_state( script_name(), npc, last_state[npc:id()])
	end 

	-- 4. Если стоим на точке - петь песенки и прочую херню
	if (mode == "simple" or mode == "ignore" or mode == "simple_la") then
		if math.random() < sound_prob then
			local silence_interval = math.random(30000,65000)
			if testing_sound then
				silence_interval = 6000
			end
			if math.random() < sound_prob then
				if not talking_npc[npc:id()] then
					xr_sound.set_sound(npc, sound_wait[math.random(1,#sound_wait)])
					talking_npc[npc:id()] = time_global()
				elseif talking_npc[npc:id()] then	
					local period = time_global() - talking_npc[npc:id()]
					if period < 5000 then
						xr_sound.set_sound(npc, sound_wait[math.random(1,#sound_wait)])
					elseif period >= 5000 and period < silence_interval then
						xr_sound.set_sound(npc, nil)
					elseif period >= silence_interval then	
						xr_sound.set_sound(npc, sound_wait[math.random(1,#sound_wait)])
						talking_npc[npc:id()] = time_global()
					end				
				end
			end
		end
	elseif (mode == "simple_c" or mode == "ignore_c" or mode == "simple_c_la") then	
		xr_sound.set_sound(npc, nil) 
	end	
end
----------------------------------------------------------------------------------------------------------------------
local count_update 			= 0	-- Счетчик апдейтов. Нельзя чтобы схема стартовала включенной сразу же, иначе 
local engage_after_update 	= 3 -- будут глюки на переключении схем и выборе оружия
post_work					= {}
local post_timer			= nil
----------------------------------------------------------------------------------------------------------------------
class "evaluator_need_companion" (property_evaluator)

function evaluator_need_companion:__init(name, storage) super (nil, name)
	self.st = storage
end

function evaluator_need_companion:evaluate()
	if count_update <= engage_after_update then
		count_update = count_update + 1
		return false
	end	
	if not self.object:alive() or xr_wounded.is_wounded(self.object) then
		return false
	end
	if being_attacked == true then 
		return false
	end
	if post_work[self.object:id()] then
		ogse_debug.add_active_eval( self.object, script_name(), "need_companion_post_work" )
		return true
	end
	if self.st.enabled == true then
		ogse_debug.add_active_eval( self.object, script_name(), "need_companion" )
		return true
	else
		return false
	end
end
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
class "action_companion_activity" (action_base)

function action_companion_activity:__init(name, storage) super (nil, name)
	self.st = storage
end

function action_companion_activity:initialize()

	action_base.initialize(self)
	
	if not self.object:alive() then
		return false
	end
	
	if being_attacked == true then return false end	
	
	self.object:enable_talk()	
	assist_point[self.object:id()] = nil

	last_state[self.object:id()] = "guard"
	state_mgr.set_state( script_name(), self.object, last_state[self.object:id()])
	
	keep_state_until = time_global()
end

local beh = {
	[beh_walk_simple]       = {beh_walk, "simple"},
	[beh_walk_low_aggr]     = {beh_walk, "simple_la"},
	[beh_walk_ignore]       = {beh_walk, "ignore"},
	[beh_crouch_simple]     = {beh_walk, "simple_c"},
	[beh_crouch_low_aggr]   = {beh_walk, "simple_c_la"},
	[beh_crouch_ignore]     = {beh_walk, "ignore_c"},
	[beh_wait_simple]       = {beh_wait, "simple"},
	[beh_wait_low_aggr]     = {beh_wait, "simple_la"},
	[beh_wait_ignore]       = {beh_wait, "ignore"},
	[beh_hide_simple]       = {beh_wait, "simple_c"},
	[beh_hide_low_aggr]     = {beh_wait, "simple_c_la"},
	[beh_hide_ignore]       = {beh_wait, "ignore_c"},
}

function action_companion_activity:execute()

	action_base.execute(self)
	
	if not self.object:alive() then
		return false
	end	
	
	if being_attacked == true then return false end
	
	if post_work[self.object:id()] then
		if post_timer == nil then
			post_timer = time_global() + 10000
		end
		if post_timer and post_timer > time_global() then
			state_mgr.set_state( script_name(), self.object, "guard")
			return
		elseif post_timer <= time_global() then
			post_timer = nil
			post_work[self.object:id()] = nil
			return
		end
	end	
	
	self.object:set_desired_position()
	self.object:set_desired_direction()
	
	local range = self.object:range()
	local fov = self.object:fov()	
	local npc = self.object
	
	--log1("COMP R "..range.." FOV "..fov)
	
	local beh_model = db.storage[npc:id()].companion.behavior
	local act = beh[beh_model]
	--log1("COMP_MDL "..tostring(npc:name()).." ACT "..tostring(beh_model))
	if act then act[1](act[2], npc) end
	--  Проверка на враждебность
	if self.object:relation(db.actor) == game_object.enemy then
		db.actor:give_game_news(self.object:character_name().." "..game.translate_string("companion_became_your_enemy_string"), "ui\\ui_iconsTotal", Frect():set(0,235,83,47), 0, 15000)
		db.storage[self.object:id()].companion.enabled = false
		number_of_companions = number_of_companions - 1
		save_var_companion(self.object:id(), "is_companion", 0)
		level_tasks.remove_location_by_id(self.object:id(), "alife_presentation_companion")
		local dead_friends = tonumber(ogse.load_variable("dead_fr", 0))
		dead_friends = dead_friends + 1
		ogse.save_variable("dead_fr", dead_friends)		
		local comm = load_var_companion(self.object:id(), "orig_community", nil)
		self.object:set_character_community(comm, 0, 0)
		trade_manager.trade_init(self.object, "misc\\trade_generic.ltx")	
		companions[self.object:id()] = nil

		unsubscribe(self.object:id())
	end	
	
end

function action_companion_activity:finalize()
	self.object:set_mental_state(anim.free)
	action_base.finalize(self)
end

-- Возвращает угол между проекциями векторов vec1 и vec2 на горизонтальную плоскость
-- положительный угол - доворот vec1 до vec2 по часовой.
function horz_angle(vec1,vec2)
  local x=vec2.x*vec1.x+vec2.z*vec1.z
  local y=-vec2.z*vec1.x+vec2.x*vec1.z -- повернули систему координат     
  return math.atan2(y,x) -- угол доворота от -pi до pi
end

--' Выбор новой позиции
function select_position(npc, st)
	local node_1_vertex_id = nil
	local node_1_distance = nil
	local node_2_vertex_id = nil
	local node_2_distance = nil

	local actor = db.actor
	local forbidden = {}
	
	for k, v in pairs(locked_vertexes) do
		if k ~= npc:id() then
			forbidden[v] = true
		end
	end

	-- проверяем точку слева от актера
	desired_direction = vector_rotate_y(actor:direction(), math.random(40,90) )
	node_1_vertex_id = level.vertex_in_direction(actor:level_vertex_id(),
		desired_direction,
		math.random(desired_distance, desired_distance+3))
	if npc:accessible(node_1_vertex_id) ~= true or node_1_vertex_id == actor:level_vertex_id() or forbidden[node_1_vertex_id] then			
		node_1_vertex_id = nil
	end
	-- проверяем точку справа от актера
	desired_direction = vector_rotate_y(actor:direction(), -math.random(40,90) )
	node_2_vertex_id = level.vertex_in_direction (  actor:level_vertex_id(),
		desired_direction,
		math.random(desired_distance, desired_distance+3) )
	if npc:accessible(node_2_vertex_id) ~= true or node_2_vertex_id == actor:level_vertex_id() or forbidden[node_2_vertex_id] then			
		node_2_vertex_id = nil
	end
	
	-- Проверяем растояния до точек
	if node_1_vertex_id ~= nil then
		node_1_distance = npc:position():distance_to_sqr(level.vertex_position(node_1_vertex_id))
	else
		node_1_distance = -1
	end
	if node_2_vertex_id ~= nil then
		node_2_distance = npc:position():distance_to_sqr(level.vertex_position(node_2_vertex_id))
	else
		node_2_distance = -1
	end
	
	-- Выбираем ближайшую из существующих
	if node_1_distance == -1 and node_2_distance == -1 then
		--' Не смогли найти точку, ругаться
		return db.actor:level_vertex_id()
	end
	if node_1_distance == -1 then
		return node_2_vertex_id
	end
	if node_2_distance == -1 then
		return node_1_vertex_id
	end
	if node_1_distance < node_2_distance then
		return node_1_vertex_id
	else
		return node_2_vertex_id
	end
end

function select_position_get_away(npc, st)
	local node_1_vertex_id = nil
	local node_1_distance = nil
	local node_2_vertex_id = nil
	local node_2_distance = nil

	local actor = db.actor
	
	local forbidden = {}
	
	for k, v in pairs(locked_vertexes) do
		if k ~= npc:id() then
			forbidden[v] = true
		end
	end	

	-- проверяем точку слева от актера
	desired_direction = actor:direction()
	node_1_vertex_id = level.vertex_in_direction(actor:level_vertex_id(),
		desired_direction,
		desired_distance)
	if npc:accessible(node_1_vertex_id) ~= true or node_1_vertex_id == actor:level_vertex_id() or forbidden[node_1_vertex_id] then			
		node_1_vertex_id = nil
	end
	-- проверяем точку справа от актера
	desired_direction = actor:direction()
	node_2_vertex_id = level.vertex_in_direction (  actor:level_vertex_id(),
		desired_direction,
		5 )
	if npc:accessible(node_2_vertex_id) ~= true or node_2_vertex_id == actor:level_vertex_id() or forbidden[node_2_vertex_id] then			
		node_2_vertex_id = nil
	end
	
	-- Проверяем растояния до точек
	if node_1_vertex_id ~= nil then
		node_1_distance = npc:position():distance_to_sqr(level.vertex_position(node_1_vertex_id))
	else
		node_1_distance = -1
	end
	if node_2_vertex_id ~= nil then
		node_2_distance = npc:position():distance_to_sqr(level.vertex_position(node_2_vertex_id))
	else
		node_2_distance = -1
	end
	
	-- Выбираем ближайшую из существующих
	if node_1_distance == -1 and node_2_distance == -1 then
		--' Не смогли найти точку, ругаться
		return db.actor:level_vertex_id()
	end
	if node_1_distance == -1 then
		return node_2_vertex_id
	end
	if node_2_distance == -1 then
		return node_1_vertex_id
	end
	if node_1_distance < node_2_distance then
		return node_1_vertex_id
	else
		return node_2_vertex_id
	end
end

function vector_rotate_y (v, angle)
    angle = angle * 0.017453292519943295769236907684886
    local c = math.cos (angle)
    local s = math.sin (angle)
    return vector ():set (v.x * c - v.z * s, v.y, v.x * s + v.z * c)
end

property_base = 79945
property_need_companion = property_base + 1
property_need_run = property_base + 2
---
act_base = 79950
act_companion_activity = act_base + 1
act_companion_run = act_base + 2

-- Добавляем в планировщик нашу схему
function add_to_binder(object, char_ini, scheme, section, st)
if db.actor:dont_has_info("dar_samogon_trance") then

	local manager = object:motivation_action_manager()
	
	local property_wounded = xr_evaluators_id.sidor_wounded_base
	local state_mgr_to_idle_combat 	= xr_actions_id.state_mgr + 1
	local state_mgr_to_idle_alife = xr_actions_id.state_mgr + 2

	manager:remove_evaluator(property_need_companion)
	manager:add_evaluator(property_need_companion, evaluator_need_companion("evaluator_need_companion", st))	
	

	local action = action_companion_activity("action_companion_activity", st)
	action:add_precondition(world_property(stalker_ids.property_alive, true))
	action:add_precondition(world_property(xr_evaluators_id.abuse_base, false))
	action:add_precondition(world_property(xr_combat_companion.prop_combat, false))
	if xrs_grenade then
		action:add_precondition( world_property( xrs_grenade.prop_fire,          		     false  ) )
		action:add_precondition( world_property( xrs_grenade.prop_grenade,          	     false  ) )
	end
	if rx_bandage and rx_bandage.enable_scheme then
		action:add_precondition(world_property(rx_bandage.evid_bandage,false))
	end	
	if rx_facer then
		action:add_precondition(world_property(rx_facer.evid_facer,false))
	end
	if rx_gl then
		action:add_precondition(world_property(rx_gl.evid_gl_fire,false))
		action:add_precondition(world_property(rx_gl.evid_gl_reload,false))
	end	
	action:add_precondition(world_property(property_wounded, false))
	action:add_precondition(world_property(property_need_companion, true))
	action:add_effect(world_property(property_need_companion, false))
	action:add_effect(world_property( stalker_ids.property_enemy, false ))	
	manager:add_action(act_companion_activity, action)	
	
	action = manager:action(state_mgr_to_idle_combat)
	action:add_precondition(world_property(property_need_companion, false))
	
	action = manager:action(state_mgr_to_idle_alife)
	action:add_precondition(world_property(property_need_companion, false))

	action = manager:action(stalker_ids.action_alife_planner)
	action:add_precondition(world_property(property_need_companion, false))

	action = manager:action(stalker_ids.action_danger_planner)
	action:add_precondition(world_property(property_need_companion, false))
	
	action = manager:action(stalker_ids.action_combat_planner)	
	action:add_precondition(world_property(property_need_companion, false))

	action = manager:action(stalker_ids.action_retreat_from_enemy)
	action:add_precondition(world_property(property_need_companion, false))
end
end

-- Функции включения/выключения схемы
function enable_scheme(npc, ini)

	reset_npc_logic(npc)

	local st = xr_logic.assign_storage_and_bind(npc, ini, "companion")
	local flag = load_var_companion(npc:id(), "is_companion", 0)

	if st then
		if tostring(flag) == "1" then
			companions[npc:id()] = true --"companion"
			subscribe(npc:id())
			--log3("--[%s.enable_scheme] subscribed: [%s]", script_name(), npc:name())
			companion_weapon[npc:id()] = load_var_companion(npc:id(), "weapon_behavior", "anything")	
			update_wmgr(npc)
			local behavior = load_var_companion(npc:id(), "companion_behavior", beh_walk_simple)
			init_danger_settings(npc)
			st.enabled = true		
			st.behavior = tonumber(behavior)
		else
			st.enabled = false
		end
	end
end
function disable_scheme(npc, scheme)
	local st = db.storage[npc:id()][scheme]
	if st then
		st.enabled = false
	end
end

function is_companion(npc_id)
	return npc_id and companions[npc_id]
end

function is_companion_se(obj)
	if obj:health() > 0 then
		local flag = load_var_companion(obj.id, "is_companion", 0)
		if tostring(flag) == "1" then
			--log1("!!COMP FND OFFLINE! "..obj:profile_name())
			companions[obj.id] = true --"companion"
			number_of_companions = number_of_companions + 1
			subscribe(obj.id)
			--log3("--[%s.is_companion_se] called subscribe!", script_name())
		end
	end
end

function reset_npc_logic(obj)
	if obj then
		local npc_id = obj:id()
		db.storage[npc_id].overrides = nil
		xr_logic.reset_generic_schemes_on_scheme_switch(obj, "nil", "nil")
		db.storage[npc_id].active_section = nil
		db.storage[npc_id].active_scheme = nil		
	end
end