-- -*- mode: lua; coding: windows-1251-dos -*-

local function random_choice( ... )
  local arg = { ... }
  return arg[ math.random( #arg ) ]
end

local function is_exo_visual( npc )
  local vis = npc:get_visual_name()
  return string.find( vis, "exo" ) or string.find( vis, "tank" )
    or string.find( vis, "_cherep" )
    or string.find( vis, "_redeye" )
    or string.find( vis, "stalker_arhara1" )
end


-----------------------------------------------------------------------
--- xrs_battle_ai.script
--- Модуль боевки
--- Автор: KamikaZze
--- Идея, советы: xStream
--- version 4.38 (10/03/2015)
-----------------------------------------------------------------------
--- Настройки:
-----------------------------------------------------------------------
-- время, сколько примерно сидеть в укрытии, миллиссекунд
local time_to_hide              = 5000
-- время, сколько стоять на точке маневрирования, миллиссекунд
local time_to_maneuver          = 2500
local close_combat_distance     = 15 -- дистанция ближнего боя
-- дистанция когда бой уже не считается ближним
local distant_combat_distance   = 35
local cooldown_time             = 20000 -- время запрета лута после боя
-- интервал реприоретизации, мсек - нельзя делать слишком низким -
-- будет судорожно метаться между целями
local reprioritize_timeout      = 1500
-- время, сколько помнить о появлении врага, миллиссекунд
local memory_timeout            = 80000
-- сколько помнить о последнем основном враге (нужно для
-- предотвращения выхода из боя слишком рано), для неписей умножается
-- на 2
local remember_enemy            = 5000
local inertion_time_grenade     = 3000 -- сколько бояться гранаты
-- С какого апдейта схема начинает работать. Нельзя чтобы схема
-- стартовала включенной сразу же, иначе будут глюки на переключении
-- схем и выборе оружия
local engage_after_update       = 3
-- время, мсек, сколько придерживаться стратегии маневрирования
local time_mantain_manuever     = 20000
-- время, мсек, сколько придерживаться выбранной тактики
local time_mantain_tactics      = 30000
local visibility_treshold_value = 0.45 -- трешхолд видимости

-- вероятность сказать фразу
local sound_prob_event = 0.6
local sound_prob_hero  = 0.1
local sound_prob_idle  = 0.1

hit_timeout = {}


-- локации где можно атаковать БТР и вертолеты
local armor_allowed_locations = { [ "l13_generators_ogse" ] = true }

-- состояния не готовности к огню, нужно заставить встать перед
-- началом стрельбы
local not_ready_states = {
  [ "sit"      ] = true,
  [ "sit_knee" ] = true,
  [ "sit_ass"  ] = true,
  [ "sleep"    ] = true,
  [ "wounded_heavy"] = true,
  [ "guard"    ] = true,
  [ "patrol"   ] = true,
}

local low_range_npc_aggr = 30
local far_range_mon_aggr = 50
local low_range_mon_aggr =  5

local combat_mult_npc     = 0.5 -- множитель веса ближней цели неписей
local combat_mult_monster = 0.3 -- множитель веса ближней цели неписей

local max_invisible_range_npc = 12
local max_invisible_range_mon =  5

local forbidden_comms = {       -- запретные коммунити
  [ "zombied" ] = true,
  -- [ "ecolog"  ] = true,
  -- [ "trader"  ] = true,
  -- [ "gunsmith"] = true,
  -- [ "guider"  ] = true,
}

local forbidden_schemes = {     -- запретные схемы
  [ "wounded" ] = true
}

local forbidden_profiles = {    -- запретные профили и имена
  [ "aes_Monolit_sniper_gauss" ] = true,
  [ "Monolit_sniper_gauss"     ] = true,
  [ "pri_monolith_roof3"       ] = true,
  [ "pri_stalker_n_2"          ] = true,
  [ "pri_stalker_n_2_0000"     ] = true,
  [ "pri_monolith_roof3_0000"  ] = true,
  [ "pri_monolith_roof3_0001"  ] = true,
  [ "pri_stalker_n_2_0001"     ] = true,
  [ "pri_stadium_sniper1"      ] = true,
  [ "pri_stadium_sniper2"      ] = true,
  [ "pri_stadium_sniper3"      ] = true,
  [ "pri_monolith_roof1"       ] = true,
  [ "pri_monolith_roof2"       ] = true,
  --[ "val_sacrifice_victim"     ] = true,
  --[ "val_prisoner_captive"     ] = true,
  --[ "val_escort_captive"       ] = true,
  [ "bandit_trader"            ] = true,
  [ "bandit_trader_spawn"      ] = true,
  [ "dik_the_drifter"          ] = true,
  [ "major_wounded"            ] = true,
  [ "gen_monolit_sniper"       ] = true,
  [ "aes_Monolit_rpg"          ] = true,
  [ "hohol"                    ] = true,
  [ "esc_lekar"                ] = true,
  [ "first_neutral"            ] = true,
  [ "esc_buharik"              ] = true,
  [ "esc_guns_remontnik"       ] = true,
  -- пацаны в саркофаге должны быть под движковой боевкой
  [ "sar_monolith_exo"         ] = true,
  [ "sar_monolith_exo_crystal" ] = true,
  [ "sar_monolith_specnaz"     ] = true,
  [ "sar_monolith_commander"   ] = true,
  
  [ "rad_kulgband_assistant"   ] = true,
  [ "dar_farm_assistant"   ] = true,
  [ "rad_kulgband_shron_guard1"   ] = true,
  [ "rad_kulgband_shron_guard2"   ] = true,
  [ "rad_kulgband_shron_guard3"   ] = true,
  [ "kulgband_informer_assist3"   ] = true,

-- Персонажи под рестрикторами не рассчитаны на скриптовую боевку. Только лаги от них.
  [ "bar_dolg_leader" ] = true,
  [ "bar_dolg_bunker_0001" ] = true,
  [ "bar_dolg_bunker_0002" ] = true,
  [ "bar_dolg_bunker_2" ] = true,
  [ "bar_bar_guard_2" ] = true,
}

local forbidden_gulags = {
-- Бандиты на базе в ТД. Сидят под рестрикторами, в результате боевке очень тяжело для них просчитать каверы, и начинаются сильные лаги.
   [ "val_watchtower1" ] = true,
   [ "val_watchtower2" ] = true,
   [ "val_watchtower3" ] = true,
   [ "val_watchtower4" ] = true,
   [ "val_watchtower5" ] = true,
   [ "val_lager_bandits" ] = true,
   [ "bar_freedom_attack" ] = true, -- с этими тоже какие-то проблемы...
}

local forbidden_by_lname = {
  -- [ "l12u_control_monolith" ] = true,
  -- [ "l12u_sarcofag"         ] = true,
}

local community_forbidden_locations = {
  -- [ "monolith" ] = {
  --   [ "l12_stancia_2" ] = true,
  -- },
}

local headshot_prob = {
  [ "novice"      ] = 0.01,
  [ "experienced" ] = 0.05,
  [ "veteran"     ] = 0.1,
  [ "master"      ] = 0.2,
}


function attach( sm )
  sm:subscribe({ signal = "on_npc_death", fun = this.death_place  })
  sm:subscribe({ signal = "on_npc_hit",   fun = this.hit_callback })
  sm:subscribe({ signal = "on_npc_net_destroy", fun = go_offline  })
  sm:subscribe({ signal = "on_spawn",     fun = this.on_spawn     })
end


--- время входа в бой
local intros = {
  [ "novice"      ] = 400,
  [ "experienced" ] = 300,
  [ "veteran"     ] = 200,
  [ "master"      ] = 100,
}

--- время на прицеливание
--- для эффективной стрельбы из дробовика необходимо,
--- чтобы выдерживался интервал между выстрелами,
--- иначе подброс ствола испортит всю картину
--- для новичков логично этот параметр сделать низким и увеличивать с опытом
local time_to_aim = {
  [ "novice"      ] = {
    shotgun = 350, sniper = 1500, other = 350, rpg = 3500,
  },
  [ "experienced" ] = {
    shotgun = 300, sniper = 1000, other = 300, rpg = 3000,
  },
  [ "veteran"     ] = {
    shotgun = 250, sniper =  800, other = 250, rpg = 2500,
  },
  [ "master"      ] = {
    shotgun = 200, sniper =  500, other = 200, rpg = 2000,
  },
}

--- отклонение прицела
local deviation_table = {
  [ "novice"      ] = 0.65,
  [ "experienced" ] = 0.6,
  [ "veteran"     ] = 0.5,
  [ "master"      ] = 0.45,
}

--- коэффициент отклонения по коммунити
local community_deviation_coeff = {
  [ "lastday"       ] =  3,
  [ "monolith"      ] =  3,
  [ "trader"        ] =  3,
  [ "killer"        ] =  3.2,
  [ "military"      ] =  3.2,
  [ "sniper"        ] =  3.2,
  [ "vermaht"       ] =  3.2,
  [ "stalker"       ] =  3.4,
  [ "zombied"       ] =  15,
}

--- группировки с улучшенной координацией (имеют радиосвязь, соотв. об
--- одной цели сразу знают все члены группировки)
local radio_comms = {
  [ "military" ] = true,
  [ "killer"   ] = true,
  [ "monolith" ] = true,
  [ "dolg"     ] = true,
}

local postcombat_states = { "hide_na", "threat" }
local postcombat_states_full_weapon = { "hide_na", "threat" }

local needed_dangers = {
  [ danger_object.attack_sound    ] = true,
  [ danger_object.bullet_ricochet ] = true,
  [ danger_object.attacked        ] = true,
  [ danger_object.grenade         ] = true,
  [ danger_object.enemy_sound     ] = true
}

local targeting_dangers = {
  [ danger_object.attacked ] = true
}


-----------------------------------------------------------------------
--- Данные:
-----------------------------------------------------------------------
local last_time_send            = {}
local last_sent_vertex          = {}
local last_hideout              = {}
local sounds_timeout            = {}
local intro_time                = {}
local already_hear              = {}
local choosen_hide_combat_state = {}
local choosen_hide_state        = {}
cooldown                        = {}
local disabled_objects          = {} -- таблица забытых объектов
local targets_list              = {} -- список целей
local last_reprioritize         = {} -- время приоретизации
primary_target                  = {} -- таблица целей
local last_target               = {} -- последняя цель
-- имя последнего врага, чисто для отладочных сообщений
local last_enemy                = {}
local last_enemy_id             = {}         -- ид последнего врага
local inited                    = {}         -- инициализированы ли
local monolith                  = {} -- неписи со скриптовой боевкой монолита
local campers                   = {} -- неписи со скриптовой боевкой кемпера
local bad_hide                  = {} -- ненадежное укрытие
local locked_vertexes           = {} -- занятые вертексы
local death_places              = {} -- места смерти союзников, избегать их
local time_hide                 = {} -- время ожидания
local hit_memory                = {} -- хитоая память
local active_grenades           = {} -- активные гранатные угрозы
local deadman_vtx               = {} -- точка откуда будем ждать успокоения
local count_update              = {} -- Счетчик апдейтов
local grenka_already_shout      = {}
local grenka_already_blow       = {}
local escape_point              = {}
local talking_about_grenka      = {}
local last_choosed_path         = {}
local sound_events              = {}
local sound_are_playing         = {}
local already_know_about        = {}
local postcombat                = {}
-- при выборе обхода справа или слева, NPC запоминает это и какое-то
-- время придерживается этой стратегии
local maneuver_strategy         = {}
knife_scheme                    = {} -- безоружные неписи
local can_fire                  = {}
local need_knife                = {}

in_combat = {}


local ignore_enemies = {}
function check_is_enemy( npc, enemy, fast )
  if not npc or not enemy then return false end
  local is_engine_enemy = npc:is_relation_enemy( enemy )
  if is_engine_enemy then
    if
      ignore_enemies[ npc:name() ]
      and ignore_enemies[ npc:name() ][ enemy:name() ]
    then
      return false
    end
    return fast and true or npc:binded_object():enemy_callback( npc, enemy )
  end
  return false
end


function on_spawn()
  local dsh_sect = "dsh.xrs_battle_ai.ignore_enemies"
  if sys_ini:section_exist( dsh_sect ) then
    for _, k in ipairs( get_section_keys( dsh_sect ) ) do
      for _, name in ipairs( parse_names( get_string( dsh_sect, k ) ) ) do
        ignore_enemies[ k ][ name ] = true
      end
    end
  end
end


function is_combat_ignore( npc, enemy )
  return not xr_combat_ignore.is_enemy( npc, enemy )
end


function get_obj_rank_name( obj )
  local enemy = get_target( obj )
  if
    enemy and enemy:id() == db.actor:id()
    and db.actor:character_rank() > obj:character_rank()
  then
    obj = db.actor
  end
  return ranks.get_obj_rank_name( obj )
end


function get_best_weapon( npc )
  local wm = rx_wmgr and rx_wmgr.get_wm( npc )
  return wm and wm:get_weapon() or npc:best_weapon()

--[=[
  local sl = npc:active_slot()
  if sl ~= NO_ACTIVE_SLOT and npc:item_in_slot( sl ) then
    return npc:item_in_slot( sl )
  else
    local wm = rx_wmgr and rx_wmgr.get_wm( npc )
    return ( wm and wm:get_weapon() ) or npc:best_weapon()
  end
--]=]
end


-- продолжаем вооруженное общение до умиротворения объекта
class "evaluator_check_altcombat" ( property_evaluator )
function evaluator_check_altcombat:__init( name, storage ) super( nil, name )
  self.st = storage
end


function evaluator_check_altcombat:evaluate()
  if
    count_update[ self.object:id() ]
    and count_update[ self.object:id() ] <= engage_after_update
  then
    count_update[ self.object:id() ] = count_update[ self.object:id() ] + 1
    in_combat[ self.object:id() ] = nil
    return false
  elseif not count_update[ self.object:id() ] then
    count_update[ self.object:id() ] = 0
    in_combat[ self.object:id()    ] = nil
    return false
  end

  if
    ( not self.object:alive() )
    or xr_wounded.is_wounded( self.object )
    or xr_companion.is_companion( self.object:id() )
    or (
      db.storage[ self.object:id() ].active_scheme
      and forbidden_schemes[ db.storage[ self.object:id() ].active_scheme ]
    )
  then
    in_combat[ self.object:id() ] = nil
    return false
  else
    if not inited[ self.object:id() ] then
      -- произведем инициализацию таблиц данных селектора
      targets_list[ self.object:id() ] = {}        -- список целей
      last_target[ self.object:id()  ] = {}        -- последняя цель
      setup_sound_table( self.object )
      inited[ self.object:id()       ] = true
      --local ini = battle.is_battle_spawned( self.object )
      --if ini then
      --  local actor_is_enemy = get_bool(
      --    "battle", "xrs_battle_ai.actor_is_enemy", false, ini
      --  )
      --  if actor_is_enemy then
      --    register_as_target( self.object, db.actor )
      --  end
      --end
    end
    reprioritize_targets( self.object )
    check_for_grenades( self.object )
  end

  local bw         = get_best_weapon( self.object )
  local npc_rank   = get_obj_rank_name( self.object )
  local targ       = have_fresh_deadman( self.object )
  local best_enemy = get_target( self.object )
  if best_enemy then
    if
      (
        best_enemy:alive()
        or ( is_armor( best_enemy ) and armor_alive( best_enemy ) )
      )
      and (
        not ( IsStalker( best_enemy ) and xr_wounded.is_wounded( best_enemy ) )
      )
      and ( not is_exclusion( self.object ) )
      and bw
    then
      ogse_debug.add_active_eval( self.object, script_name(), "altcombat" )
      if not already_hear[ self.object:id() ] then
        already_hear[ self.object:id() ] = true
        if not intro_time[ self.object:id() ] then
          intro_time[ self.object:id() ] = time_global() + intros[ npc_rank ]
        end
        cooldown[ self.object:id() ] = time_global() + cooldown_time
      end
      in_combat[ self.object:id() ] = true
      return true
    else
      if targ ~= false and not is_exclusion( self.object ) then
        ogse_debug.add_active_eval( self.object, script_name(), "altcombat_2" )
        in_combat[ self.object:id() ] = true
        return true
      end
      in_combat[ self.object:id() ] = nil
      return false
    end
  else
    if targ ~= false and not is_exclusion( self.object ) then
      local obj = level.object_by_id( targ )
      if
        not (
          IsStalker( obj ) and obj:alive() and xr_wounded.is_wounded( obj )
        )
      then
        ogse_debug.add_active_eval( self.object, script_name(), "altcombat_3" )
        in_combat[ self.object:id() ] = true
        return true
      end
    end
    if already_hear[ self.object:id() ] then
      already_hear[ self.object:id() ] = nil
    end
    if intro_time[ self.object:id() ] and not self.object:best_danger() then
      intro_time[ self.object:id() ] = nil
    end
    in_combat[ self.object:id() ] = nil
    return false
  end
end


class "action_altcombat" ( action_base )
function action_altcombat:__init( npc, action_name, storage ) super( nil, action_name )
  self.st = storage
end


function action_altcombat:initialize()
  action_base.initialize( self )
  local npc = self.object
  xr_sound.set_sound( npc, nil )
  npc:movement_enabled( true )
  stop_play_sound( npc )
  self.st.check_lvid = nil
  npc:set_item( object.idle, nil )
  self:check_objects()
  sr_light.check_light( npc )

  if
    db.storage[ self.object:id() ]
    and db.storage[ self.object:id() ].active_scheme == "camper"
  then
    campers[ self.object:id()  ] = true
    monolith[ self.object:id() ] = nil
  else
    campers[ self.object:id()  ] = nil
    monolith[ self.object:id() ] = nil
  end
end


function action_altcombat:execute()
  local pt = profile_timer()
  pt:start()

  self:_execute()

  pt:stop()
  if pt:time() > 30000 then
    local gulag = xr_gulag.get_npc_gulag(self.object)
    log3( "~~[%s]: [%s](%s): action_altcombat:execute() too slow: [%.2f s.]", script_name(), self.object:name(), gulag and gulag.name or "", pt:time() / 1e+6 )
  end
end

function action_altcombat:_execute()
  action_base.execute( self )
  local npc = self.object

  if xr_wounded.is_wounded( npc ) or not self.object:alive() then
    reset_everything( npc )
    return
  end

  if active_grenades[ npc:id() ] then
    evade_grenades( npc )
    return
  end

  if talking_about_grenka[ npc:id() ] and not active_grenades[ npc:id() ] then
    talking_about_grenka[ npc:id() ] = nil
    stop_play_sound( npc )
    xr_sound.set_sound( npc, nil )
  end

  local enemy   = get_target( npc ) -- текущий враг
  local deadman = have_fresh_deadman( npc )
  if ( not enemy ) and deadman == false then
    last_time_send[ npc:id()    ] = nil
    last_enemy[ npc:id()        ] = nil
    last_enemy_id[ npc:id()     ] = nil
    primary_target[ npc:id()    ] = nil
    last_reprioritize[ npc:id() ] = nil
    return
  end

  -- получим текущее оружие
  local bw = get_best_weapon( npc )

  -- строим список врагов/друзей, проверяем линию огня - в своих и
  -- нейтралов чтоб не стрелять
  self:check_objects( bw, enemy )

  self.object:movement_enabled( true )
  self.object:set_desired_direction()
  self.object:set_desired_position()
  self.object:set_detail_path_type( move.curve )
  self.object:set_path_type( game_object.level_path )

  local assist_point, last_algorythm
  -- если ещё свежий труп
  if ( not get_target( npc ) ) and deadman ~= false then
    stop_play_sound( npc )
    local deadman_target = level.object_by_id( deadman )
    if deadman_target then
      set_combat_sight( self.object, deadman_target, bw )
      if bw then self.object:set_item( object.aim1, bw ) end
      if not deadman_vtx[ npc:id() ] then
        local rand = math.random()
        if rand < 0.33 then
          assist_point   = randomize_position( npc )
          last_algorythm = "random_pos"
        elseif rand >= 0.33 and rand < 0.66 then
          assist_point   = select_last_known_enemy_pos( npc )
          last_algorythm = "last_enemy_vertex"
        else
          assist_point   = select_position( npc, nil, true )
          last_algorythm = "select_pos"
        end
        deadman_vtx[ npc:id() ] = assist_point
      end
      if
        deadman_vtx[ npc:id() ]
        and npc:accessible( deadman_vtx[ npc:id() ] )
        and not npc:level_vertex_id() == deadman_vtx[ npc:id() ]
      then
        if
          hit_timeout[ npc:id() ]
          and hit_timeout[ npc:id() ] > time_global()
        then
          self.object:movement_enabled( false )
        elseif hit_timeout[ npc:id() ] then
          hit_timeout[ npc:id() ] = nil
        end
        set_transfer_state( self.object, deadman_target )
        utils.send_to_nearest_accessible_vertex( npc, deadman_vtx[ npc:id() ] )
      else
        if not postcombat[ npc:id() ] then
          if has_full_weapon( npc, bw ) then
            postcombat[ npc:id() ] = postcombat_states_full_weapon[
              math.random( table.getn( postcombat_states_full_weapon ) )
            ]
          else
            postcombat[ npc:id() ] = postcombat_states[
              math.random( table.getn( postcombat_states ) )
            ]
          end
        end
        local state_chk = state_mgr.get_state( npc )
        if
          npc:animation_count() > 0 and state_chk ~= postcombat[ npc:id() ]
        then
          npc:clear_animations()
        end
        if state_chk ~= postcombat[ npc:id() ] then
          state_mgr.set_state(
            npc, postcombat[ npc:id() ], nil, nil,
            { look_object = deadman_target }
          )
          set_combat_sight( npc, deadman_target, bw )
        end
      end
      last_enemy[ npc:id()    ] = nil
      last_enemy_id[ npc:id() ] = nil
      return
    else
      reset_everything( npc )
      return
    end
  end

  -- инициализация боя
  if
    enemy
    and (
      ( not last_enemy_id[ npc:id() ] )
      or enemy:id() ~= last_enemy_id[ npc:id() ]
    )
  then
    last_enemy_id[ npc:id() ] = enemy:id()
    enable_object( self.object, enemy )
    if bw then self.object:set_item( object.aim1, bw ) end
    notify_friends( self.object, enemy )
    local anim = db.storage[ npc:id() ].state_mgr.animstate:state()
    if
      not_ready_states[ anim ]
      and not ( anim == "guard" or anim == "patrol" )
    then
      state_mgr.set_state(
        npc, "hide_fire", nil, nil, { look_object = enemy },
        { animation = true, animation_nout = true }
      )
    else
      state_mgr.set_state(
        npc, "threat_fire", nil, nil, { look_object = enemy },
        { animation = true, animation_nout = true }
      )
    end
    set_combat_sight( npc, enemy, bw )
  end

  local npc_pos  = npc:position()
  local be       = enemy
  local npc_rank = get_obj_rank_name( npc )
  local be_pos   = be:position()
  local distance = be_pos:distance_to( npc_pos )
  local cover

  -- принимаем решение
  local anim = db.storage[ npc:id() ].state_mgr.animstate:state()
  if
    intro_time[ self.object:id() ]
    and intro_time[ self.object:id() ] > time_global()
  then
    set_combat_sight( npc, be, bw )
    set_transfer_state( npc, be )
    if not_ready_states[ anim ] then
      assist_point = find_cover( npc, enemy, 2 )
      if not assist_point or assist_point == 0 then
        assist_point = select_position( npc, nil, true )
      end
    else
      assist_point = select_position( npc, nil, true )
    end
    if
      npc:level_vertex_id() == assist_point
      or npc:position():distance_to( level.vertex_position( assist_point ) ) < 1.0
    then
      if is_safe_to_block_movement( npc, be ) then
        self.object:movement_enabled( false )
      end
    else
      if
        hit_timeout[ npc:id() ] and hit_timeout[ npc:id() ] > time_global()
      then
        self.object:movement_enabled( false )
      elseif hit_timeout[ npc:id() ] then
        hit_timeout[ npc:id() ] = nil
        utils.send_to_nearest_accessible_vertex( npc, assist_point )
      else
        utils.send_to_nearest_accessible_vertex( npc, assist_point )
      end
    end
    set_sound_event( npc, "start" )
    return
  end

  process_combat_sound( npc )

  if npc:see_right_now( be ) and ( not is_armor( be ) ) and knife_scheme[ npc:id() ] then
    npc:set_mental_state( anim.danger )
    assist_point = select_enemy_pos_fanatic( npc, be )
    last_algorythm = "enemy_vertex"
    if assist_point then
      xr_sound.set_sound( npc, nil )
      set_combat_sight( npc, be, bw )
      set_escape_state( npc, be )
      if npc:level_vertex_id() ~= assist_point then
        if
          hit_timeout[ npc:id() ] and hit_timeout[ npc:id() ] > time_global()
        then
          self.object:movement_enabled( false )
        elseif hit_timeout[ npc:id() ] then
          hit_timeout[ npc:id() ] = nil
          utils.send_to_nearest_accessible_vertex( npc, assist_point )
        else
          utils.send_to_nearest_accessible_vertex( npc, assist_point )
        end
      end
    end
    return
  end


  local height          = be_pos.y - npc_pos.y
  local actor_at_height = (
    be_pos.y > npc_pos.y and height > 3 and be:id() == db.actor:id()
  )
  local is_close_range  = distance < close_combat_distance
  local cur_situation   = 0

  if
    ( npc:see_right_now( be ) and be:see( npc ) )
    or ( is_armor( be ) and get_armor_vis( be, npc ) )
  then
    -- если видим врага и он видит нас - стреляем, ищем укрытие
    time_hide[ npc:id() ] = nil
    if is_fanatic( npc ) then
      cur_situation  = 1
      last_algorythm = "select_pos_be"
    else
      cur_situation  = 2
      last_algorythm = "find_cover_2"
    end

    set_combat_sight( npc, be, bw )
    if can_fire[ npc:id() ] then
      set_combat_state( npc, be, bw )
      set_weapons_fire( npc, be, bw, false, npc_rank )
    else
      set_transfer_state( npc, be )
    end
    choose_idle_scheme( npc, "attack" )

  elseif
    ( npc:see_right_now( be ) and not be:see( npc ) )
    or ( is_armor( be ) and not get_armor_vis( be, npc ) )
  then
    -- если видим врага и он НЕ видит нас - стреляем, маневрируя
    time_hide[ npc:id() ] = nil
    if is_fanatic( npc ) then
      cur_situation  = 3
      last_algorythm = "select_pos_be"
    else
      if actor_at_height then
        cur_situation = 4
        if is_camper( npc ) then
          last_algorythm = "find_cover_0"
        else
          last_algorythm = "find_cover_2"
        end
      else
        cur_situation = 5
        if is_camper( npc ) then
          last_algorythm = "find_cover_0"
        else
          last_algorythm = "find_cover_1"
        end
      end
    end

    set_combat_sight( npc, be, bw )
    if can_fire[ npc:id() ] then
      set_combat_state( npc, be, bw )
      set_weapons_fire( npc, be, bw, false, npc_rank )
    else
      set_transfer_state( npc, be )
    end
    choose_idle_scheme( npc, "attack_notsee" )

  elseif ( not npc:see_right_now( be ) ) and be:see( npc ) then
    -- если НЕ видим врага и он видит нас - убегаем, ищем укрытие
    time_hide[ npc:id() ] = nil
    if is_fanatic( npc ) then
      cur_situation  = 6
      last_algorythm = "select_pos_be"
    else
      cur_situation  = 7
      last_algorythm = "find_cover_2"
    end

    set_combat_sight( npc, be, bw )
    if can_fire[ npc:id() ] then
      set_combat_state( npc, be, bw )
      set_weapons_fire( npc, be, bw, true, npc_rank )
    else
      set_transfer_state( npc, be )
    end
    choose_idle_scheme(npc, "defence")

  else
    -- если НЕ видим врага и он НЕ видит нас - ищем врага
    if not time_hide[ npc:id() ] then
      time_hide[ npc:id() ] = time_global() + math.random( 7000, 15000 )
        + ( 1000 * ogse.armor_type( npc ) )
    end
    if is_fanatic( npc ) then
      cur_situation  = 8
      last_algorythm = "enemy_vertex"
      -- необходимо оформить как отдельный алгоритм
    elseif is_camper( npc ) then
      cur_situation  = 8
      last_algorythm = "find_cover_0"
    else
      if time_hide[ npc:id() ] < time_global() then
        if actor_at_height then
          cur_situation  = 9
          last_algorythm = "select_pos_be"
        else
          cur_situation  = 10
          last_algorythm = random_choice(
            "find_cover_1", "last_enemy_vertex", "find_cover_2",
            "select_pos_be", "enemy_vertex", "find_cover_3"
          )
        end
      else
        cur_situation  = 11
        last_algorythm = "find_cover_2"
      end
    end

    set_combat_sight( npc, be, bw )
    set_transfer_state( npc, be )
    choose_idle_scheme( npc, "lost" )
  end

  if
    distance < distant_combat_distance
    and (
      last_algorythm == "find_cover_1"
      or last_algorythm == "find_cover_2"
    )
  then
    last_algorythm = "find_cover_3"
  end

  -- if
  --   IsMonster( be )
  --   and be:clsid() ~= clsid.burer_s
  --   and be:clsid() ~= clsid.controller_s
  -- then
  --   cur_situation  = 12
  --   last_algorythm = "select_pos"
  -- end

  local lcp     = last_choosed_path[ npc:id() ]
  local use_lcp = false
  if
    lcp and lcp.timeout > time_global()
    and lcp.situation == cur_situation and lcp.be == be:id()
  then
    if be:position():distance_to( lcp.pos ) < 5 then
      last_algorythm = lcp.alg
      use_lcp        = true
    end
  end
  if not use_lcp then
    if not lcp then
      lcp = {}
      last_choosed_path[ npc:id() ] = lcp
    end
    lcp.alg       = last_algorythm
    lcp.be        = be:id()
    lcp.pos       = be:position()
    lcp.situation = cur_situation
    lcp.timeout   = time_global() + time_mantain_tactics
    last_time_send[ npc:id() ] = nil
  end

  local actions = {
    [ "enemy_vertex"  ] = function() return select_enemy_pos( npc, be ) end,
    [ "find_cover_0"  ] = function() return find_cover( npc, be, 0 ) end,
    [ "find_cover_1"  ] = function() return find_cover( npc, be, 1 ) end,
    [ "find_cover_2"  ] = function() return find_cover( npc, be, 2 ) end,
    [ "find_cover_3"  ] = function() return find_cover( npc, be, 3 ) end,
    [ "last_enemy_vertex" ] = function()
      return select_last_known_enemy_pos( npc )
    end,
    [ "select_pos"    ] = function() return select_position( npc ) end,
    [ "select_pos_be" ] = function() return select_position( npc, be ) end,
  }
  ASSERT(
    last_algorythm and actions[ last_algorythm ],
    "[%s]: %s: wrong last_algorythm = %s",
     script_name(), npc:name(), tostring( last_algorythm )
  )
  assist_point = actions[ last_algorythm ]()

  if not assist_point then
    if last_algorythm == "last_enemy_vertex" then
      assist_point = select_enemy_pos( npc, be )
    end
  elseif assist_point == 0 then
    -- Простой таймаут
    assist_point = last_sent_vertex[ npc:id() ]
  end
  if not assist_point then
    assist_point = randomize_position( npc )
  end

  if assist_point and level.valid_vertex_id( assist_point ) then
    if
      npc:level_vertex_id() == assist_point
      or npc:position():distance_to( level.vertex_position( assist_point ) ) <= 1.0
    then
      if is_safe_to_block_movement( npc, be ) then
        self.object:movement_enabled( false )
      else
        last_time_send[ npc:id() ] = nil
      end
    else
      if
        hit_timeout[ npc:id() ] and hit_timeout[ npc:id() ] > time_global()
      then
        self.object:movement_enabled( false )
      elseif hit_timeout[ npc:id() ] then
        hit_timeout[ npc:id() ] = nil
        utils.send_to_nearest_accessible_vertex( npc, assist_point )
      elseif assist_point ~= 0 then
        utils.send_to_nearest_accessible_vertex( npc, assist_point )
      end
    end
  end
end


function action_altcombat:check_objects( bw, enemy )
  local npc = self.object
  self.objects = {}
  self.objects.monsters = {}
  self.objects[ game_object.friend  ] = {}
  self.objects[ game_object.neutral ] = {}
  self.objects[ game_object.enemy   ] = {}

  for o in npc:memory_visible_objects() do
    self:check_single_object( o:object() )
  end

  for o in npc:memory_sound_objects() do
    self:check_single_object( o:object() )
  end

  if enemy and bw and IsRPG( bw ) then
    for _, t in ipairs({ game_object.friend, game_object.neutral }) do
      for k, v in pairs( self.objects[ t ] ) do
        if self:check_npc_on_fire_line( v, bw, enemy ) then
          can_fire[ npc:id() ] = false
          return
        end
      end
    end
  end

  can_fire[ npc:id() ] = bw and bw:is_weapon_magazined() and bw:get_ammo_total() > 0
end


function action_altcombat:check_single_object( obj )
  if not obj then return end
  local npc = self.object
  if not ( IsStalker( obj ) or IsMonster( obj ) ) then return end
  if obj.clsid and obj:alive() and npc:id() ~= obj:id() then
    if IsStalker( obj ) and primary_target[ npc:id() ] ~= obj:id() then
      self.objects[ npc:relation( obj ) ][ obj:id() ] = obj
    elseif IsMonster( obj ) then
      self.objects.monsters[ obj:id() ] = obj
    end
  end
end


function action_altcombat:check_npc_on_fire_line( obj, weapon, be )
  if obj:is_monster() then return false end

  local npc         = self.object
  local npc_pos     = npc:bone_position( "bip01_spine" )
  local be_pos      = be:bone_position( "bip01_spine" )
  local be_dist     = be_pos:distance_to( npc_pos )
  local friend_pos  = obj:bone_position( "bip01_spine" )
  local radius      = 3
  local friend_dist = npc_pos:distance_to( be_pos ) - radius
  if IsRPG( weapon ) then
    local effective_radius   = be_pos:distance_to( friend_pos )
    local effective_radius_2 = be_pos:distance_to( npc_pos )
    local effective_radius_3 = friend_pos:distance_to( npc_pos )
    if
      effective_radius < 25 or effective_radius_2 < 25
      or effective_radius_3 < 25
    then
      return true
    end
  end
  -- if be_dist > 5 then --and friend_dist < be_dist then -- убрано чтобы не стреляли не только когда непись между врагом но и за ним непосредственно
  --   -- направления на врага и друга
  --   -- считаем попадает ли текущий солдат в сектор обстрела
  --   local dir_aim = utils.vector_copy_by_val( be_pos ):sub( npc_pos )
  --   local dir_obj = utils.vector_copy_by_val( friend_pos ):sub( npc_pos )
  --   local x       =  dir_obj.x * dir_aim.x + dir_obj.z * dir_aim.z
  --   -- повернули систему координат
  --   local y       = -dir_obj.z * dir_aim.x + dir_obj.x * dir_aim.z
  --   local angle   = math.atan2( y, x ) -- угол доворота от -180 до 180
  --   local div     = radius / friend_dist
  --   if angle >= -div and angle <= div then return true end
  -- end
  return false
end


function action_altcombat:finalize()
  action_base.finalize( self )
  xr_sound.set_sound( self.object, nil )
  self.object:movement_enabled( true )
  stop_play_sound( self.object )
  sr_light.check_light( self.object )
  monolith[ self.object:id() ] = nil
  campers[ self.object:id()  ] = nil
end


function check_friends_enemy( npc, enemy_id )
  local function check_enemy( npc, obj )
    if
      obj and obj.clsid  and IsStalker( obj ) and obj:alive()
      and npc:id() ~= obj:id() and obj:id() ~= db.actor:id()
    then
      if
        npc:relation( obj ) == game_object.friend
        or (
          radio_comms[ npc:character_community() ]
          and npc:character_community() == obj:character_community()
        )
        or (
          npc:relation( obj ) ~= game_object.enemy
          and npc:position():distance_to( obj ) < 25
        )
      then
        if
          primary_target[ obj:id() ]
          and primary_target[ obj:id() ] == enemy_id
        then
          return true
        end
      end
    end
    return false
  end
  for o in npc:memory_visible_objects() do
    if check_enemy( npc, o:object() ) then return true end
  end
  for o in npc:memory_sound_objects() do
    if check_enemy( npc, o:object() ) then return true end
  end
  return false
end


function notify_friends( npc, enemy )
  local function notify_friend( npc, obj )
    if
      obj and obj.clsid and IsStalker( obj ) and obj:alive()
      and npc:id() ~= obj:id()
      and obj:id() ~= db.actor:id()
      and not xr_wounded.is_wounded( obj )
    then
      if
        npc:relation( obj ) == game_object.friend
        or (
          radio_comms[ npc:character_community() ]
          and npc:character_community() == obj:character_community()
        )
        or (
          npc:relation( obj ) ~= game_object.enemy
          and npc:position():distance_to( obj ) < 25
        )
      then
        process_enemy( obj, enemy )
      end
    end
  end
  local notified = {}
  for o in npc:memory_visible_objects() do
    if not notified[ o:object():id() ] then
      notify_friend( npc, o:object() )
      notified[ o:object():id() ] = true
    end
  end
  for o in npc:memory_sound_objects() do
    if not notified[ o:object():id() ] then
      notify_friend( npc, o:object() )
      notified[ o:object():id() ] = true
    end
  end
end


function disable_object( npc, enemy ) -- забыть объект
  if npc and enemy then
    local id = enemy:id()
    if not disabled_objects[ npc:id() ] then
      disabled_objects[ npc:id() ] = {}
    end
    if not disabled_objects[ npc:id() ][ id ] then
      npc:enable_memory_object( enemy, false )
      disabled_objects[ npc:id() ][ id ] = id
    end
  end
end


function enable_object( npc, enemy ) -- вспомнить объект
  if npc and enemy then
    local id = enemy:id()
    if disabled_objects[ npc:id() ] and disabled_objects[ npc:id() ][ id ] then
      npc:enable_memory_object( enemy, true )
      disabled_objects[ npc:id() ][ id ] = nil
    end
  end
end


local damage_from_actor = {}
local crit_anims        = {
  [ "pistol" ] = {
    [ "heavy"  ] = {
      [ "belly"      ] = "norm_1_critical_hit_torso_0",
      [ "hand_left"  ] = "norm_1_critical_hit_hend_left_0",
      [ "hand_right" ] = "norm_1_critical_hit_hend_right_0",
      [ "head"       ] = "norm_1_critical_hit_head_0",
      [ "leg_left"   ] = "norm_1_critical_hit_legs_left_0",
      [ "leg_right"  ] = "norm_1_critical_hit_legs_right_0",
      [ "torso"      ] = "norm_1_critical_hit_torso_0",
    },
    [ "medium" ] = {
      [ "belly"      ] = "norm_1_critical_hit_torso_0",
      [ "hand_left"  ] = "norm_1_critical_hit_hend_left_0",
      [ "hand_right" ] = "norm_1_critical_hit_hend_right_0",
      [ "head"       ] = "norm_1_critical_hit_head_0",
      [ "leg_left"   ] = "norm_1_critical_hit_legs_left_0",
      [ "leg_right"  ] = "norm_1_critical_hit_legs_right_0",
      [ "torso"      ] = "norm_1_critical_hit_torso_0",
    },
    [ "light"  ] = {
      [ "belly"      ] = "norm_1_critical_hit_torso_0",
      [ "hand_left"  ] = "norm_1_critical_hit_hend_left_0",
      [ "hand_right" ] = "norm_1_critical_hit_hend_right_0",
      [ "head"       ] = "norm_1_critical_hit_head_0",
      [ "leg_left"   ] = "norm_1_critical_hit_legs_left_0",
      [ "leg_right"  ] = "norm_1_critical_hit_legs_right_0",
      [ "torso"      ] = "norm_1_critical_hit_torso_0",
    },
  },
  [ "rifle" ] = {
    [ "heavy"  ] = {
      [ "belly"      ] = "norm_3_critical_hit_torso_0",
      [ "hand_left"  ] = "norm_3_critical_hit_hend_left_0",
      [ "hand_right" ] = "norm_3_critical_hit_hend_right_0",
      [ "head"       ] = "norm_3_critical_hit_head_0",
      [ "leg_left"   ] = "norm_3_critical_hit_legs_left_0",
      [ "leg_right"  ] = "norm_3_critical_hit_legs_right_0",
      [ "torso"      ] = "norm_2_critical_hit_torso_0",
    },
    [ "medium" ] = {
      [ "head"       ] = "norm_8_critical_hit_head_1",
      [ "hand_left"  ] = "norm_8_critical_hit_hend_left_2",
      [ "hand_right" ] = "norm_8_critical_hit_hend_right_2",
      [ "leg_left"   ] = "norm_8_critical_hit_legs_left_1",
      [ "leg_right"  ] = "norm_8_critical_hit_legs_right_1",
      [ "torso"      ] = "norm_2_critical_hit_torso_0",
      [ "belly"      ] = "norm_2_critical_hit_torso_1",
    },
    [ "light"  ] = {
      [ "belly"      ] = "norm_8_critical_hit_torso_2",
      [ "hand_left"  ] = "norm_8_critical_hit_hend_left_0",
      [ "hand_right" ] = "norm_8_critical_hit_hend_right_0",
      [ "head"       ] = "norm_8_critical_hit_head_0",
      [ "leg_left"   ] = "norm_8_critical_hit_legs_left_0",
      [ "leg_right"  ] = "norm_8_critical_hit_legs_right_0",
      [ "torso"      ] = "norm_8_critical_hit_torso_1",
    },
  },
}

function hit_fx( obj, amount, who, bone_index )
  if ( not obj ) or xr_wounded.is_wounded( obj ) or not obj:alive() then
    return
  end

  if hit_timeout[ obj:id() ] and hit_timeout[ obj:id() ] > time_global() then
    return
  elseif hit_timeout[ obj:id() ] then
    hit_timeout[ obj:id() ] = nil
  end

  local binder = obj:binded_object()
  if not binder.last_hit_data then return end
  local hd       = binder.last_hit_data
  local hit_type = hd.hit_type
  ASSERT( hit_type, "hit_type not found" )
  if not ( hit_type == hit.fire_wound or hit_type == hit.explosion ) then
    return
  end
  if not ( hd.weapon_id or hd.who_id ) then return end
  local wpn = level.object_by_id( hd.weapon_id or hd.who_id )
  if not wpn then return end

  local weap_class = get_u32( wpn:section(), "ef_weapon_type" )
  if not weap_class then return end

  local key_1
  if weap_class > 5 then
    key_1 = "rifle"
  else
    key_1 = "pistol"
  end

  local has_exo = is_exo_visual( obj )
  local key_2, hit_delay
  if amount > 0.01 then
    if amount <= 0.1 or has_exo then
      hit_delay = 1000
      key_2     = "light"
    elseif amount <= 0.25 then
      hit_delay = 1500
      key_2     = "medium"
    else
      hit_delay = 2000
      key_2     = "heavy"
    end
  end

  local key_3
  local need_drop = false
  if bone_index and bone_index > 0 then
    if bone_index < 5 then
      key_3 = "leg_left"
    elseif bone_index >= 5 and bone_index < 9 then
      key_3 = "leg_right"
    elseif bone_index == 9 then
      key_3 = "belly"
    elseif bone_index == 10 then
      key_3 = "torso"
    elseif bone_index >= 11 and bone_index < 18 then
      key_3 = "head"
    elseif bone_index >= 18 and bone_index < 31 then
      key_3 = "hand_left"
    elseif bone_index >= 31 and bone_index < 40 then
      key_3 = "hand_right"
--[=[
      if not has_exo then
        local r = -1
        if bone_index == 33 then
          -- попадание в предплечье
          r = math.random() * 100
          need_drop = r < 30
        end
        if bone_index >= 34 and bone_index <= 38 then
          -- по кисти или пальцам
          r = math.random()*100
          need_drop = r < 50
        end
      end
--]=]
    end
  end

  if key_1 and key_2 and key_3 then
    local anim = crit_anims[ key_1 ][ key_2 ][ key_3 ]
    if anim then
      obj:add_animation( anim, true, false )
      if hit_delay then
        hit_timeout[ obj:id() ] = time_global() + hit_delay
      end
    end
  end

--[=[
  if need_drop and who:id() == db.actor:id() then
    local active_item = obj:active_item()
    if active_item then
      obj:drop_item( active_item )
    end
  end
--]=]
end


function hit_callback( obj, amount, local_direction, who, bone_index )
  -- если объект был ранее забыт - очухиваем его, если нету в табличке
  -- записываем в табличку
  local npc = obj
  if who and npc and who:id() == npc:id() then return end
  hit_fx( npc, amount, who, bone_index )

  if
    amount and amount > 0.01 and npc:alive() and not xr_wounded.is_wounded( npc )
  then
    if IsStalker( who ) then
      if who:alive() then
        if
          targets_list[ npc:id() ] and not targets_list[ npc:id() ][ who:id() ]
        then
          if who:id() == db.actor:id() then
            enable_object( npc, who )
            if check_is_enemy( npc, who ) then
              register_as_target( npc, who )
            else
              if not damage_from_actor[ npc:id() ] then
                damage_from_actor[ npc:id() ] = amount
              else
                damage_from_actor[ npc:id() ] =
                  damage_from_actor[ npc:id() ] + amount
              end
              if damage_from_actor[ npc:id() ] > 0.2 then
                register_as_target( npc, who )
              end
            end
            -- npc:make_object_visible_somewhen( who )
          else
            enable_object( npc, who )
            process_enemy( npc, who )
            -- npc:make_object_visible_somewhen( who )
          end
        elseif
          targets_list[ npc:id() ] and targets_list[ npc:id() ][ who:id() ]
        then
          local enemy_record = targets_list[ npc:id() ][ who:id() ]
          enemy_record.last_time_seen = time_global()
          enemy_record.vertex         = who:level_vertex_id()
        end
        if
          not (
            (
              npc:relation( who ) ~= game_object.enemy
              or npc:character_community() == who:character_community()
            )
            and who:id() ~= db.actor:id()
            and not xr_companion.is_companion( who:id() )
          )
        then
          if not hit_memory[ npc:id() ] then
            hit_memory[ npc:id() ] = {}
          end
          local mem = hit_memory[ npc:id() ]
          mem[ who:id() ] = true
          if amount > 0.1 then
            primary_target[ npc:id() ] = who:id()
          end
        elseif
          npc:relation(who) ~= game_object.enemy
          or npc:character_community() == who:character_community()
        then
          set_sound_event( npc, "ff" )
        end
      end
    elseif IsMonster( who ) then
      if who:alive() then
        if
          targets_list[ npc:id() ] and not targets_list[ npc:id() ][ who:id() ]
        then
          enable_object( npc, who )
          process_enemy( npc, who )
          -- npc:make_object_visible_somewhen( who )
        elseif
          targets_list[ npc:id() ] and targets_list[ npc:id() ][ who:id() ]
        then
          local enemy_record = targets_list[ npc:id() ][ who:id() ]
          enemy_record.last_time_seen = time_global()
          enemy_record.vertex         = who:level_vertex_id()
        end
        if not hit_memory[ npc:id() ] then
          hit_memory[ npc:id() ] = {}
        end
        local mem = hit_memory[ npc:id() ]
        mem[ who:id() ] = true
        if amount > 0.1 then
          primary_target[ npc:id() ] = who:id()
        end
      end
    elseif is_armor( who ) and armor_alive( who ) then
      if
        targets_list[ npc:id() ] and not targets_list[ npc:id() ][ who:id() ]
      then
        enable_object( npc, who )
        process_enemy( npc, who )
        -- npc:make_object_visible_somewhen( who )
      elseif
        targets_list[ npc:id() ] and targets_list[ npc:id() ][ who:id() ]
      then
        local enemy_record = targets_list[ npc:id() ][ who:id() ]
        enemy_record.last_time_seen = time_global()
        enemy_record.vertex         = who:level_vertex_id()
      end
    end

    if in_hideout( npc ) then
      if last_hideout[ npc:id() ] then
        locked_vertexes[ 0 ] = last_hideout[ npc:id() ].vtx
        bad_hide[ last_hideout[ npc:id() ].vtx ] = time_global() + 30000
        last_hideout[ npc:id()     ] = nil
        -- last_time_send[ npc:id()   ] = nil
        last_sent_vertex[ npc:id() ] = nil
      end
    end
    last_time_send[ npc:id() ] = nil

    local deadman = have_fresh_deadman( npc )
    if deadman ~= false then
      last_target[ npc:id() ][ deadman ] = nil
      last_enemy[ npc:id()        ] = nil
      last_enemy_id[ npc:id()     ] = nil
      primary_target[ npc:id()    ] = nil
      last_reprioritize[ npc:id() ] = nil
    end
  end
end


function death_place( obj, who )
  local npc       = obj
  local vertex    = npc:level_vertex_id()
  for k, v in pairs( death_places ) do
    if v.ttl <= time_global() then
      death_places[ k ] = nil
    end
  end
  if who:is_stalker() or who:is_actor() then
    death_places[ vertex ] = {
      killer = who:id(),
      ttl    = time_global() + 30000,
    }
  end
  local check = active_grenades[ npc:id() ]
  if check then
    grenka_already_blow[ check.grenade ] = true
    escape_point[ npc:id()    ] = nil
    active_grenades[ npc:id() ] = nil
  end
  reset_everything( npc )
end


function go_offline( obj )
  reset_everything( obj )
end


function reset_everything( npc )
  local binder = npc:binded_object()
  binder[ "xrs_battle_ai.set_combat_sight" ] = nil
  already_hear[ npc:id() ] = nil
  choosen_hide_combat_state[ npc:id() ] = nil
  choosen_hide_state[ npc:id() ] = nil
  cooldown[ npc:id() ] = nil
  deadman_vtx[ npc:id() ] = nil
  disabled_objects[ npc:id() ] = nil
  hit_memory[ npc:id() ] = nil
  inited[ npc:id() ] = nil
  intro_time[ npc:id() ] = nil
  last_choosed_path[ npc:id() ] = nil
  last_enemy[ npc:id() ] = nil
  last_enemy_id[ npc:id() ] = nil
  last_hideout[ npc:id() ] = nil
  last_reprioritize[ npc:id() ] = nil
  last_sent_vertex[ npc:id() ] = nil
  last_time_send[ npc:id() ] = nil
  locked_vertexes[ npc:id() ] = nil
  primary_target[ npc:id() ] = nil
  sounds_timeout[ npc:id() ] = nil
  targets_list[ npc:id() ] = {}
  time_hide[ npc:id() ] = nil
end


function its_a_trap( npc, vertex )
  local community  = npc:character_community()
  local vertex_pos = level.vertex_position( vertex )
  for k, v in pairs( death_places ) do
    local k_pos = level.vertex_position( k )
    if
      v.ttl > time_global()
      and ( k == vertex or k_pos:distance_to( vertex_pos ) < 10 )
    then
      local enemy = level.object_by_id( v.killer )
      if
        enemy
        and (
          (
            IsStalker( enemy ) and enemy:character_community() ~= community
            and check_is_enemy( npc, enemy )
          )
          or is_armor( enemy )
        )
        and (
          enemy:alive() or ( is_armor( enemy ) and armor_alive( enemy ) )
        )
        and not xr_wounded.is_wounded( enemy )
      then
        return true
      end
      if
        ( not enemy )
        or (
          ( is_armor( enemy ) and not armor_alive( enemy ) )
          or ( not enemy:alive() )
          or ( IsStalker( enemy ) and xr_wounded.is_wounded( enemy ) )
        )
      then
        death_places[ k ] = nil
      end
    end
  end
  return false
end


function process_enemy( npc, may_be_enemy )
  local valid, enemy = validate_enemy_object( may_be_enemy )
  if valid == false or not enemy then return end
  if npc:id() ~= enemy:id() then
    if not already_know_about[ npc:id() ] then
      already_know_about[ npc:id() ] = {}
    end
    if
      npc:relation( enemy ) == game_object.friend
      or (
        IsStalker( enemy )
        and npc:character_community() == enemy:character_community()
      )
    then
      if not enemy:alive() then
        if not already_know_about[ npc:id() ][ enemy:id() ] then
          set_sound_event( npc, "dead" )
          already_know_about[ npc:id() ][ enemy:id() ] = true
        end
      elseif IsStalker( enemy ) and xr_wounded.is_wounded( enemy ) then
        if not already_know_about[ npc:id() ][ enemy:id() ] then
          set_sound_event( npc, "fr_hit" )
          already_know_about[ npc:id() ][ enemy:id() ] = true
        end
      end
    end
  else
    return
  end
  if
    enemy:alive()
    and not ( IsStalker( enemy ) and xr_wounded.is_wounded( enemy ) )
  then
    if we_are_under_attack( npc, enemy ) then
      -- человек ты иль монструшка
      -- check_is_enemy( npc, enemy )
      if IsStalker( enemy ) and check_is_enemy( npc, enemy ) then
        register_as_target( npc, enemy )
      elseif IsMonster( enemy ) and check_is_enemy( npc, enemy ) then
        register_as_target( npc, enemy )
      end
    end
  end
end


function we_are_under_attack( npc, enemy )
  if enemy:id() ~= db.actor:id() then
    local target           = enemy:best_enemy()
    local danger_by_engine = enemy:best_danger()
    local best_danger_object, bd_type
    if danger_by_engine and check_is_enemy( npc, enemy ) then
      best_danger_object = danger_by_engine:object()
    end
    if ( not target ) and best_danger_object then
      bd_type = danger_by_engine:type()
      if targeting_dangers[ bd_type ] then
        target = best_danger_object
      end
    end
    if target then
      if
        target:id() == npc:id()
        or (
          IsStalker( target ) and target:alive()
          and (
            npc:relation( target ) == game_object.friend
            or npc:character_community() == target:character_community()
          )
        )
      then
        return true
      else
        return false
      end
    else
      return false
    end
  else
    if check_is_enemy( npc, db.actor ) then
      local be = npc:best_enemy()
      local bd = npc:best_danger()
      local bd_obj
      if bd then
        bd_obj = bd:object()
      end
      if be and be:id() == db.actor:id() then
        return true
      elseif bd_obj and bd_obj:id() == db.actor:id() then
        local bd_type = bd:type()
        if needed_dangers[ bd_type ] then
          return true
        end
      else
        return false
      end
    else
      return false
    end
  end
  return false
end


function is_enemy_see( enemy, npc )
  if enemy:see( npc ) then
    return true
  elseif enemy:is_actor() then
    return actor_see( npc )
  elseif IsStalker( enemy ) or IsMonster( enemy ) then
    return
      ( enemy:best_enemy() and enemy:best_enemy():id() == npc:id() )
      and true or false
  end
  return false
end


function register_as_target_companions( npc )
  for id, _ in pairs( xr_companion.companions ) do
    local enemy = level.object_by_id( id )
    if enemy then
      if
        ( not targets_list[ npc:id() ] ) or not targets_list[ npc:id() ][ id ]
      then
        if npc and npc:alive() and not xr_wounded.is_wounded( npc ) then
          local dist = npc:position():distance_to( enemy:position() )
          local enemy_record = {
            npc    = IsStalker( enemy ),
            range  = dist,
            vis    = is_enemy_see( enemy, npc ),
            weight = 1000,
          }
          if enemy_record.vis and enemy_record.npc then
            enemy_record.last_time_seen = time_global()
            enemy_record.vertex         = enemy:level_vertex_id()
          end
          if not targets_list[ npc:id() ] then
            targets_list[ npc:id() ] = {}
          end
          targets_list[ npc:id() ][ id ] = enemy_record
        end
      end
    end
  end
end


function register_as_target( npc, enemy )
  local id = enemy:id()
  if
    ( not targets_list[ npc:id() ] ) or not targets_list[ npc:id() ][ id ]
  then
    if id == db.actor:id() then
      register_as_target_companions( npc ) --KRodin: вообще мне кажется, что это не особо нужно.
    end
    if npc and npc:alive() and not xr_wounded.is_wounded(npc) then
      local dist = npc:position():distance_to( enemy:position() )
      local enemy_record = {
        npc    = IsStalker( enemy) ,
        range  = dist,
        vis    = is_enemy_see( enemy, npc ),
        weight = 1000,
      }
      if enemy_record.vis and enemy_record.npc then
        enemy_record.last_time_seen = time_global()
        enemy_record.vertex         = enemy:level_vertex_id()
      end
      if not targets_list[ npc:id() ] then
        targets_list[ npc:id() ] = {}
      end
      targets_list[ npc:id() ][ id ] = enemy_record
    else
      return
    end
  end
end


function reprioritize_targets( npc )
  -- обновление основной цели, вызывается из апдейта или любой другой
  -- аналогичной обработки, хоть из эвалуатора
  -- обновим предварительно реестр целей
  if
    last_reprioritize[ npc:id() ]
    and last_reprioritize[ npc:id() ] > time_global()
  then
    return
  end

  get_targets_from_memory( npc )
  refresh_targets( npc )

  if locked_vertexes[ 0 ] then
    local check_hide = locked_vertexes[ 0 ]
    local check_time = bad_hide[ check_hide ]
    if time_global() > check_time then
      bad_hide[ check_hide ] = nil
      locked_vertexes[ 0 ]   = nil
    end
  end

  local enemy_by_engine = npc:best_enemy()
  for k, v in pairs( targets_list[ npc:id() ] ) do
    if v.vis then               -- если цель видит нас
      local close_combat, far_combat = combat_ranges( npc, v.npc )
      local mult = combat_multiplier( v.npc )
      if not v.npc then         -- если она монстр
        if v.armor then         -- если она пиздец едучий/летячий
          if v.range >= 100 and v.range < 150 then -- и цель далеко
            v.weight = v.range * mult
          elseif v.range < 100 then -- а если близко
            v.weight = v.range * mult * 3
          end
        else
          if v.range >= close_combat and v.range < far_combat then
            -- и цель на средней дистанции
            v.weight = v.range * mult
          elseif v.range < close_combat then -- а если вплотную
            v.weight = v.range * mult -- 0
          elseif check_friends_enemy( npc, k ) then
            v.weight = v.range * mult * 3
          end
        end
      else -- а если непись
        if v.range >= close_combat and v.range < far_combat then
          -- если не ближний бой
          v.weight = v.range
        elseif v.range < close_combat then -- а если ближний
          v.weight = v.range * mult
        elseif v.range > far_combat and v.range < ( npc:range() * 1.5 ) then
          -- сверхдальний бой
          v.weight = v.range * mult * 2
        elseif check_friends_enemy( npc, k ) then
          v.weight = v.range * mult * 3
        end
      end
    else -- если не видит
      if primary_target[ npc:id() ] == k then
        last_target[ npc:id() ][ k ] = time_global()
        primary_target[ npc:id() ] = nil
      end
      if not v.npc then         -- если она монстр
        if v.armor then         -- если она пиздец едучий/летячий
          if v.range < 150 then
            v.weight = v.range * 2
          else
            v.weight = 1000
          end
        else
          if v.range < max_invisible_range_mon then
            v.weight = v.range * 2
          else
            v.weight = 1000
          end
        end
      else                                        -- а если непись
        if v.range < max_invisible_range_npc then -- если в радиусе "слуха"
          v.weight = v.range * 3
        elseif v.range < distant_combat_distance then
          -- если в радиусе дальнего боя
          if
            v.last_time_seen
            and v.last_time_seen + memory_timeout > time_global()
          then
            -- если видели её не менее минуты назад
            v.weight = v.range * 5
          else
            v.weight = 1000
          end
        else
          v.weight = 1000
        end
      end
    end
    if
      enemy_by_engine and enemy_by_engine:alive()
      and not (
        IsStalker( enemy_by_engine )
        and xr_wounded.is_wounded( enemy_by_engine )
      )
      and k == enemy_by_engine:id()
    then
      v.weight = v.weight / 1.3
    end
  end

  local last_range
  local last_weight = 1000
  for k, v in pairs( targets_list[ npc:id() ] ) do
    if v.weight < last_weight then
      last_range  = v.range
      last_weight = v.weight
      primary_target[ npc:id() ] = k
    end
  end

  if not primary_target[ npc:id() ] then
    for k, v in pairs( targets_list[ npc:id() ] ) do
      if v.range < last_weight then
        last_weight = v.range
        if
          v.npc
          and v.range < close_combat_distance
          and v.last_time_seen
          and v.last_time_seen + memory_timeout < time_global()
        then
          last_range = v.range
          primary_target[ npc:id() ] = k
        end
      end
    end
  end
  if last_range then
    last_target[ npc:id() ] = {}
  end

  if primary_target[ npc:id() ] then
    if last_range and last_range > npc:range() then
      npc:set_range( last_range * 1.1 )
    end
    last_reprioritize[ npc:id() ] = time_global() + reprioritize_timeout
  else
    local deadman = have_fresh_deadman( npc )
    if deadman == false then
      last_enemy[ npc:id()     ] = nil
      last_enemy_id[ npc:id()  ] = nil
      primary_target[ npc:id() ] = nil
      last_target[ npc:id()    ] = {}
    end
    last_reprioritize[ npc:id() ] = time_global() + 500
  end
end


function is_armor( target )
  local level_name = level.name()
  if not armor_allowed_locations[ level_name ] then return false end
  local heli = db.heli[ target:id() ]
  local car  = db.cars[ target:id() ]
  if heli or car then
    return true
  else
    return false
  end
end


function get_armor_vis( target, npc )
  local heli = db.heli[ target:id() ]
  local car  = db.cars[ target:id() ]
  if heli then
    return target:get_helicopter():isVisible( npc )
  else
    return target:get_car():IsObjectVisible( npc )
  end
end


function armor_alive( target )
  local heli = db.heli[ target:id() ]
  local car  = db.cars[ target:id() ]
  if heli then
    return target:get_helicopter():GetfHealth() > 0.05
  elseif car then
    return target:get_car():GetfHealth() > 0.05
  end
end


function refresh_targets( npc )
  -- обновление реестра врагов, вызывается из reprioritize_targets
  -- добавление движкового врага
  local enemy_by_engine = npc:best_enemy()
  if
    enemy_by_engine and enemy_by_engine:alive()
    and (
      not (
        IsStalker( enemy_by_engine )
        and xr_wounded.is_wounded( enemy_by_engine )
      )
    )
    and is_enemy_see( enemy_by_engine, npc )
  then
    if
      ( not targets_list[ npc:id() ][ enemy_by_engine:id() ] )
      and not (
        disabled_objects[ npc:id() ]
        and disabled_objects[ npc:id() ][ enemy_by_engine:id() ]
      )
    then
      if
        check_is_enemy( npc, enemy_by_engine )
        or (
          xr_companion.is_companion( enemy_by_engine:id() )
          and check_is_enemy( npc, db.actor )
        )
      then
        register_as_target( npc, enemy_by_engine )
      else
        disable_object( npc, enemy_by_engine )
        if primary_target[ npc:id() ] == enemy_by_engine:id() then
          last_target[ npc:id() ][ enemy_by_engine:id() ] = time_global()
          primary_target[ npc:id() ] = nil
        end
        targets_list[ npc:id() ][ enemy_by_engine:id() ] = nil
      end
    end
  end

  -- добавление нападающего денжера
  local danger_by_engine = npc:best_danger()
  if danger_by_engine then
    local best_danger_object = danger_by_engine:object()
    if best_danger_object then
      local bd_type = danger_by_engine:type()
      local is_stalker_obj = IsStalker( best_danger_object )
      if is_stalker_obj and check_is_enemy( npc, best_danger_object ) then
        local is_still_alive = best_danger_object:alive()
        if
          is_still_alive and not xr_wounded.is_wounded( best_danger_object )
        then
          if needed_dangers[ bd_type ] then
            if
              ( not targets_list[ npc:id() ][ best_danger_object:id() ] )
              and not (
                disabled_objects[ npc:id() ]
                and disabled_objects[ npc:id() ][ best_danger_object:id() ]
              )
            then
              if
                check_is_enemy( npc, best_danger_object )
                or (
                  xr_companion.is_companion( best_danger_object:id() )
                  and check_is_enemy( npc, db.actor )
                )
              then
                register_as_target( npc, best_danger_object )
              else
                disable_object( npc, best_danger_object )
                if primary_target[ npc:id() ] == best_danger_object:id() then
                  last_target[ npc:id() ][ best_danger_object:id() ] = time_global()
                  primary_target[ npc:id() ] = nil
                end
                targets_list[ npc:id() ][ best_danger_object:id() ] = nil
              end
            end
          end
        end
      end
    end
  end

  for k, v in pairs( targets_list[ npc:id() ] ) do
    local check_target = level.object_by_id( k )
    if
      check_target
      and (
        (
          check_target:alive()
          and not (
            IsStalker( check_target ) and xr_wounded.is_wounded( check_target )
          )
        )
          or ( is_armor( check_target ) and armor_alive( check_target ) )
      )
    then
      if is_armor( check_target ) then
        v.vis = get_armor_vis( check_target, npc )
      else
        v.vis = is_enemy_see( check_target, npc )
      end
      local dist = npc:position():distance_to( check_target:position() )
      v.range = dist
      if not v.vis then
        if not v.npc then
          if v.armor then
            v.vertex = check_target:level_vertex_id()
            if dist > 200 then
              disable_object( npc, check_target )
              if primary_target[ npc:id() ] == k then
                last_target[ npc:id() ][ k ] = time_global()
                primary_target[ npc:id() ] = nil
              end
              targets_list[ npc:id() ][ k ] = nil
            end
          else
            if dist > 100 then
              disable_object( npc, check_target )
              if primary_target[ npc:id() ] == k then
                last_target[ npc:id() ][ k ] = time_global()
                primary_target[ npc:id() ] = nil
              end
              targets_list[ npc:id() ][ k ] = nil
            end
          end
        else
          if check_is_enemy( npc, check_target ) then
            if dist > 100 and k ~= db.actor:id() then
              disable_object( npc, check_target )
              if primary_target[ npc:id() ] == k then
                last_target[ npc:id() ][ k ] = time_global()
                primary_target[ npc:id() ] = nil
              end
              targets_list[ npc:id() ][ k ] = nil
            else
              if npc:see( check_target ) or is_camper( npc ) then
                v.last_time_seen = time_global()
                v.vertex         = check_target:level_vertex_id()
              end
            end
          else
            disable_object( npc, check_target )
            if primary_target[ npc:id() ] == k then
              last_target[ npc:id() ][ k ] = time_global()
              primary_target[ npc:id() ] = nil
            end
            targets_list[ npc:id() ][ k ] = nil
          end
        end
      else
        if v.npc or v.armor then
          v.last_time_seen = time_global()
          v.vertex         = check_target:level_vertex_id()
        end
      end
    elseif check_target then
      if not check_target:alive() then
        set_sound_event( npc, "killed" )
      elseif
        IsStalker( check_target ) and xr_wounded.is_wounded( check_target )
      then
        set_sound_event( npc, "hit" )
      end
      disable_object( npc, check_target )
      if primary_target[ npc:id() ] == k then
        last_target[ npc:id() ][ k ] = time_global()
        primary_target[ npc:id() ] = nil
      end
      targets_list[ npc:id() ][ k ] = nil
    else
      if primary_target[ npc:id() ] == k then
        primary_target[ npc:id() ] = nil
        local self_hit = hit()
        self_hit.type      = hit.strike
        self_hit.power     = 0
        self_hit.impulse   = 0.01
        self_hit.draftsman = npc
        self_hit.direction = vector():set( 0, 0, 0 )
        npc:hit( self_hit )
      end
      targets_list[ npc:id() ][ k ] = nil
    end
  end
end


function register_as_target_armor( npc, enemy )
  local id = enemy:id()
  if
    ( not targets_list[ npc:id() ] ) or not targets_list[ npc:id() ][ id ]
  then
    local enemy_record = {
      armor  = true,
      npc    = false,
      range  = npc:position():distance_to( enemy:position() ),
      vis    = false,
      weight = 1000,
    }
    if string.find( enemy:name(), "btr" ) then
      enemy_record.vis = enemy:get_car():IsObjectVisible( npc )
    else
      enemy_record.vis = enemy:get_helicopter():isVisible( npc )
    end
    if enemy_record.vis then
      enemy_record.last_time_seen = time_global()
      enemy_record.vertex         = enemy:level_vertex_id()
    end
    if not targets_list[ npc:id() ] then
      targets_list[ npc:id() ] = {}
    end
    targets_list[ npc:id() ][ id ] = enemy_record
  end
end


local hostile_treshold = get_float( "game_relations", "attitude_neutal_threshold" )
function is_hostile_armor( comm, target )
  local t_comm = "actor"
  if
    string.find( target:section(), "helicopter" )
    or string.find( target:section(), "mi24" )
    or string.find( target:section(), "mi2"  )
    or string.find( target:section(), "mi6"  )
  then
    if target:spawn_ini():line_exist( "logic", "community" ) then
      t_comm = ini:r_string( "logic", "community" )
    else
      t_comm = "military"
    end
  elseif string.find( target:name(), "btr" ) then
    local check_comm = ogse_scripted_btr.cars_comm[target:name()]
    if not check_comm then
      t_comm = "military"
    end
  end

  -- квестовая врезка начало
  if
    level.name() == "l13_generators_ogse"
    and (
      string.find( target:section(), "helicopter" )
      or string.find( target:section(), "mi24" )
    )
    and ( comm == "freedom" or comm == "dolg" )
  then
    return false
  end
  -- квестовая врезка конец

  return utils2.community_relation_safe( comm, target:id(), t_comm ) < hostile_treshold
end


function check_helicopter( npc )
  local level_name = level.name()
  if not armor_allowed_locations[ level_name ] then return end
  local npc_position = npc:position()
  for k, v in pairs( db.heli ) do
    local heli   = v:get_helicopter()
    local health = heli:GetfHealth()
    if health < 0 then
      health = 0
    end
    if
      health > 0.005
      and v:position():distance_to( npc_position ) <= 150
      and is_hostile_armor( npc:character_community(), v )
    then
      register_as_target_armor( npc, v )
    end
  end
end


function check_btr(npc)
  local level_name = level.name()
  if not armor_allowed_locations[ level_name ] then return end
  local npc_position = npc:position()
  for k, v in pairs( db.cars ) do
    if string.find( v:name(), "btr" ) then
      local btr    = v:get_car()
      local health = btr:GetfHealth()
      if health < 0 then
        health = 0
      end
      if
        health > 0.005
        and v:position():distance_to( npc_position ) <= 150
        and is_hostile_armor( npc:character_community(), v )
      then
        register_as_target_armor( npc, v )
      end
    end
  end
end


function get_targets_from_memory( npc )
  -- сбор врагов, вызывается из reprioritize_targets
  check_helicopter( npc )
  check_btr( npc )
  for o in npc:memory_visible_objects() do
    process_enemy( npc, o:object() )
  end
  for o in npc:memory_sound_objects() do
    process_enemy( npc, o:object() )
  end
  local mem = hit_memory[ npc:id() ]
  if mem then
    for k, v in pairs( mem ) do
      local enemy = level.object_by_id( k )
      if enemy and IsStalker( enemy ) and enemy:alive() then
        process_enemy( npc, enemy )
      end
    end
  end
end


function get_last_enemy_lertex( npc )
  local id = last_enemy_id[ npc:id() ]
  if id then
    local t = targets_list[ npc:id() ][ id ]
    if t then
      return t.vertex
    end
  end
end


function get_max_weapon_range( npc, bw )
  -- служебная для проверки достанет ли оружие
  if npc then
    if not bw then bw = get_best_weapon( npc ) end
    local ini = system_ini()
    if bw then
      local sect = bw:section()
      if ini:section_exist( sect ) and ini:line_exist( sect, "max_radius" ) then
        return ini:r_float( sect, "max_radius" )
      elseif not ini:section_exist( sect ) then
        return 36
      elseif not ini:line_exist( sect, "max_radius" ) then
        return 36
      end
    else
      return 36
    end
  else
    return 36
  end
end


function combat_ranges( npc, enemy_is_npc )
  if npc then
    local wpn_check_max_range = get_max_weapon_range( npc )
    -- берем всех
    if enemy_is_npc then
      return low_range_npc_aggr, wpn_check_max_range
    else
      return low_range_mon_aggr, far_range_mon_aggr
    end
  else
    return 30, alife():switch_distance()
  end
end


function combat_multiplier( enemy_is_npc )
  if enemy_is_npc then
    return combat_mult_npc
  else
    return combat_mult_monster
  end
end


function have_fresh_deadman( npc )
  if not last_target[ npc:id() ] then return false end
  local target = false
  for k, v in pairs( last_target[ npc:id() ] ) do
    local obj     = level.object_by_id( k )
    local timeout = remember_enemy
    if obj and IsStalker( obj ) then
      timeout = timeout * 2
    end
    if obj and not ( IsStalker( obj ) or IsMonster( obj ) )  then
      last_target[ npc:id() ][ k ] = nil
    elseif not obj then
      last_target[ npc:id() ][ k ] = nil
    elseif v and v + timeout > time_global() then
      target = k
    else
      last_target[ npc:id() ][ k ] = nil
    end
  end
  if not target then
    postcombat[ npc:id() ] = nil
  end
  return target
end


-- Алгоритм озвучки: неперывно собираем информацию про звуковые
-- события. Если есть событие - расскажем о нем. Если нет события
-- врубаем айдл

-- Айдлы ставятся флагами и разворачиваются по ситуации. Те что
-- ставятся флагами это Атакуем, Защищаемся, Не видим противника.

-- Атакуем разворачивается в: Атакуем (видим и он нас видит), Атакуем
-- одного/Атакуем группу (видим и он нас НЕ видит)

-- Защищаемся не разворачивается

-- Не видим противника разворачивается в: Грозим близкому врагу/Грозим
-- далекому врагу (зависимо от расстояния, время потери до 10 секунд),
-- Ищем врага (от 10 до 20 секунд), Совсем потеряли врага (более 20
-- секунд)

-- Ставятся они в выброе типа перемещения, разворачивание производится
-- на основе таблицы целей

-- События добываются следующим образом:
-- Начало боя из старта боёвки
-- Идем в обход из выбора перемещения
-- Завалили врага из refresh_targets(npc), если цель погибла
-- Ранили врага из refresh_targets(npc), если цель ранена
-- Ранило друга из get_targets_from_memory(npc), если есть раненый
-- друг и мы его видим
-- Убило друга из get_targets_from_memory(npc), если есть убитый друг
-- и мы его видим
-- Френдли файр из хит коллбэка

-- События которые надо отыграть звуком
-- 1. Начало боя            fight_enemy
-- 2. Идем в обход          fight_detour
-- 3. Завалили врага        fight_enemy_down
-- 4. Ранили врага          fight_enemy_hit
-- 5. Ранило друга          fight_friend_hitted
-- 6. Убило друга           fight_tolls
-- 7. Френдли файр          fight_friendly_fire

-- Боевочные идлы
-- 1. Атакуем               fight_attack
-- 2. Атакуем одного        fight_attack_one
-- 3. Атакуем группу        fight_attack_many
-- 4. Защищаемся            fight_backup
-- 5. Ищем врага            fight_search
-- 6. Совсем потеряли врага fight_enemy_lost
-- 7. Грозим близкому врагу fight_threat_close
-- 8. Грозим далекому врагу fight_threat_distant

-- Функции: set_sound_event( npc, event ) -- выставить звуковое событие
-- допустимые значения event:
-- "start"
-- "hero"
-- "killed"
-- "hit"
-- "fr_hit"
-- "dead"
-- "ff"

-- choose_idle_scheme( npc, scheme ) -- выставить тип идловой озвучки
-- допустимые значеня scheme:
-- "attack"
-- "attack_notsee"
-- "defence"
-- "lost"

function setup_sound_table( npc )
  sound_events[ npc:id() ] = {
    events = {},
    idle   = "defence",
    start  = false,
    hero   = false,
    killed = false,
    hit    = false,
    fr_hit = false,
    dead   = false,
    ff     = false,
  }
end


function choose_idle_scheme( npc, scheme )
  -- допустимые значеня scheme:
  -- "attack"
  -- "attack_notsee"
  -- "defence"
  -- "lost"
  if not sound_events[ npc:id() ] then
    setup_sound_table( npc )
  end
  sound_events[ npc:id() ].idle = scheme
end


function set_sound_event( npc, event )
  if not sound_events[ npc:id() ] then
    setup_sound_table( npc )
  end
  -- Если недавно что-то уже говорил, то событие регистрировать не
  -- будем.
  if sounds_timeout[ npc:id() ] and sounds_timeout[ npc:id() ] > time_global() then
    return
  end
  local t = sound_events[ npc:id() ]
  -- Если это событие запрещено некоторе время озвучивать, то
  -- регистрировать его не будем.
  local e_timeout = t[ event .. "_timeout" ]
  if e_timeout and e_timeout > time_global() then return end
  if not t[ event ] then
    if event == "hero" then
      t.hero_timeout = time_global() + math.random( 10000, 30000 )
      if math.random() > sound_prob_hero then return end
    end
    t[ event ] = true
    table.insert( t.events, event );
  end
end


function set_combat_sound_playing( npc )
  sound_are_playing[ npc:id() ] = time_global() + math.random( 1000, 2500 )
end


function set_combat_sound_timeout( npc )
  sounds_timeout[ npc:id() ] = time_global() + math.random( 6000, 8000 )
end


function process_combat_sound( npc )
  if
    sound_are_playing[ npc:id() ]
    and sound_are_playing[ npc:id() ] > time_global()
  then
    return
  elseif sound_are_playing[ npc:id() ] then
    sound_are_playing[ npc:id() ] = nil
    xr_sound.set_sound( npc, nil )
    return
  end
  if
    sounds_timeout[ npc:id() ]
    and sounds_timeout[ npc:id() ] > time_global()
  then
    return
  end

  local snd_flags = sound_events[ npc:id() ]
  if table.getn( snd_flags.events ) > 0 then
    local e = snd_flags.events[ math.random( table.getn( snd_flags.events ) ) ]
    for _, k in ipairs( snd_flags.events ) do
      snd_flags[ k ] = false
    end
    snd_flags.events = {}
    if math.random() < sound_prob_event then
      local snd_theme
      if e == "start" then
        snd_theme = "fight_enemy"
      elseif e == "dead" then
        snd_theme = "fight_tolls"
      elseif e == "fr_hit" then
        snd_theme = "fight_friend_hitted"
      elseif e == "ff" then
        snd_theme = "fight_friendly_fire"
      elseif e == "killed" then
        snd_theme = "fight_enemy_down"
      elseif e == "hit" then
        snd_theme = "fight_enemy_hit"
      elseif e == "hero" then
        snd_theme = "fight_detour"
      end
      xr_sound.set_sound( npc, snd_theme )
      set_combat_sound_playing( npc )
      set_combat_sound_timeout( npc )
      return
    end
  end

  if
    snd_flags.idle_timeout
    and snd_flags.idle_timeout > time_global()
  then
    return
  end
  snd_flags.idle_timeout = time_global() + math.random( 10000, 30000 )
  if math.random() > sound_prob_idle then return end

  set_combat_sound_playing( npc )
  set_combat_sound_timeout( npc )
  if snd_flags.idle == "attack" then
    xr_sound.set_sound( npc, "fight_attack" )
  elseif snd_flags.idle == "attack_notsee" then
    local count = 0
    for k, v in pairs( targets_list[ npc:id() ] ) do
      if v.range < 50 then
        count = count + 1
      end
      if count >= 2 then
        break
      end
    end
    if count == 1 then
      xr_sound.set_sound( npc, "fight_attack_one" )
    elseif count > 1 then
      xr_sound.set_sound( npc, "fight_attack_many" )
    end
  elseif snd_flags.idle == "defence" then
    xr_sound.set_sound( npc, "fight_backup" )
  elseif snd_flags.idle == "lost" then
    local target = primary_target[ npc:id() ]
    local target_info = targets_list[ npc:id() ][ target ]
    if not target_info then return end
    if target_info and not target_info.last_time_seen then
      if math.random() < 0.2 then
        xr_sound.set_sound( npc, "fight_threat_close" )
      elseif math.random() < 0.4 then
        xr_sound.set_sound( npc, "fight_threat_distant" )
      elseif math.random() < 0.6 then
        xr_sound.set_sound( npc, "fight_search" )
      else
        xr_sound.set_sound( npc, "fight_enemy_lost" )
      end
      return
    end
    if time_global() - target_info.last_time_seen <= 5000 then
      if target_info.range < distant_combat_distance then
        xr_sound.set_sound( npc, "fight_threat_close" )
      else
        xr_sound.set_sound( npc, "fight_threat_distant" )
      end
    elseif time_global() - target_info.last_time_seen <= 12000 then
      xr_sound.set_sound( npc, "fight_search" )
    else
      xr_sound.set_sound( npc, "fight_enemy_lost" )
    end
  end
end


-- Возвращает угол между проекциями векторов vec1 и vec2 на
-- горизонтальную плоскость.
-- положительный угол - доворот vec1 до vec2 по часовой.
function horz_angle( vec1, vec2 )
  local x =  vec2.x * vec1.x + vec2.z * vec1.z
  -- повернули систему координат
  local y = -vec2.z * vec1.x + vec2.x * vec1.z
  return math.atan2( y, x )     -- угол доворота от -pi до pi
end


function vert_angle( vec1, vec2 )
  local x =  vec2.y * vec1.y + vec2.z * vec1.z
  -- повернули систему координат
  local y = -vec2.z * vec1.y + vec2.y * vec1.z
  return math.atan2( y, x )     -- угол доворота от -pi до pi
end


function actor_see( npc )
  -- арктангенс 45 град /npc:position():distance_to(db.actor:position())
  local dangerang = 1
  local ang = horz_angle(
    device().cam_dir, npc:position():sub( device().cam_pos )
  )
  local visibility_value = level.cover_in_direction(
    db.actor:level_vertex_id(), npc:position():sub( db.actor:position() )
  )
  local tgt = ang > -dangerang and ang < dangerang
    and visibility_value > visibility_treshold_value
  if tgt then
    return true
  end
  return false
end


function get_target( npc )
  local target_id = primary_target[ npc:id() ]
  local target
  if target_id then
    target = level.object_by_id( target_id )
  end
  return target
end


function has_full_weapon( npc, object )
  if object then
    return get_u32( object:section(), "ef_weapon_type" ) ~= 5
  end
  return true
end


function IsShotgun( object )
  if object then
    return get_u32( object:section(), "ef_weapon_type" ) == 7
  end
  return false
end


function IsSniperRifle( object )
  if object then
    return get_u32( object:section(), "ef_weapon_type" ) == 8
  end
  return false
end


function IsRPG(object)
  if object then
    return get_u32( object:section(), "ef_weapon_type" ) == 9
  end
  return false
end


function in_hideout( npc )
  if npc and last_hideout[ npc:id() ] then
    local npc_pos     = npc:position()
    local npc_vert    = npc:level_vertex_id()
    local hideout_pos = level.vertex_position( last_hideout[ npc:id() ].vtx )
    local distance_to_cover = npc_pos:distance_to( hideout_pos )
    if distance_to_cover < 3 or npc_vert == last_hideout[ npc:id() ].vtx then
      return true
    end
  end
  return false
end


function in_transit( npc )
  if npc and last_sent_vertex[ npc:id() ] then
    local npc_pos  = npc:position()
    local npc_vert = npc:level_vertex_id()
    local sent_pos = level.vertex_position( last_sent_vertex[ npc:id() ] )
    local distance_to_sent_pos = npc_pos:distance_to( sent_pos )
    if
      npc_vert ~= last_sent_vertex[ npc:id() ] and distance_to_sent_pos > 1.5
    then
      return distance_to_sent_pos
    end
  end
  return false
end


function set_weapons_fire( npc, enemy, weapon, override_vis, npc_rank )
  if hit_timeout[ npc:id() ] and hit_timeout[ npc:id() ] > time_global() then
    return
  elseif hit_timeout[ npc:id() ] then
    hit_timeout[ npc:id() ] = nil
  end

  if
    enemy
    and ( enemy:alive() or ( is_armor( enemy ) and armor_alive( enemy ) ) )
    and weapon and not ( IsStalker( enemy ) and xr_wounded.is_wounded( enemy ) )
  then
    local time_aim     = time_to_aim[ npc_rank ]
    local type_of_fire = object.aim1
    local be_pos       = enemy:position()
    local npc_pos      = weapon:get_weapon():get_fire_point()

    local binder = npc:binded_object()
    local st     = binder[ "xrs_battle_ai.set_combat_sight" ]
    if st and st.look_pos then
      be_pos = st.look_pos
    else
      if is_armor( enemy ) then
        if string.find( enemy:name(), "btr" ) then
          be_pos = enemy:bone_position( "mashine_gun_tower" )
        else
          be_pos = enemy:bone_position( "korpus1" )
        end
      else
        be_pos = enemy:bone_position( get_string(enemy:section(), "bone_head", "bip01_head") )
      end
    end
    local distance = npc_pos:distance_to( be_pos )

    local rq = npc:see_right_now( enemy )
    if is_armor( enemy ) and armor_alive( enemy ) then
      rq           = false
      type_of_fire = object.fire1
    else
      local weapon_unstrapped = npc:weapon_unstrapped()
      local anim              = db.storage[ npc:id() ].state_mgr.animstate:state()
      if
        ( not weapon_unstrapped ) or not_ready_states[ anim ]
        or ( IsRPG( weapon ) and distance < 25 )
      then
        rq           = false
        type_of_fire = object.aim1
      end
    end

    if rq then
      type_of_fire = object.fire1 -- по умолчанию можем стрелять

--[=[ --Тормозная проверка FF не нужна - FF игнорируется неписями в мотиваторе.
      local dir_enemy = utils.vector_copy_by_val( be_pos ):sub( npc_pos )
      dir_enemy:normalize()
      rq = level.ray_query(
        npc_pos, dir_enemy, distance + 5, rq_target.rqtBoth, npc
      )
      if rq.result then
        local obj = rq.object
        local is_alive_mob = obj and ( IsStalker( obj ) or IsMonster( obj ) )
          and obj:alive()
        if is_alive_mob and not check_is_enemy( npc, obj, true ) then
          -- если попадем в своего - стрелять нельзя
          type_of_fire = object.aim1
        end
      end
--]=]

    end

    if type_of_fire == object.fire1 then
      if st and st.use_deviation then
        st.use_deviation = false
        local dev = add_deviation( npc, be_pos, weapon, distance, enemy )
        be_pos.x  = be_pos.x + dev.x
        be_pos.y  = be_pos.y + dev.y
        be_pos.z  = be_pos.z + dev.z
        npc:set_sight( look.fire_point, be_pos )
      end
    end

    if IsShotgun( weapon ) then
      npc:set_item( type_of_fire, weapon, 1, time_aim.other )
    elseif IsSniperRifle( weapon ) then
      npc:set_item( type_of_fire, weapon, 1, time_aim.other )
    elseif IsRPG( weapon ) then
      npc:set_item( type_of_fire, weapon, 1, time_aim.rpg )
    else
      local qs = get_u32(
        weapon:section(), "xrs_battle_ai.preffered_fire_mode"
      )
      if not qs then
        qs = math.random( 2, 5 )
      end
      npc:set_item( type_of_fire, weapon, qs, time_aim.other )
    end

  end
end


function set_escape_state( npc, enemy )
  if hit_timeout[ npc:id() ] and hit_timeout[ npc:id() ] > time_global() then
    return
  elseif hit_timeout[ npc:id() ] then
    hit_timeout[ npc:id() ] = nil
  end

  local emerg
  local anim = db.storage[ npc:id() ].state_mgr.animstate:state()
  if not_ready_states[ anim ] then
    emerg = { animation = true, animation_nout = true }
  end

  if in_hideout( npc ) then
    state_mgr.set_state(
      npc, "claim",   nil, nil, { look_object = enemy }, emerg
    )
  elseif in_transit( npc ) then
    state_mgr.set_state(
      npc, "assault", nil, nil, { look_object = enemy }, emerg
    )
  else
    state_mgr.set_state(
      npc, "claim",   nil, nil, { look_object = enemy }, emerg
    )
  end
end


function looking_to_enemy( npc, enemy )
  local binder = npc:binded_object()
  local st     = binder[ "xrs_battle_ai.set_combat_sight" ]
  if
    st and st.look_pos
    and st.enemy_id == enemy:id() and st.time > time_global()
  then
    return { look_position = st.look_pos }
  end
  return { look_object = enemy }
end


function set_combat_state( npc, enemy, weapon )
  if hit_timeout[ npc:id() ] and hit_timeout[ npc:id() ] > time_global() then
    return
  elseif hit_timeout[ npc:id() ] then
    hit_timeout[ npc:id() ] = nil
  end

  local emerg
  local anim = db.storage[ npc:id() ].state_mgr.animstate:state()
  if not_ready_states[ anim ] then
    emerg = { animation = true, animation_nout = true }
  end

  local state_name
  if in_hideout( npc ) then
    local hide_val = last_hideout[ npc:id() ].value
    if hide_val <= 0.45 then
      state_name = "hide_fire"
    else
      state_name = "threat_fire"
    end
  elseif in_transit( npc ) then
    state_name = "raid_fire"
  else
    local npc_pos  = npc:position()
    local be_pos   = enemy:position()
    local distance = be_pos:distance_to( npc_pos )
    if distance < close_combat_distance then
      state_name = "threat_fire"
    else
      state_name = "hide_fire"
    end
  end

  if state_name then
    state_mgr.set_state(
      npc, state_name, nil, nil, looking_to_enemy( npc, enemy ), emerg
    )
  end
end


function set_transfer_state( npc, enemy )
  if hit_timeout[ npc:id() ] and hit_timeout[ npc:id() ] > time_global() then
    return
  elseif hit_timeout[ npc:id() ] then
    hit_timeout[ npc:id() ] = nil
  end

  local emerg
  local anim = db.storage[ npc:id() ].state_mgr.animstate:state()
  if not_ready_states[ anim ] then
    emerg = { animation = true, animation_nout = true }
  end

  local state_name
  if in_hideout( npc ) then
    local hide_val = last_hideout[ npc:id() ].value
    if hide_val <= 0.45 then
      state_name = "hide_na"
    else
      state_name = "threat"
    end
  elseif in_transit( npc ) then
    state_name = "assault"
  else
    state_name = "threat"
  end

  if state_name then
    state_mgr.set_state(
      npc, state_name, nil, nil, { look_object = enemy }, emerg
    )
  end
end


function add_deviation( npc, position, weapon, distance, enemy )
  local npc_rank   = get_obj_rank_name( npc )
  local npc_comm   = npc:character_community()
  local deviations = deviation_table[ npc_rank ]
  local dev_coeff  = community_deviation_coeff[ npc_comm ]
    or community_deviation_coeff.stalker
  local max = 0
  if deviations then
    max = deviations * dev_coeff
    if enemy:is_actor() then
      local k = 1
      if k > 0 then
        max = max * k
      else
        max = 0
      end
    end
    if max > 0 then
      position.x = position.x + ( max * 2 * math.random() - max )
      position.y = position.y + ( max * 2 * math.random() - max )
      position.z = position.z + ( max * 2 * math.random() - max )
    end
  end
  return position
end


function set_escape_sight( npc, vertex )
  if hit_timeout[ npc:id() ] and hit_timeout[ npc:id() ] > time_global() then
    return
  elseif hit_timeout[ npc:id() ] then
    hit_timeout[ npc:id() ] = nil
  end
  local vertex_pos = level.vertex_position( vertex )
  vertex_pos.y = vertex_pos.y + 1.5
  npc:set_desired_direction()
  npc:set_sight( look.point, vertex_pos )
end


function set_combat_sight( npc, enemy, weapon )
  if hit_timeout[ npc:id() ] and hit_timeout[ npc:id() ] > time_global() then
    return
  elseif hit_timeout[ npc:id() ] then
    hit_timeout[ npc:id() ] = nil
  end
  if not weapon then return end

  local enemy_pos = enemy:position()
  local npc_pos   = npc:position()
  local direction = npc_pos:sub( enemy_pos )
  local distance  = npc_pos:distance_to( enemy_pos )

  local binder    = npc:binded_object()
  local st_name   = "xrs_battle_ai.set_combat_sight"
  local st        = binder[ st_name ]
  if not st then
    st = {}
    binder[ st_name ] = st
  end

  local bone, use_deviation
  if
    st.bone
    and st.enemy_id == enemy:id() and st.weapon_id == weapon:id()
    and st.time > time_global()
  then
    bone = st.bone
  else
    if enemy:is_actor() or enemy:is_stalker() then
      use_deviation = not IsSniperRifle( weapon )
      local rank = get_obj_rank_name( npc )
      if math.random() < headshot_prob[ rank ] then
        local bones = { "bip01_head", "bip01_neck" }
        bone = bones[ math.random( table.getn( bones ) ) ]
      end
    elseif is_armor( enemy ) then
      use_deviation = true
      if string.find( enemy:name(), "btr" ) then
        bone = "seat_left"
      else
        bone = "pilot1"
      end
    else
      use_deviation = false
--[=[ --Для монстров кости не используем
      if distance < 10 then
        bone = "bip01_spine"
      else
        if IsSniperRifle( weapon ) then
          bone = get_string(enemy:section(), "bone_head", "bip01_head")
        elseif enemy:section() == "spider" then
          -- у пауков нет кости bip01_neck
          local bones = { get_string(enemy:section(), "bone_head", "bip01_head"), "bip01_spine" }
          bone = bones[ math.random( table.getn( bones ) ) ]
        else
          local bones = { get_string(enemy:section(), "bone_head", "bip01_head"), "bip01_neck", "bip01_spine" }
          bone = bones[ math.random( table.getn( bones ) ) ]
        end
      end
--]=]
    end
    st.bone      = bone
    st.enemy_id  = enemy:id()
    st.time      = time_global() + 10000
    st.weapon_id = weapon:id()
  end
  st.use_deviation = use_deviation

  local look_pos
  if bone then
    look_pos = enemy:bone_position( bone )
  end

  st.look_pos = look_pos
  npc:set_desired_direction()
  if look_pos then
    npc:set_sight( look.fire_point, look_pos )
  else
    npc:set_sight( enemy, true, true )
  end
end


function check_vertex_locked( npc, vertex )
  if locked_vertexes[ 0 ] and locked_vertexes[ 0 ] == vertex then
    return true
  end
  local vertex_pos = level.vertex_position( vertex )
  for k, v in pairs( locked_vertexes ) do
    local loced_vtx_pos = level.vertex_position( v )
    if
      ( v == vertex or vertex_pos:distance_to( loced_vtx_pos) < 4 )
      and k ~= npc:id()
    then
      local checking_npc = level.object_by_id( k )
      if
        checking_npc and checking_npc:alive()
        and not xr_wounded.is_wounded( checking_npc )
      then
        if
          npc:relation( checking_npc ) ~= game_object.enemy
          and checking_npc:relation( npc ) ~= game_object.enemy
        then
          return true
        end
      end
    end
  end
  return false
end


-- список режимов:
-- mode = 0 - оборона (удержание позиции)
-- mode = 1 - атака
-- mode = 2 - отступление
function find_cover( npc, enemy, mode )
  -- возвращает лучшую точку прикрытия от врага в заданном радиусе от
  -- своей позиции и на нужном расстояниии от врага
  -- cover_point* best_cover(vector self_position, vector enemy_position, float radius, float min_enemy_distance, float max_enemy_distance)
  --
  -- возвращает лучшую точку прикрытия в заданном радиусе от своей
  -- позиции и не ближе min_distance. Прикрытость учитывается со всех
  -- направлений.
  -- cover_point* safe_cover(const vector& self_position, float radius, float min_distance)
  --
  -- C++ class cover_point {
  --   function level_vertex_id() const;
  --   function position() const;
  -- };

  if
    last_time_send[ npc:id() ] and last_time_send[ npc:id() ] > time_global()
  then
    return 0
  end
  if not ( npc and enemy ) then return end

  local npc_pos   = npc:position()
  local enemy_pos = enemy:position()
  local to_enemy  = npc_pos:distance_to( enemy_pos )

  local cover
  local min_dist = close_combat_distance
  if mode == 1 then           -- атака
    local max, min, radius
    if to_enemy > min_dist then
      max    = to_enemy
      min    = math.max(
        math.min( to_enemy * 0.7, to_enemy - min_dist ),
        min_dist
      )
      radius = ( max - min ) * 2
    else
      max    = to_enemy * 1.25
      min    = to_enemy * 0.75
      radius = to_enemy * 2
    end
    cover = npc:best_cover( npc_pos, enemy_pos, radius, min, max )

  elseif mode == 2 then       -- отступление
    local min    = math.max( to_enemy, min_dist )
    local max    = math.max( min * 1.5, min + min_dist )
    local radius = max - to_enemy
    cover = npc:best_cover( npc_pos, enemy_pos, radius, min, max )

  elseif mode == 3 then
    cover = npc:ambush_cover( npc_pos, enemy_pos, 10, 10 )
    if not cover then
      cover = npc:ambush_cover( npc_pos, enemy_pos, 30, 10 )
    end

  elseif mode == 0 then       -- оборона
    cover = npc:safe_cover( npc_pos, 20, 0 )
  end

  if not cover then return end
  local cover_vertex  = cover:level_vertex_id()
  if
    mode == 1
    and (
      check_vertex_locked( npc, cover_vertex )
      or its_a_trap( npc, cover_vertex )
    )
  then
    return
  end
  local cover_value   = level.cover_in_direction(
    cover_vertex, enemy_pos:sub( cover:position() )
  )
  local dist_to_cover = cover:position():distance_to( npc_pos )
  local move_speed    = 1.8
  local move_time     = dist_to_cover / move_speed
  last_time_send[ npc:id()   ] = time_global() + move_time + time_to_hide
  last_sent_vertex[ npc:id() ] = cover_vertex
  last_hideout[ npc:id()     ] = {
    value = cover_value,
    vtx   = cover_vertex,
  }
  locked_vertexes[ npc:id() ] = cover_vertex
  return cover_vertex
end


function enemy_covered_value( npc, enemy )
  if not is_armor( enemy ) then
    local enemy_pos    = enemy:bone_position( get_string(enemy:section(), "bone_head", "bip01_head") )
    local npc_pos      = npc:bone_position( get_string(npc:section(), "bone_head", "bip01_head") )
    local enemy_vertex = enemy:level_vertex_id()
    local cover_enemy_value = level.cover_in_direction(
      enemy_vertex, npc_pos:sub( enemy:position() )
    )
    -- прикрытость точки по направлению с непися на врага
    return cover_enemy_value
  else
    if string.find( enemy:name(), "btr" ) then
      local enemy_pos    = enemy:bone_position( "seat_left" )
      local npc_pos      = npc:bone_position( "bip01_spine" )
      local enemy_vertex = enemy:level_vertex_id()
      local cover_enemy_value = level.cover_in_direction(
        enemy_vertex, npc_pos:sub( enemy:position() )
      )
      -- прикрытость точки по направлению с непися на врага
      return cover_enemy_value
    else
      local enemy_pos    = enemy:bone_position( "pilot1" )
      local npc_pos      = npc:bone_position( "bip01_spine" )
      local enemy_vertex = enemy:level_vertex_id()
      local cover_enemy_value = level.cover_in_direction(
        enemy_vertex, npc_pos:sub( enemy:position() )
      )
      -- прикрытость точки по направлению с непися на врага
      return cover_enemy_value
    end
  end
end


function is_safe_to_block_movement( npc, enemy )
  if not enemy then return true end
  if
    npc:position():distance_to( enemy:position() ) > distant_combat_distance
    and not enemy:see( npc )
  then
    return true
  end
  return false
end


function find_vertex_around( npc, around_vertex, dir, rotate_min, rotate_max, offset_min, offset_max, sign )
  if not sign then sign = 1 end
  local ai_step     = 0.7 -- шаг AI сетки
  local math_pi_180 = 180 / math.pi

  local random_rotate    = math.random( rotate_min, rotate_max )
  local cur_dir          = vector_rotate_y( dir, random_rotate * sign )
  local random_offset    = math.random( offset_min, offset_max )
  local rotate_angle     = math.asin( ai_step / random_offset )
  local rotate_angle_deg = rotate_angle * math_pi_180 * sign
  local cur_angle        = 0
  local vertex_id
  while not vertex_id do
    -- проверяем точку слева
    vertex_id = level.vertex_in_direction(
      around_vertex, cur_dir, random_offset
    )
    if
      vertex_id == around_vertex
      or ( not npc:accessible( vertex_id ) )
      or check_vertex_locked( npc, vertex_id )
    then
      vertex_id = nil
      -- поворачиваем направление поиска
      cur_angle = cur_angle + rotate_angle
      if rotate_min + cur_angle * math_pi_180 > rotate_max then
        break
      else
        cur_dir = vector_rotate_y( cur_dir, rotate_angle_deg )
      end
    else
      break
    end
  end
  return vertex_id
end


-- если не указан target, то от себя
-- если указан target, то от target
-- если указан флаг, то нельзя вернуть nil, обязательно нормальное значение
function select_position( npc, target, flag )
  if
    last_time_send[ npc:id() ] and last_time_send[ npc:id() ] > time_global()
  then
    if flag then
      return npc:level_vertex_id()
    else
      return 0
    end
  end

  locked_vertexes[ npc:id() ] = nil
  last_hideout[ npc:id()    ] = nil
  local around_object = npc
  if target then
    around_object = target
    set_sound_event( npc, "hero" )
  end

  local bw = get_best_weapon( npc )

  local max_wpn_range     = get_max_weapon_range( npc, bw )
  local random_offset_min = math.min(
    distant_combat_distance, max_wpn_range / 2
  )
  local random_offset_max = max_wpn_range
  local random_rotate_min =  45
  local random_rotate_max = 120

  local around_dir    = around_object:direction()
  local around_vertex = around_object:level_vertex_id()
  if target then
    local last_vtx = get_last_enemy_lertex( npc )
    local pos      = target:position()
    if math.random() > 0.7 and last_vtx then
      around_vertex = last_vtx
      pos = level.vertex_position( around_vertex )
    end
    local pos_npc = npc:position()
    if pos.y > pos_npc.y then
      local height = pos.y - pos_npc.y
      if target:id() == db.actor:id() and height >= 3 then
        random_rotate_min =  90
        random_rotate_max = 150
      end
    end
    if not target:alive() then
      random_offset_min = 5
      random_offset_max = 7
    end
  else
    local enemy = get_target( npc )
    if enemy and IsMonster( enemy ) and enemy:alive() then
      local dist = npc:position():distance_to( enemy:position() )
      if dist < random_offset_min then
        random_rotate_min =  90
        random_rotate_max = 180
      end
    end
  end

  local node_1_vertex_id = find_vertex_around(
    npc, around_vertex, around_dir,
    random_rotate_min, random_rotate_max,
    random_offset_min, random_offset_max
  )
  local node_2_vertex_id = find_vertex_around(
    npc, around_vertex, around_dir,
    random_rotate_min, random_rotate_max,
    random_offset_min, random_offset_max, -1
  )

  -- Проверяем растояния до точек
  local node_1_distance = -1
  if node_1_vertex_id then
    node_1_distance = npc:position()
      :distance_to( level.vertex_position( node_1_vertex_id ) )
  end

  local node_2_distance = -1
  if node_2_vertex_id then
    node_2_distance = npc:position()
      :distance_to( level.vertex_position( node_2_vertex_id ) )
  end

  -- Выбираем ближайшую из существующих
  if node_1_distance == -1 and node_2_distance == -1 then
    -- Не смогли найти точку, ругаться
    -- return around_object:level_vertex_id()
    if flag then
      return npc:level_vertex_id()
    else
      return nil
    end
  end

  local move_speed = 2
  if node_1_distance == -1 then
    local move_time = node_2_distance / move_speed
    last_time_send[ npc:id()   ] = time_global() + move_time + time_to_maneuver
    last_sent_vertex[ npc:id() ] = node_2_vertex_id
    locked_vertexes[ npc:id()  ] = node_2_vertex_id
    return node_2_vertex_id
  end

  if node_2_distance == -1 then
    local move_time = node_1_distance / move_speed
    last_time_send[ npc:id()   ] = time_global() + move_time + time_to_maneuver
    last_sent_vertex[ npc:id() ] = node_1_vertex_id
    locked_vertexes[ npc:id()  ] = node_1_vertex_id
    return node_1_vertex_id
  end

  if
    node_1_distance > 0 and node_1_distance < 50
    and node_2_distance > 0 and node_2_distance < 50
  then
    local choose_table = { node_1_vertex_id, node_2_vertex_id }
    local dist_table   = { node_1_distance,  node_2_distance  }
    if
      ( not maneuver_strategy[ npc:id() ] )
      or maneuver_strategy[ npc:id() ].time_to_change < time_global()
    then
      local choosed_path = math.random( table.getn( choose_table ) )
      maneuver_strategy[ npc:id() ] = {
        time_to_change = time_global() + time_mantain_manuever,
        value          = choosed_path,
      }
      local move_time    = dist_table[ choosed_path ] / move_speed
      last_time_send[ npc:id()   ] = time_global() + move_time + time_to_maneuver
      last_sent_vertex[ npc:id() ] = choose_table[ choosed_path ]
      locked_vertexes[ npc:id()  ] = choose_table[ choosed_path ]
      return choose_table[ choosed_path ]
    else
      local choosed_path = maneuver_strategy[ npc:id() ].value
      local move_time    = dist_table[ choosed_path ] / move_speed
      last_time_send[ npc:id()   ] = time_global() + move_time + time_to_maneuver
      last_sent_vertex[ npc:id() ] = choose_table[ choosed_path ]
      locked_vertexes[ npc:id()  ] = choose_table[ choosed_path ]
      return choose_table[ choosed_path ]
    end
  end

  if node_1_distance < node_2_distance then
    local move_time = node_1_distance / move_speed
    last_time_send[ npc:id()   ] = time_global() + move_time + time_to_maneuver
    last_sent_vertex[ npc:id() ] = node_1_vertex_id
    locked_vertexes[ npc:id()  ] = node_1_vertex_id
    return node_1_vertex_id
  else
    local move_time = node_2_distance / move_speed
    last_time_send[ npc:id()   ] = time_global() + move_time + time_to_maneuver
    last_sent_vertex[ npc:id() ] = node_2_vertex_id
    locked_vertexes[ npc:id()  ] = node_2_vertex_id
    return node_2_vertex_id
  end
end


function find_vertex_in_radius( npc, around_vertex, radius )
  local dist = math.random( 0, radius )
  if dist == 0 then
    if
      npc:accessible( around_vertex )
      and not check_vertex_locked( npc, around_vertex )
    then
      return around_vertex
    else
      return
    end
  end
  local around_pos = level.vertex_position( around_vertex )
  local new_dir    = vector():set(
    math.random( -1000, 1000 ) / 1000, 0, math.random( -1000, 1000 ) / 1000
  )
  new_dir:normalize()
  local ai_step     = 0.7 -- шаг AI сетки
  local math_pi_180 = 180 / math.pi
  local pi2         = math.pi * 2
  while dist >= ai_step do
    -- итератор вращения направления
    local rotate_angle = math.asin( ai_step / dist )
    local cur_angle, cur_dir = 0, new_dir
    while math.abs( cur_angle ) < pi2 do
      -- ищем вертекс
      -- нужная нам позиция
      local pos     = vector():mad( around_pos, cur_dir, dist )
      local vert_ok = level.vertex_id( pos )
      if
        level.valid_vertex_id( vert_ok )
        and npc:accessible( vert_ok )
        and not check_vertex_locked( npc, vert_ok )
      then
        return vert_ok
      end
      -- поворачиваем направление поиска
      cur_angle = cur_angle + rotate_angle
      cur_dir   = vector_rotate_y( cur_dir, rotate_angle * math_pi_180 )
    end
    dist = dist - ai_step
  end
end


function select_last_known_enemy_pos( npc )
  if
    last_time_send[ npc:id() ]
    and last_time_send[ npc:id() ] > time_global()
  then
    return 0
  end

  locked_vertexes[ npc:id() ] = nil
  last_hideout[ npc:id()    ] = nil

  local known_enemy_vtx = get_last_enemy_lertex( npc )
  if not known_enemy_vtx then return nil end
  local last_vtx = find_vertex_in_radius(
    npc, known_enemy_vtx, distant_combat_distance
  )

  if not last_vtx then
    return nil
  else
    local dist_to_point = npc:position()
      :distance_to( level.vertex_position( last_vtx ) )
    local move_speed    = 2
    local move_time     = dist_to_point / move_speed
    last_time_send[ npc:id()   ] = time_global() + move_time + time_to_maneuver
    last_sent_vertex[ npc:id() ] = last_vtx
    locked_vertexes[ npc:id()  ] = last_vtx
    return last_vtx
  end
end


function select_enemy_pos( npc, enemy )
  if
    last_time_send[ npc:id() ]
    and last_time_send[ npc:id() ] > time_global()
  then
    return 0
  end

  locked_vertexes[ npc:id() ] = nil
  last_hideout[ npc:id()    ] = nil

  local known_enemy_vtx = enemy:level_vertex_id()
  if not known_enemy_vtx then return nil end
  local last_vtx = find_vertex_in_radius(
    npc, known_enemy_vtx, distant_combat_distance
  )

  if not last_vtx then
    return nil
  else
    local dist_to_point = npc:position()
      :distance_to( level.vertex_position( last_vtx ) )
    local move_speed    = 2
    local move_time     = dist_to_point / move_speed
    last_time_send[ npc:id()   ] = time_global() + move_time + time_to_maneuver
    last_sent_vertex[ npc:id() ] = last_vtx
    locked_vertexes[ npc:id()  ] = last_vtx
    return last_vtx
  end
end


function select_enemy_pos_fanatic( npc, enemy )
  if
    last_time_send[ npc:id() ]
    and last_time_send[ npc:id() ] > time_global()
  then
    return last_sent_vertex[ npc:id() ]
  end

  locked_vertexes[ npc:id() ] = nil
  last_hideout[ npc:id()    ] = nil

  local move_speed = 2
  local known_enemy_vtx = enemy:level_vertex_id()
  if not known_enemy_vtx then known_enemy_vtx = randomize_position( npc ) end
  local dist_to_point   = npc:position()
    :distance_to( level.vertex_position( known_enemy_vtx ) )
  local move_time       = ( dist_to_point / move_speed ) * 0.5
  last_time_send[ npc:id()   ] = time_global() + move_time
  last_sent_vertex[ npc:id() ] = known_enemy_vtx
  locked_vertexes[ npc:id()  ] = known_enemy_vtx
  return known_enemy_vtx
end


function randomize_position( npc )
  if
    last_time_send[ npc:id() ]
    and last_time_send[ npc:id() ] > time_global()
  then
    return last_sent_vertex[ npc:id() ]
  end

  locked_vertexes[ npc:id() ] = nil
  last_hideout[ npc:id()    ] = nil

  local last_vtx = find_vertex_in_radius( npc, npc:level_vertex_id(), 50 )
  if not last_vtx then
    return nil
  else
    local dist_to_point = npc:position()
      :distance_to( level.vertex_position( last_vtx ) )
    local move_speed    = 2
    local move_time     = dist_to_point / move_speed
    last_time_send[ npc:id()   ] = time_global() + move_time + time_to_hide
    last_sent_vertex[ npc:id() ] = last_vtx
    locked_vertexes[ npc:id()  ] = last_vtx
    return last_vtx
  end
end


function check_for_grenades( npc )
  local best_danger = npc:best_danger()
  if best_danger then
    local bd_type = best_danger:type()
    if bd_type == danger_object.grenade then
      if not active_grenades[ npc:id() ] then
        if npc:character_community() ~= "zombied" then
          local best_danger_object = best_danger:dependent_object()
          if
            best_danger_object
            and ( not grenka_already_blow[ best_danger_object:id() ] )
            and npc:position():distance_to( best_danger_object:position() ) < distant_combat_distance
          then
            local id = best_danger_object:id()
            active_grenades[ npc:id() ] = {
              grenade = id,
              parent  = best_danger:object():id(),
              timeout = time_global()+inertion_time_grenade,
            }
            if
              ogse.get_npc_relation( npc, best_danger:object() ) == "enemy"
            then
              enable_object( npc, best_danger:object() )
              process_enemy( npc, best_danger:object() )
              -- npc:make_object_visible_somewhen(best_danger:object())
              xr_sound.set_sound( npc, "beware_grenade" )
            end
          end
        end
      end
    end
  end
  if active_grenades[ npc:id() ] then
    local check = active_grenades[ npc:id() ]
    if check.timeout < time_global() then
      active_grenades[ npc:id() ] = nil
      grenka_already_blow[ check.grenade ] = true
      escape_point[ npc:id()    ] = nil
    end
  end
end


function evade_grenades( npc )
  local danger     = active_grenades[ npc:id() ]
  local id         = danger.grenade
  local danger_obj = level.object_by_id( id )

  if danger_obj and not grenka_already_blow[ danger.grenade ] then
    if danger.timeout - time_global() > inertion_time_grenade * 0.9 then
      return
    end

    if not grenka_already_shout[ id ] then
      grenka_already_shout[ id ] = npc:id()
      talking_about_grenka[ npc:id() ] = time_global()
      xr_sound.set_sound( npc, "beware_grenade" )
    end

    if not escape_point[ npc:id() ] then
      last_hideout[ npc:id()    ] = nil
      locked_vertexes[ npc:id() ] = nil
      local parent      = level.object_by_id( danger.parent )
      local distance    = npc:position():distance_to( parent:position() )
      local danger_vert = level.vertex_in_direction(
        parent:level_vertex_id(), parent:direction(), distance
      )
      local cover       = npc:best_cover(
        npc:position(), level.vertex_position( danger_vert ), 15, 5, 30
      )
      local best_dist, best_dir = 0, vector():set( 0, 0, 0 )
      local dir   = npc:position():sub( danger_obj:position() ):normalize()
      local dvert = npc:level_vertex_id()
      if cover then
        dvert = cover
      else
        for a = -120, 120, 10 do
          local ndir = vector_rotate_y( dir, a )
          local vert = level.vertex_in_direction(
            npc:level_vertex_id(), ndir, 50
          )
          local ndist = level.vertex_position( vert ):
            distance_to( danger_obj:position() )
          if ndist > best_dist and npc:accessible( vert ) then
            best_dist = ndist
            dvert     = vert
          end
        end
      end
      escape_point[ npc:id() ] = dvert
    end

    xr_sound.set_sound( npc, nil )
    npc:set_sight(
      look.direction, level.vertex_position( escape_point[ npc:id() ] )
    )
    state_mgr.set_state( npc, "sprint_p" )
    npc:set_dest_level_vertex_id( escape_point[ npc:id() ] )

  else
    npc:set_mental_state( anim.danger )
    grenka_already_blow[ active_grenades[ npc:id() ].grenade ] = true
    active_grenades[ npc:id() ] = nil
    escape_point[ npc:id()    ] = nil
    xr_sound.set_sound( npc, nil )
  end
end


function correct_position( gi, npc )
  if IsStalker( gi ) or IsMonster( gi ) then
    -- Вычисляем вектор разницы между координатами кости и level
    -- vertex. Пытаемся найти level vertex наиболее близкий к кости
    local diff  = gi:bone_position( get_string(gi:section(), "bone_head", "bip01_head") )
      :sub( level.vertex_position( gi:level_vertex_id() ) )
    local len   = diff:magnitude()
    local diffp = vector():set( diff.z, 0, -diff.x ):mul( 0.5 )
    -- Сдвигаем целевую точку вбок, чтобы непись не залазил ногами в труп
    diff:add( diffp )
    return npc:vertex_in_direction( gi:level_vertex_id(), diff, len )
  else
    return gi:level_vertex_id()
  end
end


function is_exclusion( npc )
  --local name    = npc:name()
  --local profile = npc:profile_name()
  --if
  --  string.find( name, "prisoner" ) or string.find( profile, "prisoner" )
  --  or string.find( name, "captive" ) or string.find( profile, "captive" )
  --  or string.find( name, "esc_shustryi" )
  --then
  --  return true
  --else
    return false
  --end
end


function is_camper( npc )
  if campers[ npc:id() ] then
    return true
  else
    return false
  end
end


function is_fanatic( npc )
  if monolith[ npc:id() ] then
    return true
  else
    return false
  end
end


evid_altcombat  = 18720
actid_altcombat = evid_altcombat + 1

function add_to_binder( object, ini, scheme, section, storage )
  local operators  = {
    [ "gogogo" ] = actid_altcombat,
  }
  local properties = {
    [ "alt_combat_enabled" ] = evid_altcombat,
  }

  local manager = object:motivation_action_manager()
  local property_wounded         = xr_evaluators_id.sidor_wounded_base
  local state_mgr_to_idle_combat = xr_actions_id.state_mgr + 1
  local state_mgr_to_idle_alife  = xr_actions_id.state_mgr + 2

  local lname = level.name()
  local comm  = object:character_community()
  local forbidden_by_comm = community_forbidden_locations[ comm ]
  local gulag = xr_gulag.get_npc_gulag(object)

  if
    ( not object:alive() )
    or forbidden_comms[ comm ]
    or ( forbidden_by_comm and forbidden_by_comm[ lname ] )
    or forbidden_by_lname[ lname ]
    or forbidden_profiles[ object:name() ]
    or forbidden_profiles[ object:profile_name() ]
    or (
      comm == "monolith"
      and string.find( object:name(), "pri_" )
      and (
        string.find( object:name(), "sniper" )
        or string.find( object:name(), "roof" )
      )
    )
	or ( gulag and forbidden_gulags[ gulag.name ] )
  then
    manager:add_evaluator(
      properties.alt_combat_enabled, property_evaluator_const( false )
    )
    return
  end

  manager:add_evaluator(
    properties.alt_combat_enabled,
    evaluator_check_altcombat( "alt_combat_enabled", storage )
  )

  local action = action_altcombat( object, "gogogo", storage )
  action:add_precondition( world_property( stalker_ids.property_alive, true ) )
  action:add_precondition(
    world_property( xr_evaluators_id.sidor_wounded_base, false )
  )
  
  if xrs_ai then xrs_ai.addCommonPrecondition( action ) end --KRodin: если возникнут проблемы, это убрать и раскомментировать блок ниже
  --if xrs_grenade then
  --  action:add_precondition( world_property( xrs_grenade.prop_fire, false  ) )
  --  action:add_precondition( world_property( xrs_grenade.prop_grenade, false  ) )
  --end

  if rx_bandage and rx_bandage.enable_scheme then
    action:add_precondition( world_property( rx_bandage.evid_bandage, false ) )
  end	
  if rx_facer then
    action:add_precondition( world_property( rx_facer.evid_facer, false ) )
    action:add_precondition(
      world_property( rx_facer.evid_steal_up_facer, false )
    )
  end
  if rx_gl then
    action:add_precondition( world_property( rx_gl.evid_gl_fire,   false ) )
    action:add_precondition( world_property( rx_gl.evid_gl_reload, false ) )
  end

  if ogsm_hideout then
    action:add_precondition( world_property( ogsm_hideout.property_blowout, false ) )
    action:add_precondition( world_property( ogsm_hideout.property_hideout_lost, false ) )
  end
  
  action:add_precondition(
    world_property( properties.alt_combat_enabled, true )
  )
  action:add_effect( world_property( properties.alt_combat_enabled, false ) )
  action:add_effect( world_property( stalker_ids.property_enemy, false ) )
  manager:add_action( operators.gogogo, action )

  action = manager:action( stalker_ids.action_combat_planner )
  action:add_precondition(
    world_property( properties.alt_combat_enabled, false )
  )

  action = manager:action( stalker_ids.action_alife_planner )
  action:add_precondition(
    world_property( properties.alt_combat_enabled, false )
  )

  action = manager:action( state_mgr_to_idle_alife )
  action:add_precondition(
    world_property( properties.alt_combat_enabled, false )
  )

  action = manager:action( state_mgr_to_idle_combat )
  action:add_precondition(
    world_property( properties.alt_combat_enabled, false )
  )
end


function enable_scheme( npc, ini, scheme, section )
  local st = xr_logic.assign_storage_and_bind( npc, ini, scheme, section )
end


function disable_scheme( npc, scheme )
  local st = db.storage[ npc:id() ][ scheme ]
  if st then
    st.enabled = false
  end
end
