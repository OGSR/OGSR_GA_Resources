
-----------------------------------------------------------------------
--- ogse.script
--- Утилитарная база OGSE 0.6.9.3
--- 2007-2008 (c) xStream, DEXXX
--- 2009-2013 (c) OGS Evolution Team
-----------------------------------------------------------------------

function attach(sm)
	sm:subscribe({signal = "on_storyline_start", fun = this.on_storyline_start})
	sm:subscribe({signal = "on_update",			fun = this.show_time})
	sm:subscribe({signal = "on_take",			fun = this.on_item_take})
	sm:subscribe({signal = "after_time_change",	fun = this.after_time_change})
	sm:subscribe({signal = "on_spawn",          fun = this.on_spawn})
end

game_time_factor = get_float("alife", "time_factor")

art_levels = {
["af_medusa"] = 1,
["af_vyvert"] = 1,
["af_blood"] = 1,
["af_ameba_slime"] = 1,
["af_gravi"] = 2,
["af_drops"] = 2,
["af_electra_sparkler"] = 2,
["af_ameba_slug"] = 2,
["af_rusty_thorn"] = 2,
["af_mincer_meat"] = 2,
["af_cristall_flower"] = 2,
["af_fireball"] = 3,
["af_electra_flash"] = 3,
["af_rusty_kristall"] = 3,
["af_kaktus"] = 3,
["af_gold_fish"] = 4,
["af_cristall"] = 4,
["af_dummy_spring"] = 4,
["af_dummy_dummy"] = 4,
["af_dummy_pellicle"] = 4,
["af_night_star"] = 5,
["af_soul"] = 5,
["af_electra_moonlight"] = 5,
["af_ameba_mica"] = 5,
["af_rusty_sea-urchin"] = 5,
["af_dummy_battery"] = 5,
["af_dummy_glassbeads"] = 5,
["af_fuzz_kolobok"] = 5
}

local loc_levels = {
["l01_escape"] = 1,
["l02_garbage"] = 2,
["l03_agroprom"] = 3,
["l03u_agr_underground"] = 3,
["l04_darkvalley"] = 3,
["l04u_labx18"] = 4,
["l05_bar"] = 3,
["l06_rostok"] = 4,
["l07_military"] = 4,
["l08_yantar"] = 4,
["l08u_brainlab"] = 5,
["l10_radar"] = 5,
["l10u_bunker"] = 5,
["l11_pripyat"] = 5,
["l12_stancia"] = 5,
["l12_stancia_2"] = 5,
["l12u_sarcofag"] = 5,
["l12u_control_monolith"] = 5,
["l09_deadcity_ogse"] = 5,
["l13_generators_ogse"] = 5,
["l22_marsh"] = 5
}

-- Переменные для типсов
tips_variable = {
	["pda_news"] = ([[device\pda\pda_news]]),
	["pda_tips"] = ([[device\pda\pda_tip]]),
	["pda_task"] = ([[device\pda\pda_objective]]),
	["pda_sos"] = ([[device\pda\pda_sos]]),
}
tips_icons = {
	default  = { 82, 282},
	trader   = { 332, 893},
	dolg     = { 0, 658},
	freedom  = { 0, 658},
	ecolog   = { 498, 0},
	arena    = { 332, 141},
	stalker  = { 0, 658},
	krot     = { 332, 47},
	barman   = { 332, 235},
	wolf	   = { 332, 940},
	o_soznanie = { 498, 893},
	monolith = { 0, 658},
	saharov  = { 332, 470},
	prizrak  = { 0, 658},
	killer   = { 0, 658},
	death    = { 0, 752},
	gen_info	= { 0, 658},
	trade 	= { 0, 0},
	uniq	= { 498, 47}
}


function kill_living_npc(npc_id)
   local s_npc = alife():object(npc_id)
   s_npc.force_offline = true
   go_offline_kill_timer(npc_id):start()
end
-- служебный таймер, ждущий ухода в оффлайн
class "go_offline_kill_timer" (ogse_qt.quick_timer)
function go_offline_kill_timer:__init(npc_id) super()
   self.npc_id = npc_id -- запоминаем в таймере id непися
end
function go_offline_kill_timer:condition()
   return (not level.object_by_id(self.npc_id)) -- ждём исчезновения клиентского объекта
end
function go_offline_kill_timer:action()
   local sobj = alife():object(self.npc_id)
   if sobj then
      alife():release(sobj, true)
   --else
      --send_tip("Something wrong!") -- такое возможно при удалении объекта
   end
end

--- Перезапуск логики NPC
function reset_npc_logic(obj)
	if obj then
		local npc_id = obj:id()
		db.storage[npc_id].overrides = nil
		xr_logic.reset_generic_schemes_on_scheme_switch(obj, "nil", "nil")
		db.storage[npc_id].active_section = nil
		db.storage[npc_id].active_scheme = nil
	end
end

-- Проверка уровня артефакта по имени левела
function art_accesible(item)
	local section = item:section()
	local level_name = level.name()
	local art_level = art_levels[section]
	local loc_level = loc_levels[level_name]
	if art_level and loc_level then
		return art_level <= loc_level
	else
		return true
	end
	return false
end

-- Проверка нахождения актора в особой зоне
function actor_in_zone(pos_psy_x,pos_psy_y,size_psy_x,size_psy_y,z1,z2)
	local pos = db.actor:position()
	local x1, x2, y1, y2 = pos_psy_x, pos_psy_y, size_psy_x, size_psy_y

	return ( (pos.x >= x1 and pos.x <= x2) and (pos.z >= y1 and pos.z <= y2) and (pos.y >= z1) and (pos.y <= z2) ) and 1 or 0
end

-- Проверка нахождения НПС в особой зоне
function npc_in_zone(obj,lev,pos_psy_x,pos_psy_y,size_psy_x,size_psy_y,z1,z2)
local level_name = level.name()
if level_name ~= lev then
	return false
end
local pos = obj:position()
local x1 = pos_psy_x
local x2 = pos_psy_y
local y1 = size_psy_x
local y2 = size_psy_y
return (pos.x >= x1 and pos.x <= x2) and (pos.z >= y1 and pos.z <= y2) and (pos.y >= z1) and (pos.y <= z2)
end

local quest_profiles = {
	["military_trader"] 		= true,
	["bandit_trader"] 			= true,
	["monolit_trader"] 			= true,
	["merc_trader"] 			= true,
	["pri_trader_profile"]	 	= true,
	["agr_dolg_glavnyi"] 		= true,
	["agr_dolg_sniper"] 		= true,
	["agr_ratcatcher"]			= true,
	["ecolog_v_tainike"] 		= true,
	["ecolog_v_doline"] 		= true,
	["neytral_drug_seregi"]		= true,
	["neytral_serega_manyak"] 	= true,
	["yan_svoboda_informator"] 	= true,
	["mil_dolg_recon"] 			= true,
	["mil_svoboda_wounded"] 	= true,
	["mil_dolg_killer_commander"] = true,
	["mil_dolg_killer_1"] 		= true,
	["mil_dolg_killer_2"] 		= true,
	["mil_Svoboda_zombi_stalker"] = true,
	["mil_svoboda_bespredel"] 	= true,
	["esc_anmaly_military_leader"] 	= true,
	["esc_anmaly_military_solder"] 	= true,
	["bar_arena_manager"]	= true,
	["aem_arny"]	= true,
	["aem_admin_1"]	= true,
	["aem_admin_2"]	= true,
	["aem_admin_3"]	= true,
	["aem_admin_4"]	= true,
	["aem_admin_5"]	= true,
	["esc_specotryad_leader"] = true,
	["esc_specotryad_npc"] = true,
	["esc_plennik_on_blockpost"] = true,
	["esc_killer_mined_lager"] = true,
	["val_freedom_enemy"] = true,
	["val_freedom_enemy_commander"] = true,
	["val_friend_of_barman"] = true,
	["val_stalkers_barman"] = true,
	["gar_dolg_on_sdelka"] = true,
	["gar_killers_on_sdelka"] = true,
	["agr_plennik_on_base_mils"] = true,
	["agr_military_plennik"] = true,
	["pri_doch_of_starik"] = true,
	["esc_starik_searcing_doch"] = true,
	["rad_freedomer_on_vetr"] = true,
	["esc_stalker_novice_teterev"] = true,
	["esc_bandit_of_teterev_leader"] = true,
	["esc_bandit_of_teterev"] = true,
	["esc_sniper_qest_on_elevator"] = true,
	["esc_sniper_qest_on_elevator_2"] = true,
	["yan_zombied_chuk"] = true,
	["yan_figa"] = true,
	["x18_death_stalker"] = true,
	["val_kvestx10_svyaznoy"] = true,
	["esc_scoryi"] = true,
	["val_orlov"] = true,
	["val_kvest_sniper"] = true,
	["esc_sitnik"] = true,
	["esc_pechkin"] = true,
	["yan_ecolog_preobr"] = true,
	["val_bandit_uzh"] = true,
	["esc_hitryi"] = true,
	["val_bodryi"] = true,
	["x16_gribnik"] = true,
	["x16_leshyi"] = true,
	["gar_hellcar_group_1"] = true,
	["gar_hellcar_group_2"] = true,
	["gar_seryi_drug2"] = true,
	["gar_seryi_drug3"] = true,
	["esc_blokpost_commander"] = true,
	["sim_stalker_master_diador"] = true,
	["agr_defector_stalker1"] = true,
	["bar_ecolog_professor"] = true,
	["gar_sniper_bandit"] = true,
	["first_neutral"] = true,
	["esc_lekar"] = true,
	["bridge_lekar"] = true,
	["esc_digger"] = true,
	["ds_hunter"] = true,
	["ds_glavar"] = true,
	["ds_telohr_1"] = true,
	["ds_telohr_2"] = true,
	["ds_shesterka"] = true,
	["ds_patruln"] = true,
	["bratstvo_lider"] = true,
	["bratstvo_orujeinik"] = true,
	["bratstvo_vrach"] = true,
	["bratstvo_cleaner"] = true,
	["iskatel_shaman"] = true,
	["iskatel_dusty"] = true,
	["iskatel_yuriy"] = true,
	["iskatel_ahmet"] = true,
	["iskatel_bacha"] = true,
	["ds_nalet_band_1"] = true,
	["ds_nalet_band_2"] = true,
	["ds_nalet_band_3"] = true,
	["ds_nalet_band_4"] = true,
	["ds_nalet_band_5"] = true,
	["ds_nalet_band_6"] = true,
	["ds_nalet_band_7"] = true,
	["ds_nalet_band_8"] = true,
	["garb_novice_arthunter"] = true,
	["bar_kulg_agent"] = true,
	["dolg_palach1"] = true,
	["dolg_palach2"] = true,
	["bar_sergant_jivoderov"] = true,
	["rad_company_mikluha"] = true,
	["rad_company_che"] = true,
	["rad_company_fidel"] = true,
	["rad_company_markiz"] = true,
	["rad_company_graf"] = true,
	["rad_company_zahar"] = true,
	["izgioy_lider"] = true,
	["izgoy_pomoshnik"] = true,
	["izgoy_first_patient"] = true,
	["izgoy_second_patient"] = true,
	["dar_merk_lider"] = true,
	["dar_merk_bomber"] = true,
	["dar_merk_guard_1"] = true,
	["dar_merk_guard_2"] = true,
	["dar_officer"] = true,
	["bar_dr_gorbovsky"] = true,
	["dik_the_drifter"] = true,
	["bratstvo_agent_1"] = true,
	["dar_gaz_dolg_lider"] = true,
	["dar_gaz_dolg1"] = true,
	["dar_gaz_dolg2"] = true,
	["dar_gaz_dolg3"] = true,
	["stalker_tikar"] = true,
	["major_pomoshnik2"] = true,
	["major_wounded"] = true,
	["zona_brother1"] = true,
	["zona_brother2"] = true,
	["yan_soldier"] = true,
	["ros_soldier"] = true,
	["yan_soldier_new"] = true,
	["deadcity_bar_nardyman"] = true,
	["deadcity_bar_barman"] = true,
	["deadcity_master_voice"] = true,
	["bar_guider"] = true,
	["yantar_guider"] = true,
	["pri_guider"] = true,
	["esc_semenov"] = true,
	["stalker_hvost"] = true,
	["stalker_kolya"] = true,
	["uley_robber"] = true,
	["deadcity_bar_billiardman"]	= true,
	["deadcity_bar_restsofa"]	= true,
	["deadcity_bar_sleeper"]	= true,
	["deadcity_bar_zasranets"]	= true,
	["deadcity_bar_drinkman"]	= true,
	["deadcity_bar_guard1"]	= true,
	["deadcity_bar_guard2"]	= true,
	["hohol"]						=	true,
	["esc_buharik"]					=	true,
	["esc_guns_remontnik"]			=	true,
	
	["dar_farm_assistant"]			=	true,
	["kulgband_trader"]			=	true,
	["kulgband_trader_guard1"]			=	true,
	["kulgband_trader_guard2"]			=	true,
	["kulgband_looser"]			=	true,
	["kulgband_driver"]			=	true,
	["kulgband_scout"]			=	true,
	["mil_monolith_man1"]			=	true,
	["mil_monolith_man2"]			=	true,
	["mil_monolith_man3"]			=	true,
	["kulgband_trader2"]			=	true,
	["val_trader_npc"]			=	true,
	["rad_kulgband_assistant"]			=	true,
	["dar_bridge_kulgband_man1"]			=	true,
	["dar_bridge_kulgband_man2"]			=	true,
	["dar_bridge_kulgband_man3"]			=	true,
	["dar_bridge_kulgband_assist1"]			=	true,
	["dar_bridge_kulgband_assist2"]			=	true,
	["kulgband_seif_dead_man"]			=	true,
	["dar_bridge_kulgband_glavar"]			=	true,
	["city_kulgband_glavar"]			=	true,
	["city_kulgband_glavar2"]			=	true,
	["city_kulgband_telohr1"]			=	true,
	["city_kulgband_telohr2"]			=	true,
	["city_kulgband_shesterka"]			=	true,
	["city_kulgband_patruln"]			=	true,
	["city_kulgband_assist1"]			=	true,
	["city_kulgband_assist2"]			=	true,
	["kulgband_bridge_scout"]			=	true,
	["dar_bridge_kulgband_assist4"]			=	true,
	["dar_bridge_kulgband_assist5"]			=	true,
	["dar_bridge_kulgband_assist6"]			=	true,
	["kulgband_hutor_deadman"]			=	true,
	["kulgband_informer_assist3"]			=	true,
	["kulgband_informer"]			=	true,
}

--- Возвращает true если параметром передан квестовый непись
function is_quest_npc(npc)
	if not npc then return false end
	--
	local story
	if npc.m_story_id then
		story = npc.m_story_id
	else
		story = npc:story_id()
	end
	--log3("[OGSE] SID of [%s]: [%s]", npc:name(), story)
	if story == 4294967295 then
		if quest_profiles[npc:profile_name()] or quest_profiles[npc:name()] then
			return true
		end
	end
	--
	return story ~= 4294967295
end

-- телепортация NPC в пределах уровня
-- сама функция только ставит флажок на выпихивание в оффлайн и запускает ждущий таймер
-- вся работа будет сделана в экшине таймера
function teleport_npc(npc_id, pos)
   local s_npc = alife():object(npc_id)
   s_npc.force_offline = true
   go_offline_watch_timer(npc_id, pos):start() -- таймер "выстрелил-забыл"
end
-- служебный таймер, ждущий ухода в оффлайн
class "go_offline_watch_timer" (ogse_qt.quick_timer)
function go_offline_watch_timer:__init(npc_id, pos) super()
   self.npc_id = npc_id -- запоминаем в таймере id непися
   self.pos    = pos -- запоминаем позицию, куда будем перемещать
end
function go_offline_watch_timer:condition()
   return not level.object_by_id(self.npc_id) -- ждём исчезновения клиентского объекта
end
function go_offline_watch_timer:action()
   local s_npc = alife():object(self.npc_id)
   if s_npc then
      s_npc.position = self.pos -- кастуем злое колдунство
      s_npc.force_offline = nil -- отправляем обратно в онлайн
   --else
      --log1("Something wrong!") -- такое возможно при удалении объекта
   end
end

--- Возвращает класс защиты надетой на ГГ брони от выброса. В obj передавать db:actor
--- С неписями НЕ работает! Пользуйте armor_type(npc)
function armor_class(obj)
	if not obj then return end

	local armor = obj:get_current_outfit()
	if not armor then return 5 end

	local armorname = armor:section()
	return (
			   armorname:find("scientific_outfit")
			or armorname:find("ecolog_outfit")
			or armorname:find("protection_outfit")
			or armorname:find("military_outfit")
		) and 1
		or (
			   armorname:find("exo")
			or armorname:find("monolit_exoskeleton")
		) and 2
		or (   armorname:find("outfit_specnaz_m1")
			or armorname:find("specops_outfit")
			or armorname:find("monolit_outfit_m1")
			or armorname:find("svoboda_heavy_outfit")
		) and 3
		or 4
end

--- Возвращает величину урона ударной волной в зависимости от локации
function level_blow_damage()
	local level_name = level.name()

	return
		   ( level_name == "l01_escape" ) and 0.02
		or ( level_name == "l03_agroprom" or level_name == "l02_garbage" or level_name == "l04_darkvalley" ) and 0.04
		or ( level_name == "l05_bar" or level_name == "l06_rostok" ) and 0.06
		or ( level_name == "l07_military" or level_name == "l08_yantar" or level_name == "l11_pripyat" ) and 0.08
		or 0.06
end

local armor_type_npc = { ["novice"] = 4, ["experienced"] = 3, ["veteran"] = 2, ["master"] = 1 }
--- Возвращает класс защиты непися
function armor_type(npc)
	if not npc then return end

	local npc_rank = ranks.get_obj_rank_name(npc)
	if npc_rank then
		return armor_type_npc[npc_rank] or 1
	end
end

-- Показ типса
function send_tip(news_text, header, timeout, showtime, sender, sound)
	if not news_text then return end

	local header = header or game.translate_string("st_tip")
	local timeout = timeout or 0
	local showtime = showtime or 5
	local sender = sender or "default"
	local x = tips_icons[sender][1]
	local y = tips_icons[sender][2]
	local player = xr_sound.get_safe_sound_object( tips_variable[sound] or tips_variable["pda_tips"] )

	player:play(db.actor, timeout, sound_object.s2d) --Играем дефолтный звук

	local news_text = "%c[255,160,160,160]"..header.."\\n".."%c[default]"..news_text
	db.actor:give_game_news(news_text, "ui\\ui_iconsTotal", Frect():set(x,y,83,47), timeout*1000, showtime*1000)

	return true
end

--****************************************ТАЙМЕРЫ - НАЧАЛО.*************************************************
--KRodin: перевёл эти дерьмотаймеры на систему ogse_st_mgr.script
--По-хорошему, надо бы от них избавиться, но тут слишком много работы.
--НИ В КОЕМ СЛУЧАЕ НЕ ПОЛЬЗУЙТЕСЬ ЭТИМИ ТАЙМЕРАМИ В БУДУЩЕМ!
function start_timer(name, delay, action)
	if not delay then return end
	if not action then action = "" end
	--log3("~~Starting timer: [%s_%s]", name, action)

	ogse_st_mgr.delayed_fun_start()
	:set_delay( delay )
	:init( script_name()..".__do_timer_action", name, action )
	:start(delay < 300)
end

function g_start_timer(name, delay_d, delay_h, delay_m, action)
	if not delay_d or not delay_h or not delay_m then return end
	if not action then action = "" end
	--log3("~~Starting gtimer: [%s_%s]", name, action)

	ogse_st_mgr.delayed_fun_start()
	:set_gdelayDHMS( delay_d, delay_h, delay_m, 0 )
	:init( script_name()..".__do_timer_action", name, action )
	:start(delay_m > 0 and delay_m < 20)
end

local selector = {
--[=[ --KRodin: не нашел где это используется, но оставил, на всякий случай.
	["kol"] = function(params_string)
		local h = hit ()
		h.direction = vector():set(0, 0, 0)
		h.impulse = 5
		h.draftsman = db.actor
		h.type = hit.explosion
		h.power = 3
		if has_alife_info("task_1_start") and not has_alife_info("kolodets_razminirovan") then
			local snd = [[weapons\grenade\grenade_explosion6]]
			snd = xr_sound.get_safe_sound_object(snd)
			db.actor:give_info_portion("kolodets_razminirovan")
			db.actor:give_info_portion("task_2_obj_1")
			db.actor:hit(h)
			if snd then
				snd:play_no_feedback(db.actor, sound_object.s3d, 0, db.actor:position(), 1.0)
			end
			level.add_cam_effector("camera_effects\\fusker.anm", 999, false, "")
		end
		if has_alife_info("task_1_start") and has_alife_info("kolodets_razminirovan") then
			db.actor:give_info_portion("task_2_obj_1")
		end
		del_variable("kol")
	end,
--]=]
	["fpl"] = function(params_string)
		level_tasks.set_task_state(task.completed, "sar_warlab", 0)
		level_tasks.set_task_state(task.completed, "sar_warlab", 1)
	end,

	["oso"] = function(params_string)
		ogse_quests.turn_pnv_off()
		level.add_pp_effector("deadcity_wake.ppe", 2008, false)

		local point = patrol("mon_jump_aes2_walk")
		local look = patrol("mon_jump_aes2_look")
		db.actor:set_actor_position(point:point(0))
		local dir = look:point(0):sub(point:point(0))
		db.actor:set_actor_direction(-dir:getH())

		bind_stalker.restore_weapon()
		level.enable_input()
		level.show_indicators()
	end,

	["vd1"] = function(params_string)
		local p = particles_object("anomaly2\\teleport_out_00")
		p:play_at_pos(params_string)
		local s = sound_object("anomaly\\teleport_incoming")
		s:play_no_feedback(db.actor,sound_object.s2d, 0, vector():set(0, 0, 0), 1.0)
		start_timer("vd2", 2)
	end,

	["vd2"] = function(params_string)
		level.add_pp_effector("teleport.ppe", 2009, false)
		local s = sound_object("anomaly\\teleport_work_2")
		s:play_at_pos(db.actor, vector():set(0, 0, 0), 0, sound_object.s2d)
		db.actor:give_info_portion("pri_trader_vanish")
		start_timer("vd3", 2)
	end,

	["vd3"] = function(params_string)
		local s = sound_object("x18_laugh")
		s:play_no_feedback(db.actor,sound_object.s2d, 0, vector():set(0, 0, 0), 1.0)
		level.enable_input()
		bind_stalker.restore_weapon()
	end,

	["dismiss_prebandit"] = function(params_string)
		if has_alife_info("actor_prebandit") then
			dialogs.actor_clear_community(actor, npc)
		end
	end,

	["make_reinforcements_mad"] = function(params_string)
		jekan_work.dar_zapravka_reinforcement_madness()
	end,

	["block_begin_dialog"] = function(params_string)
		if has_alife_info("block_begin_dialog") then
			db.actor:disable_info_portion("block_begin_dialog")
		end
	end,

	["fail_kill_agr_plennik"] = function(params_string)
		tasks_functor.fail_kill_agr_plennik_timer()
	end,

	["scene_hit_actor_to_prison"] = function(params_string)
		if not tasks_functor.orlov_killed() then
			tasks_functor.show_messeges_shpion_to_orlov()
		end
	end,

	["zag"] = function(params_string)
		db.actor:give_info_portion("hunter_new_zagadka")
		db.actor:disable_info_portion("hunter_oshibka")
	end,

	["rad_zomb"] = function(params_string)
		jekan_work.rad_company_gipnoz()
	end,

	["barpris"] = function(params_string)
		db.actor:give_info_portion("sergant_new_dopros")
	end,

	["dar_officer"] = function(params_string)
		jekan_work.spawn_dar_officer()
		news_manager.send_tip(db.actor, "merc_officer_tip", nil)
		soundtrack.dar_officer_spawn()
	end,

	["road_bomb"] = function(params_string)
		jekan_work.road_bomb_hit()
	end,

	["road_bomb_expl"] = function(params_string)
		jekan_work.btr_signal_to_stop()
	end,

	["uaz"] = function(params_string)
		db.actor:give_info_portion("spawn_dar_uaz")
	end,

	["request"] = function(params_string)
		soundtrack.military_radio_request2()
		db.actor:give_info_portion("dar_dez_btr_spawn")
	end,

	["drifter1"] = function(params_string)
		jekan_work.drifter_body_release()
	end,

	["drifter2"] = function(params_string)
		jekan_work.respawn_drifter()
		jekan_work.spawn_drifter_dog()
	end,
	
	["goto_izgoy_camp"] = function(params_string)
		jekan_work.goto_camp()
	end,
	
	["yan_sold_move_actor"] = function(params_string)
		jekan_work.yan_sold_paralyze_actor()
	end,

	["yan_sold_actor_failed"] = function(params_string)
		if db.actor:dont_has_info("yan_sold_hitted") and db.actor:dont_has_info("yan_soldier_dead") then
			db.actor:give_info_portion("yan_sold_actor_wait_too_long")
		else
			db.actor:give_info_portion("yan_sold_generator_enabled")
		end
	end,
	
	["yan_sold_give_tip"] = function(params_string)
		level.enable_input()
		news_manager.send_tip( db.actor, "tips_yan_sold", nil, "actor", nil )
	end,
	
	["yan_actor_hit_soldier"] = function(params_string)
		news_manager.send_tip( db.actor, "tips_actor_hit_soldier", nil, "actor", nil )
	end,
	
	["izgoy_fin"] = function(params_string)
		jekan_work.izgoy_fin()
	end,
	
	["brat_1"] = function(params_string)
		jekan_work.teleport_brat()
	end,	

	["drifter3"] = function(params_string)
		jekan_work.drifter_release_effect()
	end,

	["uley_1"] = function(params_string)
		jekan_update.uley_timer_1()
	end,

	["uley_2"] = function(params_string)
		jekan_update.uley_timer_2()
	end,

	["zapr"] = function(params_string)
		jekan_work.ds_zapravka_signal2()
	end,
	
	["final_dream"] = function(params_string)
		ogse_quests.final_dream()
	end,
	
	["recall_all"] = function(params_string)
		ogse_quests.flashback()
	end,	

	["final_talk"] = function(params_string)
		ogse_quests.init_talk_final()
	end,	
	
	["orlov_talk_1"] = function(params_string)
		xr_effects.show_messeges_shpion_to_orlov1()
	end,	
	["orlov_talk_2"] = function(params_string)
		xr_effects.show_messeges_shpion_to_orlov2()
	end,	
	["orlov_talk_3"] = function(params_string)
		xr_effects.show_messeges_shpion_to_orlov3()
	end,	
	["orlov_talk_4"] = function(params_string)
		xr_effects.show_messeges_shpion_to_orlov4()
	end,	

	["cheb5"] = function(params_string)
		db.actor:disable_info_portion("cheb_sleep")
	end,
	
	["cheb_magic"] = function(params_string)
		local kolya = level_object_by_sid(story_ids.stalker_kolya)
		local ps = particles_object([[anomaly2\electra2_blast_02]])
		ps:play_at_pos(kolya:position())
		local snd = xr_sound.get_safe_sound_object("anomaly\\anomaly_gravy_blast1")
		snd:play_no_feedback(db.actor, sound_object.s3d, 0, db.actor:position(), 1.0)
		local sKolya = alife():object(kolya:id())
		if sKolya then
			alife():release(sKolya, true)
		end
		quest_deadcity.ps_snow:stop()
		db.actor:give_info_portion("cheb_finish_his_magic")
	end,

	["cheb_art"] = function(params_string)
		db.actor:disable_info_portion("cheb_levelhelp")
		db.actor:disable_info_portion("cheb_busy")
	end,

	["art1"] = function(params_string)
		jekan_work.delete_art1()
	end,

	["art1a"] = function(params_string)
		jekan_work.fake_art1effect()
	end,

	["art2"] = function(params_string)
		jekan_work.delete_art2()
	end,

	["art2a"] = function(params_string)
		jekan_work.fake_art2effect()
	end,

	["art3"] = function(params_string)
		jekan_work.delete_art3()
	end,

	["art3a"] = function(params_string)
		jekan_work.fake_art3effect()
	end,

	["str_zon1"] = function(params_string)
		db.actor:give_info_portion("strangezone1_rebuild")
		jekan_work.strange_zone1_charged_tip()
		db.actor:disable_info_portion("strangezone1_off")
		
		if db.actor:has_info("strangezone1_has_same_art") then
			db.actor:disable_info_portion("strangezone1_has_same_art")
		end
	end,

	["str_zon2"] = function(params_string)
		db.actor:give_info_portion("strangezone2_rebuild")
		jekan_work.strange_zone2_charged_tip()
		db.actor:disable_info_portion("strangezone2_off")
		
		if db.actor:has_info("strangezone2_has_same_art") then
			db.actor:disable_info_portion("strangezone2_has_same_art")
		end
	end,

	["str_zon3"] = function(params_string)
		db.actor:give_info_portion("strangezone3_rebuild")
		jekan_work.strange_zone3_charged_tip()
		db.actor:disable_info_portion("strangezone3_off")
		
		if db.actor:has_info("strangezone3_has_same_art") then
			db.actor:disable_info_portion("strangezone3_has_same_art")
		end
	end,

	["str_zon4"] = function(params_string)
		db.actor:give_info_portion("strangezone4_rebuild")
		jekan_work.strange_zone4_charged_tip()
		db.actor:disable_info_portion("strangezone4_off")
		
		if db.actor:has_info("strangezone4_has_same_art") then
			db.actor:disable_info_portion("strangezone4_has_same_art")
		end
	end,

	["str_zon5"] = function(params_string)
		db.actor:give_info_portion("strangezone5_rebuild")
		jekan_work.strange_zone5_charged_tip()
		db.actor:disable_info_portion("strangezone5_off")
		
		if db.actor:has_info("strangezone5_has_same_art") then
			db.actor:disable_info_portion("strangezone5_has_same_art")
		end
	end,

	["str_zon6"] = function(params_string)
		db.actor:give_info_portion("strangezone6_rebuild")
		jekan_work.strange_zone6_charged_tip()
		db.actor:disable_info_portion("strangezone6_off")
		
		if db.actor:has_info("strangezone6_has_same_art") then
			db.actor:disable_info_portion("strangezone6_has_same_art")
		end
	end,

	["str_zon7"] = function(params_string)
		db.actor:give_info_portion("strangezone7_rebuild")
		jekan_work.strange_zone7_charged_tip()
		db.actor:disable_info_portion("strangezone7_off")
		
		if db.actor:has_info("strangezone7_has_same_art") then
			db.actor:disable_info_portion("strangezone7_has_same_art")
		end
	end,

	["atpbox1"] = function(params_string)
		jekan_work.put_items_to_atp_box()
	end,

	["atpbox2"] = function(params_string)
		jekan_work.vikin_vasyu_na_moroz()
		alife():create("bolt", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id(), db.actor:id())
	end,

	["unicsos"] = function(params_string)
		db.actor:give_info_portion("unic_krovosos_quest")
	end,

	["unicsos2"] = function(params_string)
		if db.actor:dont_has_info("sleep_bloodsucker_on_place") then
			jekan_work.spawn_krovos_unic_bad2()
			start_timer("unicsos3",0,1)
		end
	end,

	["unicsos3"] = function(params_string)
		jekan_work.release_krovos_unic_body()
	end,

	["psdog"] = function(params_string)
		db.actor:give_info_portion("unic_pseudodog_quest")
	end,

	["psdog2"] = function(params_string)
		if db.actor:dont_has_info("sleep_pseudodog_on_place") then
			jekan_work.spawn_pseudodog_unic_bad2()
			start_timer("psdog3",0,1)
		end
	end,

	["psdog3"] = function(params_string)
		jekan_work.release_pseudodog_unic_body()
	end,

	["guard"] = function(params_string)
		jekan_work.spawn_caravan_guard1()
		jekan_work.spawn_caravan_guard2()
	end,

	["cargo"] = function(params_string)
		jekan_work.spawn_loader_cargo1()
	end,
	
	["art_trap"] = function(params_string)
		ogse_teleport_art_quest.journey_begin()
	end,
	
	["btr_comp"] = function(params_string)
		ogse_quests.comp_is_offline()
	end,

	["btr_acc_rdy"] = function(params_string)
		ogse_quests.btr_accum_charged()
	end,
	
	["btr_final"] = function(params_string)
		ogse_quests.btr_finished()
	end,	

	["atplider"] = function(params_string)
		if db.actor:dont_has_info("atp_lider_dead") then
			jekan_work.spawn_atp_lider_work_restrictor()
		end
	end,

	["kosar"] = function(params_string)
		level.enable_input()
		jekan_work.release_potsik()
		db.actor:give_money(-1000)
	end,
	
	["psy_helm_up"] = function(params_string)
		db.actor:give_info_portion("master_quest_helmet_given")
	end,	
	
	["dead_bomb"] = function(params_string)
		db.actor:give_info_portion("master_quest_bomb_ready")
	end,

	["thermite_bomb"] = function(params_string)
		ogse_quests.blow_bidon_bomb()
	end,
	
	["master_notice"] = function(params_string)
		ogse_quests.notify_actor_mg()
	end,	
	
	["game_loose"] = function(params_string)
		db.actor:disable_info_portion("game_kosti_loose")
	end,	

	["synak_drinked"] = function(params_string)
		db.actor:give_info_portion("sinyak_go_to_sleep")
	end,	
	
	["synak_sleeped"] = function(params_string)
		db.actor:give_info_portion("sinyak_awaked")
	end,	
	
	["release_major_jivoderov"] = function(params_string)
		jekan_work.release_major()
	end,		
	
	["stop_bomb_effector"] = function(params_string)
		level.remove_cam_effector(1001)
	end,	
}

function __do_timer_action(select_string, params_string)
	local action = selector[select_string]
	if action then
		action(params_string)
	end
end
--****************************************ТАЙМЕРЫ - КОНЕЦ.*************************************************

-----------------------------------------------------------------------------------------------------------
--Спавним предметы в инвентарь актора, НПС, монстров, ящиков (поддерживаются и клиентские, и серверные объекты)
--ДЛЯ СПАВНА ПАТРОНОВ ИСПОЛЬЗОВАТЬ ОТДЕЛЬНУЮ ФУНКЦИЮ!!!
function spawn_item_in_inv(section, npc, num)
	local npc = npc or db.actor
	local num = num or 1

	local pos, lvi, gvi, pid, sobj
	if type(npc.id) == "function" then
		pos, lvi, gvi, pid = npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id()
	else
		pos, lvi, gvi, pid = npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id
	end

	local is_actor = pid == db.actor:id()
	local game_obj = level.object_by_id(pid)
	for i = 1, num do
		sobj = alife():create(section, pos, lvi, gvi, pid)
		if not is_actor and game_obj then
			level.client_spawn_manager():add(sobj.id, -1, fix_spawn_item_in_inv, game_obj) --Фикс пропадания доспавненного предмета при сейв/лоаде
		end
	end
	if num == 1 then
		return alife():object(sobj.id)
	end
end

--Спавним патроны в инвентарь актора, НПС, монстров, ящиков (поддерживаются и клиентские, и серверные объекты)
function spawn_ammo_in_inv(section, num, npc)
	if num < 1 then return end

	local npc = npc or db.actor

	local pos, lvi, gvi, pid
	if type(npc.id) == "function" then
		pos, lvi, gvi, pid = npc:position(), npc:level_vertex_id(), npc:game_vertex_id(), npc:id()
	else
		pos, lvi, gvi, pid = npc.position, npc.m_level_vertex_id, npc.m_game_vertex_id, npc.id
	end

	local is_actor = pid == db.actor:id()
	local game_obj = level.object_by_id(pid)
	local num_in_box = get_u32(section, "box_size")
	while num > num_in_box or num > 0 do
		local sitem = alife():create_ammo(section, pos, lvi, gvi, pid, num < num_in_box and num or num_in_box)
		if not is_actor and game_obj then
			level.client_spawn_manager():add(sitem.id, -1, fix_spawn_item_in_inv, game_obj) --Фикс пропадания доспавненного предмета при сейв/лоаде
		end
		num = num - num_in_box
	end
end

function fix_spawn_item_in_inv(obj, item_id, item_obj) --Фикс пропадания доспавненного предмета при сейв/лоаде
    obj:transfer_item(item_obj, obj)
end
-----------------------------------------------------------------------------------------------------------

-- Удаляем объект из игры
function remove_item(item_to_remove)
	if item_to_remove then
		local sobj = alife():object(item_to_remove:id())
		if sobj then
			alife():release(sobj, true)
			return true
		else
			return false
		end
	end
	return false
end

--/Удаление итемов из инвентаря ГГ
function remove_inv_items_by_section(sec, items_to_remove)
	local items_removed = 0
	for i = 0, db.actor:object_count() - 1 do
		local item = db.actor:object(i)
		if item and item:section() == sec then
			if remove_item(item) then
				items_removed = items_removed + 1
			end
			if items_removed == items_to_remove then 
				return
			end 
		end
	end 
end

-- Выбрасываем объект из инвентаря, применимо к ГГ
function drop_item(npc, item)
	if item then
	    npc:mark_item_dropped(item)
	end
end

-- Убиваем непися
function make_suicide(npc)
	npc:kill(npc)
end

-- Узнаем отношение одного непися к другому
function get_npc_relation(obj,target)
	local rel = obj:relation(target)
	if rel then
		return rel == game_object.neutral and "neutral"
			or rel == game_object.friend and "friend"
			or rel == game_object.enemy and "enemy"
	end
end

-- Задаем отношение одного непися к другому
function set_npc_relation(obj,target,relation)
	ASSERT(relation, "[ogse.set_npc_relation] variable relation == nil!")
	if relation=="neutral" then
		rel=game_object.neutral
	elseif relation=="friend" then
		rel=game_object.friend
	elseif relation=="enemy" then
		rel=game_object.enemy
	else
		return false
	end
	obj:set_relation(rel,target)
	return true
end

-- Выставляем группировку непися, можно ГГ
function set_npc_community(npc,community_string)
	--значения для community_string можно узнать в config\creatures\game_relations.ltx
	return npc:set_character_community(community_string, 0, 0)
end

-- Удаляем предмет из инвентаря по имени
function remove_item_from_inventory_by_name(remove_item_name,npc)
	return remove_item_from_inventory(npc:object(remove_item_name),npc)
end
function remove_item_from_inventory(remove_item, npc)
	npc = npc or db.actor
	if remove_item then
	    npc:mark_item_dropped(remove_item)
		local sobj = alife():object(remove_item:id())
		if sobj then
			alife():release(sobj, true)
			return true
		end
	end
	return false
end

-- Очищаем инвентарь непися, можно ГГ
function clear_npc_inventory(npc)
    npc:iterate_inventory(function(_, item)
		local section = item:section()
		if section == "bolt" or section == "device_torch" then
			return
		end

		npc:mark_item_dropped(item)
		local sobj = alife():object(item:id())
		if sobj then
			alife():release(sobj, true)
		end
	end)
end

-- Проверка, запущена ли игра
function check_game()
	return level.present() and db.actor and db.actor:alive() and device().precache_frame < 1
end

--**********************************************************************************************************
--KRodin перевёл все функции на систему ogse_unist.script.
--В будущем эти функции НЕ ИСПОЛЬЗОВАТЬ! А использовать ТОЛЬКО ogse_unist.script!!! Подробности читать там.
function save_variable(variable_name, value)
	save_var("ogse."..variable_name, value)
end

function load_variable(variable_name, value_if_not_found)
	if var_exists("ogse."..variable_name) then
		return load_var("ogse."..variable_name)
	elseif value_if_not_found ~= nil then
		return value_if_not_found
	else
		return nil
	end
end

function del_variable(variable_name)
	delete_var("ogse."..variable_name)
end
--***********************************************************************************************************

-- Определяем находится ли ГГ в определенной зоне
function check_npc_in_box(npc, p1,p2)
	local pos=npc:position()
	return is_point_inside_interval(pos.x,p1.x,p2.x) and
		is_point_inside_interval(pos.y,p1.y,p2.y) and
		is_point_inside_interval(pos.z,p1.z,p2.z)
end
function is_point_inside_interval(x,p1,p2)
	if p1>p2 then
		p1,p2 = p2,p1
	end

	return x>p1 and x<p2
end


-- Колбэк на появление предмета в инвентаре ГГ
function on_item_take(obj)
	if obj:section() == "wpn_montirovka" and db.actor:dont_has_info("player_have_crowbar") and level.name() == "l06_rostok" then
		soundtrack.rostok_gordon()
		db.actor:give_info_portion("player_have_crowbar")
		return true
	end
	if obj:section() == "book_1" and db.actor:dont_has_info("prof_zapiska_find") then
		db.actor:give_info_portion("prof_zapiska_find")
		return true
	end
end


function on_storyline_start()
	ogse_spawns.traders_spawn()
	ogse_spawns.sidr_guard_spawn()
	bar_spawn.arbalet()

	db.actor:give_info_portion("encyclopedy_tutorial_jump")
	db.actor:give_info_portion("encyclopedy_tutorial_crouch")
	db.actor:give_info_portion("encyclopedy_tutorial_sprint")
	db.actor:give_info_portion("encyclopedy_tutorial_binocular")
	db.actor:give_info_portion("encyclopedy_tutorial_relation")
	db.actor:give_info_portion("encyclopedy_tutorial_wound")

	dsh.create_free_mob("rad_zombie_rusty", vector():set(359, -45, -111), 1, 1940) --Зомби на Радаре с рукой-артефактом
end

function kill_offline_npc(obj)
	if not obj then return end
	ASSERT( IsStalker(obj) or IsMonster(obj), "" )

	local pk = get_netpk(obj)
	ASSERT( pk:isOk(), "can't read netpacket of %s", obj:name() )
	local data = pk:get()
	data.health = 0
	data.upd.health = 0
	pk:set(data)
	obj.offline_dead = 1
	smart_terrain.on_death( obj.id )
end

-- возвращает уровень здоровья НПС, для проверки в оффлайне жив/мёртв НПС
function check_offline_npc(obj)
	if not obj then return end
	ASSERT( IsStalker(obj) or IsMonster(obj), "" )

	local pk = get_netpk(obj, 2)
	ASSERT( pk:isOk(), "can't read netpacket of %s", obj:name() )
	local data = pk:get()
	--log3("Data of [%s]: %s", obj:name(), data)

	return data.upd.health > 0
end


-------------------Выводим время на HUD-------------------
function after_time_change() --Принудительное обновление времени после перевода стрелок.
	show_time(true)
end

function show_time( forced )
	if forced ~= true then
		ogse_signals.get_mgr():reschedule( 60000 / game_time_factor )
	end
	local hud = get_hud()
	local cs = hud:GetCustomStatic("hud_time_text")
	if not cs then
		cs = hud:AddCustomStatic("hud_time_text", true)
		local wnd = get_main_window()
		local st = wnd:GetStatic( "minimap:background" )
		st:AttachChild(cs:wnd())
	end
	local h = level.get_time_hours()
	local m = level.get_time_minutes()
	local txt = (h >= 10 and h or "0"..h)..":"..(m >= 10 and m or "0"..m)
	cs:wnd():SetText(txt)
end
-----------------------------------------------------------


-- вспомогательная функция, создание одного или нескольких объектов в заданной точке
-- назначение: убрать повторный код из функций далее по тексту
local function spawn_single_object_internal(res, spawn_item)
	ASSERT(spawn_item.sec, "[spawn_single_object_internal] section not defined")
	ASSERT(spawn_item.pos, "[spawn_single_object_internal] position not defined, sec = '%s'", spawn_item.sec)
	ASSERT(spawn_item.lvid, "[spawn_single_object_internal] lvid not defined, sec = '%s'", spawn_item.sec)
	ASSERT(spawn_item.gvid, "[spawn_single_object_internal] gvid not defined, sec = '%s'", spawn_item.sec)
	if spawn_item.lvl then
		ASSERT(level_system_name_by_gvid(spawn_item.gvid) == spawn_item.lvl,
			"[spawn_single_object_internal] gvid does not match the level name, sec = '%s', lvl = '%s', gvid = %d",
			spawn_item.sec,
			spawn_item.lvl,
			spawn_item.gvid
			)
	end
	local count = spawn_item.cnt or 1
	ASSERT(not (count > 1 and spawn_item.sid), "[spawn_single_object_internal] cannot assign same sid to multiple objects!, sec = '%s'", spawn_item.sec)
	local sim = alife()
	for i=1,count do
		local sobj_abstract = sim:create(spawn_item.sec, vector():set(unpack(spawn_item.pos)), spawn_item.lvid, spawn_item.gvid)
		-- получаем объект правильнго типа
		local sobj = sim:object(sobj_abstract.id)
		-- на самом деле в этой проверке нет смысла. Ситуации, когда объект создать не удалось, а выполнение продолжилось,
		-- просто не бывает. В этих случаях всегда идёт вылет. Но пусть будет
		ASSERT(sobj, "[spawn_single_object_internal] cannot create object, sec = '%s'", spawn_item.sec)
		if spawn_item.use_ai_locations == false then
			alife():use_ai_locations(sobj, false)
		elseif spawn_item.use_ai_locations == true then
			alife():use_ai_locations(sobj, true)
		end
		if spawn_item.sid then
			sim:assign_story_id(sobj.id, spawn_item.sid)
		end
		if spawn_item.angle then
			sobj.angle = vector():set(unpack(spawn_item.angle))
		end
		if spawn_item.inf then
			db.actor:give_info_portion(spawn_item.inf)
		end
		table.insert(res, sobj)
	end
end

-- спавнит один или несколько одинаковых предметов в заданной точке
-- фактически просто обёртка над spawn_single_object_internal
function spawn_object(spawn_item)
	local res = {}
	spawn_single_object_internal(res, spawn_item)
	return unpack(res)
end
-- спавнит несколько предметов, заданных таблицей
function spawn_objects(spawn_items)
	local res = {}
	for idx,spawn_item in ipairs(spawn_items) do
		spawn_single_object_internal(res, spawn_item)
	end
	return res
end
-- спавнит рандомно один из предметов, заданных таблицей
function spawn_object_rand(spawn_items)
	local spawn_item = spawn_items[math.random(#spawn_items)]
	local res = {}
	spawn_single_object_internal(res, spawn_item)
	return unpack(res)
end

function quest_spawn_ex(section, total, spawn_item)
	local res = {}
	for i=1,total do
		local spawn_item_tmp = table.clone_simple(spawn_item)
		spawn_item_tmp.sec = section
		spawn_single_object_internal(res, spawn_item_tmp)
	end
	return unpack(res)
end


function kill_crow()
	local lname = level.name()
	for id, sobj in alife():objects() do
		local crow = level.object_by_id(id)
		if crow and crow:section() == "m_crow" and object_level_name(crow) == lname then
			local hit = hit()
				hit.direction = crow:direction()
				hit.impulse = 1000
				hit.draftsman = crow
				hit.power = 1000
				hit.type = hit.strike
			crow:hit(hit)

			ogse_st_mgr.start_gtimer(nil, math.random(150, 300), "ogse.release_crow", id)
		end
	end
end

function release_crow(id)
	local sobj = alife():object(id)
	if sobj then
		alife():release(sobj, true)
	end
end

function spawn_crow()
	local lv = db.actor:level_vertex_id()
	local gv = db.actor:game_vertex_id()
	local x_offset = 0
	local z_offset = 0
	local y_offset = 100
	for k=1,20 do
	x_offset = math.random(-100,100)
	z_offset = math.random(-100,100)
		local pos = db.actor:position()
		pos.x = pos.x + x_offset
		pos.y = pos.y + y_offset
		pos.z = pos.z + z_offset
		alife():create("m_crow", pos, lv, gv)
	end
end


function give_supplies_to_actor(first_speaker, second_speaker)
	if not db.actor:object("detector_simple") then
		dialogs.relocate_item_section(first_speaker, "detector_simple", "in")
	end
	if not db.actor:object("device_torch") then
		dialogs.relocate_item_section(first_speaker, "device_torch", "in")
	end
	if not db.actor:object("hand_radio_f") then
		dialogs.relocate_item_section(first_speaker, "hand_radio_f", "in")
	end
end

function give_binocl_to_actor(first_speaker, second_speaker)
	if not db.actor:object("wpn_binoc") then
		dialogs.relocate_item_section(first_speaker, "wpn_binoc", "in")
	end
end

--[[function money_in(money)
	dialogs.relocate_money(db.actor, money, "in")
end]]

--[[function money_out(money)
	dialogs.relocate_money(db.actor, money, "out")
end]]

function give_info(info)
	if not has_info(info) then
		db.actor:give_info_portion(info)
	end
end

function has_info(info)
	return db.actor:has_info(info)
end


-- функция создания окна сообщения, которое закроется само через определённое время
function autohiding_msg(txt, delay)
	local dlg = MonologueMsg(txt)
	level.start_stop_menu(dlg, true)
	autohide_dlg_timer(delay, dlg):start()
end

-- окно "монологового" типа. Просто сообщение в рамке.
-- Закрыть можно по ESC. Также можно использовать в комбинации с
-- таймером автозакрытия (см. MonologueMsg и ф-ю autohiding_msg)
class "MonologueMsg" (CUIScriptWnd)
function MonologueMsg:__init(txt) super()
	local xml = CScriptXmlInit()
	if device().width / device().height > 0.7 then
		xml:ParseFile("ui_ogse_monologue_msg.xml") -- 4^3
	else
		xml:ParseFile("ui_ogse_monologue_msg_16.xml") -- 16^9
	end	
	xml:InitWindow("main", 0, self)
	self.msg = xml:InitStatic("main:msg", self)
	self.msg:SetTextST(txt)
	--log1("--MonologueMsg:__init()")
end
function MonologueMsg:__finalize()
	--log1("--MonologueMsg:__finalize()")
end
function MonologueMsg:OnKeyboard(dik, key_act) CUIScriptWnd.OnKeyboard(self,dik,key_act)
	if key_act == ui_events.WINDOW_KEY_PRESSED and dik == DIK_keys.DIK_ESCAPE then
		self:GetHolder():start_stop_menu(self,true)
	end
	return true
end

-- служебный таймер для автоматического закрытия диалога через заданное время
class "autohide_dlg_timer" (ogse_qt.quick_timer)
function autohide_dlg_timer:__init(delay, dlg) super(delay)
	self.dlg = dlg
end
function autohide_dlg_timer:taction()
	if self.dlg and self.dlg:IsShown() then
		self.dlg:GetHolder():start_stop_menu(self.dlg, true)
	end
end


--/* Уменьшения репутации на .. едениц главному герою..
function reputation_down_20(stalker, player)
	db.actor:change_character_reputation(-20)
end

function reputation_down_10(stalker, player)
	db.actor:change_character_reputation(-10)
end

function reputation_up_10(stalker, player)
	db.actor:change_character_reputation(10)
end

function reputation_up_20(stalker, player)
	db.actor:change_character_reputation(20)
end


function transfer_items_to_box(box_sid, remove_quest_items, exclude_sections, exclude_clsids)
	local box = level_object_by_sid(box_sid)
	if not box then return end
	local cnt = db.actor:object_count()
	for i=0, cnt-1 do
		local obj = db.actor:object(i)
		-- есть ли объект
		if obj then
		local sect = obj:section()
		-- фильтр по запрещенным class id
		if not exclude_clsids or not exclude_clsids[obj:clsid()] then
		-- фильтр по запрещенным секциям
		if not exclude_sections or not exclude_sections[sect] then
		-- фильтр по квестовым вещам
		if remove_quest_items or not (sys_ini:line_exist(sect, "quest_item") and sys_ini:r_bool(sect, "quest_item")) then
			-- особая обработка метки
			if sect == "amk_metka" then
				ogse_metka.dropped_to_box = ogse_metka.dropped_to_box + 1
			end
			-- передаем предмет
			db.actor:transfer_item(obj, box)
		end
		end
		end
		end
	end
end

function transfer_items_from_box(box_sid)
	local box = level_object_by_sid(box_sid)
	if not box then return end

	local cnt = box:inv_box_count()
	for i=0, cnt-1 do
		local obj = box:object_from_inv_box(i)
		-- есть ли объект
		if obj then
			local sect = obj:section()
			-- передаем предмет
			box:transfer_item(obj, db.actor)
		end
	end
end


function transfer_weapons_to_box(box_sid, remove_quest_items, exclude_sections, exclude_clsids)
	local box = level_object_by_sid(box_sid)
	if not box then return end
	local cnt = db.actor:object_count()
	for i=0, cnt-1 do
		local obj = db.actor:object(i)
		-- есть ли объект
		if obj then
		local sect = obj:section()
		-- фильтр по запрещенным class id
		if not exclude_clsids or not exclude_clsids[obj:clsid()] then
		-- фильтр по запрещенным секциям
		if not exclude_sections or not exclude_sections[sect] then
		-- фильтр по квестовым вещам
		if remove_quest_items or not (sys_ini:line_exist(sect, "quest_item") and sys_ini:r_bool(sect, "quest_item")) then
			-- передаем предмет
			if obj:is_weapon() or obj:is_knife() then
				db.actor:transfer_item(obj, box)
			end
		end
		end
		end
		end
	end
end


function is_developer_mode()
	return string.find( command_line(), "-dev" )
end

function on_spawn()
  if not is_developer_mode() then
    for _, k in ipairs({
      --[["g_god", "g_unlimitedammo", "g_zones_dbg", "g_vertex_dbg",]] "g_crosshair_dbg", "g_ammunition_on_belt"
    }) do
      cmd( k, "off" )
    end
    --
    --cmd( "hud_draw", "on" )
    --
    for _, k in ipairs({
      --"hud_adjust_mode", "show_wnd_rect", "show_wnd_rect_all"
    }) do
      cmd( k, 0 )
    end
    --
    for _, k in ipairs({
      --[["g_god", "g_unlimitedammo", "g_zones_dbg", "g_vertex_dbg",]] "g_crosshair_dbg", "g_ammunition_on_belt",
      --"hud_draw",
      --[["hud_adjust_mode", "show_wnd_rect", "show_wnd_rect_all",]]
      --[["demo_record",]] "jump_to_level", "time_factor", "set_weather"
    }) do
      get_console():disable_command( k )
    end
  end
end
