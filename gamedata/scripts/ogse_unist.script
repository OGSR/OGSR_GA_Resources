
-----------------------------------------------------------
--| ogse_unist.script
--| Универсальная система хранения пользовательских данных
--| Malandrinus, OGS Evolution Team, 2011
--| version 1.0
--| https://github.com/dsh2dsh/op2ogse/blob/master/gamedata/scripts/ogse_unist.script
-----------------------------------------------------------
-- Использование:
-- ogse.save_var(name, value [,type [,subtype]]) -- сохранить переменную
-- ogse.load_var(name [,default_value [,type [,subtype]]]) -- прочитать переменную
-- ogse.var_exists(name) -- проверить существование переменной
-- ogse.delete_var(name) -- удалить переменную, чтобы освободить место
-- name - строка с уникальным именем переменной
-- value - значение
-- type - строка с типом. Это в ряде случаев необязательный параметр.
--
-- Возможные варианты:
-- "string" - строка, занимает количество символов + 1
-- "bool" - логическое значение, 1 байт
-- "float" - яисло с плавающей запятой, 4 байта
-- "vector" - вектор из 3-х float, 12 байт
-- "time" - время CTime, 8 байт
-- "u8", "s8", "u16", "s16", "u32", "s32" - знаковые и беззнаковые целые, 1,2,4 байта соответственно
-- "number" - автораспознаваемый тип числа, хранится в строковом виде. длина зависит от значения. 
--            Этот тип не нужно указывать, он будет назначен переменной автоматически, 
--            если значение имеет тип числа.
-- "chunk" - представляет собой нетпакет, или попросту кусок двоичных данных произвольной длины. 
--           Это планировалось как основа для создания отдельных хранилищ, совместимых с текущей 
--           идеологией. Т.е. везде, где для сохранения/загрузки передаётся нетпакет, его можно 
--           заменить на наш отдельный, а его уже хранить в этом общем хранилище. Смысл этого в 
--           экономии места при организации сохранения разных подсистем. Для каждой подсистемы или 
--           сохраняемого модуля можно конечно выделить отдельный объект хранения (из тех, что 
--           лежат в основе всего универсального хранилища), но это в общем случае слишком 
--           расточительно. Используя эти сохраняемые пакеты можно упаковывать данные более экономно.
-- "table" - таблица вида { [key] = value, ...}, где типы ключей и значений ограничены
--           автораспознаваемыми типами: строки, логические значения, числа и таблицы.
-- "array" - тип массива. Значение - таблица вида {v1, v2, v3}.
--           При сохранении массивов можно указывать тип их элементов. Вот так:
--           ogse.save_var( script_name() .. ".chunks", chunks, "array", "chunk" )
--           Здесь сохраняется список, каждый элемент которого сохраняется, как
--           chunk. Это вместо автоугадава, который все сохраняет, как строки.
-- "array_template" - Предполагается использовать следующим образом:
--                    ogse.save_var(
--                      "chunks", chunks, "array_template", { "u8", "u16", "string", "time" }
--                    )
--                    В chunks будет список, каждый элемент которого является списком,
--                    состоящим из элементов, указанных в четвертом параметре. В отличие от
--                    типа "chunk", данные не копируются туда-сюда побайтово и запись/чтение
--                    должны работать быстрее.
--                    !Типы "number" и "chunk" не поддерживаются в четвёртом параметре!
--                    --
--                    Теперь вот такую структуру:
--                    local arr = {
--                      {
--                        43567,
--                        { 1, 2, 3, 4, ..., 88 }
--                      },
--                      ...
--                    }
--                    можно сохранить вот так:
--                    ogse.save_var (
--                      name, arr, "array_template",
--                      {
--                        "u16",
--                        { "array_template", { "u16" } },
--                      }
--                    )
--                    --
--                    Можно и просто "array" использовать. Вот так например:
--                    ogse.save_var (
--                      name, arr, "array_template",
--                      {
--                        "string",
--                        "string",
--                        { "array" },
--                      }
--                    )
--                    что бы сохранить что-нибудь вроде:
--                    local arr = {
--                      {
--                        "name1",
--                        "name2",
--                        { "test", true, 234 }
--                      },
--                      ...
--                    }
-- параметр type не является обязательным в случае типа значения строка, логическое значение, 
-- число и таблица (именно таблица, а не массив!).
-- В случае числа при неуказании точного типа числа оно просто сохраняется в строковом виде. 
-- Поэтому желательно его указывать. Для чисел с плавающей запятой это существенно уменьшит размер 
-- хранимых данных, так как при указании типа "float" число будет сохранено в двоичном виде 
-- как 4 байта, строка же может занять до 16-и байт.
-- Во всех остальных случаях, вектор, объект CTime, chunk, array, параметр надо указывать
-- обязательно, так как в этом случае нет возможности тривиально определить природу вргумента. 
-- Если в этом случае не указать тип, то будет вылет с соответствующим сообщением.
--
-- при чтении переменной минимально достаточно указать её имя
-- local value = ogse.load_var(name)
-- Однако, переменная должна существовать. Если такой ранее не было сохранено, то будет 
-- вылет (намеренно). Чтобы этого избежать, надо указывать значение по умолчанию.
-- local value = ogse.load_var(name, default_value [,type [,subtype]])
-- тип, как необязательный параметр, указывается по тем же правилам, что и при сохранении.

local STORAGE_DBG = false --Включает подробный отладочный вывод

function attach(sm)
  sm:subscribe({signal = "on_load_before_all", fun = this.on_load})
  sm:subscribe({signal = "on_save_after_all", fun = this.on_save})
-----------Псевдонимы для удобства вызова-----------
  if not _G.ogse then _G.ogse = {} end --на всякий случай
  _G.ogse.save_var           = this.set_value
  _G.ogse.load_var           = this.get_value
  _G.ogse.load_var_safe      = this.get_value_safe
  _G.ogse.var_exists         = this.value_exist
  _G.ogse.delete_var         = this.remove_value
  _G.ogse.save_or_delete_var = this.set_or_remove_value
  _G.get_game_id             = this.get_game_id
----------------------------------------------------
--Дополнительные методы для движкового класса net_packet--
--В других скриптах не используются, поэтому пусть инитятся прям здесь.
  net_packet.w_CTime_ex = function( p, t ) --Запись CTime в пакет.
    ASSERT(t, "[w_CTime_ex] time is nil")
    local Y, M, D, h, m, s, ms = -1, 0, 0, 0, 0, 0, 0
    if t and t ~= game.CTime() then
      Y, M, D, h, m, s, ms = t:get()
      Y = Y - 2000
    end
    p:w_u8 ( Y )
    p:w_u8 ( M )
    p:w_u8 ( D )
    p:w_u8 ( h )
    p:w_u8 ( m )
    p:w_u8 ( s )
    p:w_u16( ms )
  end
  net_packet.r_CTime_ex = function( p ) --Чтение CTime из пакета
    local Y, M, D, h, m, s, ms = p:r_s8(), p:r_u8(), p:r_u8(), p:r_u8(), p:r_u8(), p:r_u8(), p:r_u16()
    local t = game.CTime()
    if Y ~= -1 then
      t:set( Y + 2000,  M, D, h, m, s, ms)
    end
    return t
  end
----------------------------------------------------------
end


local storage = {}    -- данные для сохранения
local ready   = false -- можно ли пользоваться (не раньше, чем будет
                      -- загружен онлайновый актор) надо, чтобы не
                      -- было пересечений с другими
                      -- хранилищами. Внимание, НЕ МЕНЯТЬ!
local storage_guid = "{5377D955-0611-4545-A3AB-18521FD303B0}"
local st_objects   = {}
local st_count_item


function is_ready()
  return ready
end


function clear_storage() -- чистим хранилище, остаётся только одно, корневое
  for k, v in pairs( storage ) do
    if k ~= st_count_item.name then
      remove_value( k )
    end
  end
  for i = st_count_item.value, 2, -1 do
    ogse_base_storage.remove_storage( st_objects[ i ].st_id )
    table.remove( st_objects, i )
  end
  st_count_item.value = 1
end


function print_storage_usage()
  log1( "----==<| Printing storage usage information |>==--" )
  for i = 1, st_count_item.value do
    local st        = st_objects[ i ]
    local items_cnt = 0
    for _, _ in pairs( st.data ) do
      items_cnt = items_cnt + 1
    end
    log3( "~~[%s]: total space = [%s], free space = [%s], items count = [%s]", i, st.total_space, st:free_space(), items_cnt )
  end
  log1( "----==<| Printing storage usage information - END |>==--" )
end


function print_storage()
  print_storage_usage()
  local types_inv = {}
  for k, v in pairs( types ) do types_inv[ v ] = k end
  log1( "----==<| Printing storage content |>==--" )
  for name, item in pairs( storage ) do
    log3( "Name = ["..name.."], type = ["..types_inv[ item.type ].."], data_size = ["..item:data_size().."], full size = ["..item.size.."]\n"..item:get_string() )
  end
  log1( "----==<| Printing storage content - END |>==--" )
end


types = {
  [ "string" ] =  1,
  [ "number" ] =  2,
  [ "bool"   ] =  3,
  [ "float"  ] =  4,
  [ "u8"     ] =  5,
  [ "s8"     ] =  6,
  [ "u16"    ] =  7,
  [ "s16"    ] =  8,
  [ "u32"    ] =  9,
  [ "s32"    ] = 10,
  [ "time"   ] = 11,
  [ "vector" ] = 12,
  [ "array"  ] = 13,
  [ "table"  ] = 14,
  [ "chunk"  ] = 15,
  [ "array_template" ] = 16,
}

if STORAGE_DBG then
  type_id_tostring = {}
  for type, id in pairs(types) do
    type_id_tostring[id] = type
  end
end

local item_types_registry


-------------------------------------------------------------------
-- функция создаёт элемент с именем и типом, но без привязки к конкретному хранилищу
-- смысл в предварительном создании элемента для последующего выяснения, куда его
-- можно поместить и собственно помещения
function create_item( name, value, typ, subtype )
  if typ then -- явно задали тип
    if type( typ ) ~= "number" then
      ASSERT( types[ typ ], "ogse_unist.create_item: unknown type [%s]", typ )
      typ = types[ typ ]
    end
    local constructor = item_types_registry[ typ ]
    ASSERT(
      constructor,
      "ogse_unist.create_item: cant find type [%s] in types registry", typ
    )
    return constructor( name, value, subtype )
  else
    -- здесь пытаемся определить, какой тип. Такая ситуация должна
    -- прокатывать только для следующих типов: строки, логические
    -- значения, числа, сохраняемые в строках (types.number)
    local lua_type = type( value )
    if lua_type == "string" then
      return string_element( name, value )
    elseif lua_type == "boolean" then
      return bool_element( name, value )
    elseif lua_type == "number" then
      -- в этом случае любые числа будут сохраняться в виде строки
      -- занимает больше места, медленней работает, для чисел с
      -- плавающей запятой может привести к потерям точности с другой
      -- стороны меньше гемора
      return general_number( name, value )
    elseif lua_type == "table" then
      return table_element( name, value )
    elseif lua_type == "nil" then
      -- надо подумать, что делать, вылетать или сохранять nil
      abort("ogse_unist.create_item: trying set nil value for variable with name [%s]", name )
	else
	  abort("ogse_unist.create_item: trying set [%s] value for variable with name [%s]", lua_type, name)
    end
  end
end


-- функция читает из нетпакета один элемент в универсальном формате
function read_item_from_packet( r_packet )
  local pos1 = r_packet:r_tell()
  local typ  = r_packet:r_u8()  -- тип данных
  local constructor = item_types_registry[ typ ]
  ASSERT(
    constructor,
    "ogse_unist.read_item_from_packet: cant find type [%s] in types registry", typ
  )
  local name = r_packet:r_stringZ()
  local item = constructor( name )
  item:read_value( r_packet )
  local pos2 = r_packet:r_tell()
  ASSERT(
    pos2 - pos1 == item.size,
	"read_item_from_packet: item reported size is different from actually readed data: name_len = [%s], value = [%s], item.size = [%s], written = [%s]",
	item.name:len(), item:get_string(), item.size, pos2 - pos1
  )
  return item
end


-- пишем в нетпакет данные одного элемента
function write_item_to_packet( w_packet, item )
  local pos1 = w_packet:w_tell()
  w_packet:w_u8( item.type )
  w_packet:w_stringZ( item.name )
  item:write_value( w_packet )
  local pos2 = w_packet:w_tell()
  ASSERT(
    pos2 - pos1 == item.size,
	"write_item_to_packet: item reported size is different from actually written data: name_len = [%s], value = [%s], item.size = [%s], written = [%s]",
	item.name:len(), item:get_string(), item.size, pos2 - pos1
  )
end


local function add_storage()
  local st_count = st_count_item.value + 1
  local st = base_single_storage( st_count )
  ASSERT(
    st, "ogse_unist.add_storage: can't create new storage. count = [%s]", st_count
  )
  st_objects[ st_count ] = st
  st_count_item.value = st_count -- грязный трюк, не поступаем так
                                 -- больше ни с какой переменной
  return st
end


local game_id
function get_game_id()
  return game_id or abort("[ogse_unist.get_game_id] value of game_id is not yet defined. Do not use it before actor's loaded")
end


function on_load()
  -- корневое хранилище, содержит переменную с общим количеством хранилищ
  st_objects[ 1 ] = base_single_storage( 1 )
  local st_count_key = "ST_COUNT_" .. storage_guid -- её имя
  st_count_item = storage[ st_count_key ]
  if not st_count_item then
    -- если её ещё нет (только что создано корневое хранилище)
    -- то создаём её со значением 1 (всего одно, корневое хранилище)
    st_count_item = create_item( st_count_key, 1, types.u16 )
    ASSERT( st_count_item, "on_init: cant create count item" )
    -- добавляем элемент в корневое хранилище
    st_objects[ 1 ]:add_item( st_count_item )
    storage[ st_count_key ] = st_count_item
  end
  for i = 2, st_count_item.value do     -- перебираем все остальные
    local st = base_single_storage( i ) -- создаём их, читаем
    st_objects[ i ] = st                -- регистрируем
  end
  ready = true -- закончили, можно использовать систему
  -- если нет переменной с ID игры, то добавляем
  -- ключ, чтобы с меньшей вероятностью затереть
  local game_id_key = "GAME_ID_" .. storage_guid
  if not value_exist( game_id_key ) then
    game_id = math.random( 1000000, 9999999 )
    set_value( game_id_key, game_id, "u32" )
  else
    game_id = get_value( game_id_key )
    ASSERT(
      ready, "[ogse_unist.on_load] cannot load game_id. Check the logic!"
    )
  end
  --ASSERT(ready, "ogse_unist.on_init: storage was not succesfully created")
  if STORAGE_DBG then print_storage() else print_storage_usage() end
end


function on_save()
  local st_count_key = "ST_COUNT_" .. storage_guid
  ASSERT( storage[ st_count_key ], "st_count_key not found in the storage" )
  local items = {}
  for name, item in pairs( storage ) do
    if name ~= st_count_key then
      table.insert( items, item )
    end
  end
  table.sort( items, function( a, b ) return a.size > b.size end )
  table.insert( items, 1, storage[ st_count_key ] )
  for i = 1, st_count_item.value do
    st_objects[ i ]:clear()
  end
  local total_space = 8000
  for _, item in ipairs( items ) do
    local frags
    if item.size > total_space then
      frags = item:fragment_value( total_space )
    else
      frags = { item }
    end
    for i = 1, st_count_item.value do
      if st_objects[ i ]:free_space() >= frags[ 1 ].size then
        -- добавляем элемент в хранилище
        st_objects[ i ]:add_item( frags[ 1 ] )
        table.remove( frags, 1 )
        if #frags == 0 then break end
      end
    end
    if #frags > 0 then
      -- если не найдено, то добавляем новые хранилища
      for i = 1, #frags do
        local st = add_storage()
        -- добавляем элемент в хранилище
        st:add_item( frags[ i ] )
      end
    end
  end
  for i = 1, st_count_item.value do
    st_objects[ i ]:save()
  end
end


-- класс, инкапсулирущий одиночное хранилище
class "base_single_storage"
function base_single_storage:__init( num ) -- аргумент, номер объекта хранилища
  self.st_num = num
  self.st_id  = "ST_" .. storage_guid .. num
  self.st_obj = ogse_base_storage.get_storage( self.st_id )
  -- это делается только здесь и только один раз
  local r_packet = self.st_obj:r_reset()
  self.data_size = 0
  self.start_pos = r_packet:r_tell()
  -- log2( "start_pos=%d (%d)", self.start_pos, self.st_obj.zero_pos )
  self.total_space = 8000
  ASSERT(
    8192 - self.start_pos > self.total_space,
    "base_single_storage:__init: netpacket free space is unexpectedly small"
  )
  self.data = {}
  while not r_packet:r_eof() do
    local item = read_item_from_packet( r_packet )
    self:add_item( item )
  end
  self.end_pos = r_packet:r_tell()
  self:merge_data_to( storage )
end


function base_single_storage:clear()
  self.data      = {}
  self.data_size = 0
end


function base_single_storage:get_total_space()
  return self.total_space
end


function base_single_storage:get_data_size()
  local sz = 0
  for _, item in pairs( self.data ) do
    sz = sz + item.size
  end
  return sz
end


function base_single_storage:save()
  -- это делается только здесь и только один раз
  local w_packet = self.st_obj:w_reset()
  for _, item in pairs( self.data ) do
    write_item_to_packet( w_packet, item )
  end
end


function base_single_storage:merge_data_to( t )
  for name, item in pairs( self.data ) do
    if t[ name ] then
      t[ name ]:append_data_from( item )
    else
      t[ name ] = item
    end
  end
end


function base_single_storage:free_space()
  return self.total_space - self.data_size
end


-- одиночное хранилище не создаёт элементы, а только хранит поэтому
-- для него есть только функции добавления элемента существующего
-- элемента в хранилище и удаления элемента из хранилища (но не
-- удаления самого элемента)
function base_single_storage:add_item( item )
  ASSERT(
    self.data_size + item.size <= self.total_space,
    "base_single_storage:add_item: dude, you can't save it here. No space for the element:\nname: %s\ntype: %s\nsize: %s\nin the storage:\nnumber: %s\ntotal space: %s\nfree space: %s",
    item.name, item.type, item.size, self.st_num, self.total_space, self:free_space()
  )
  -- добавить элемент в локальную таблицу
  self.data[ item.name ] = item
  -- обновить размер данных
  self.data_size = self.data_size + item.size
end


--------------------------------------------------------------------------------
-- для элементов принимается идеология неизменения. Это означает, что
-- значение элемента и его размер никогда не поменяются и значит
-- должны быть вычислены только один раз новое значение можно получить
-- только полной заменой элемента операция get_value всегда даёт копию
-- данных, независимую от содержащейся в элементе Примечание: для
-- базовых типов (чисел, строк, логических значений) это выполняется
-- само собой. Для ссылочных типов (массивов и таблиц) это делается
-- искусственно, методом глубокого клонирования


class "u8_element"
function u8_element:__init( name, value )
  self.name = name
  self.type = types.u8
  if value ~= nil then
    self.value = value
    self:update_size()
  end
  self.r_fun = "r_u8"
  self.w_fun = "w_u8"
end

function u8_element:get_value()
  return self.value
end

function u8_element:data_size()
  return 1
end

function u8_element:header_size()
  -- длина имени + 1 байт на завершитель строки имени + 1 байт на тип
  return self.name:len() + 2
end

function u8_element:get_string()
  return self.value
end

function u8_element:read_value( r_packet )
  self.value = r_packet[ self.r_fun ]( r_packet )
  self:update_size()
  return self.value
end

function u8_element:write_value( w_packet )
  w_packet[ self.w_fun ]( w_packet, self.value )
end

-- выдаёт полный размер элемента в байтах в нетпакете, включая поле
-- имени и типа
function u8_element:update_size()
  self.size = self:header_size() + self:data_size()
end

function u8_element:fragment_value( max_size )
  abort( "not implemented" )
end

function u8_element:append_data_from( item )
  abort( "not implemented" )
end


class "s8_element" ( u8_element )
function s8_element:__init( name, value ) super( name, value )
  self.type  = types.s8
  self.r_fun = "r_s8"
end


class "u16_element" ( u8_element )
function u16_element:__init( name, value ) super( name, value )
  self.type  = types.u16
  self.r_fun = "r_u16"
  self.w_fun = "w_u16"
end

function u16_element:data_size()
  return 2
end


class "s16_element" ( u16_element )
function s16_element:__init( name, value ) super( name, value )
  self.type  = types.s16
  self.r_fun = "r_s16"
  self.w_fun = "w_s16"
end


class "u32_element" ( u8_element )
function u32_element:__init( name, value ) super( name, value )
  self.type  = types.u32
  self.r_fun = "r_u32"
  self.w_fun = "w_u32"
end

function u32_element:data_size()
  return 4
end


class "s32_element" ( u32_element )
function s32_element:__init( name, value ) super( name, value )
  self.type  = types.s32
  self.r_fun = "r_s32"
  self.w_fun = "w_s32"
end


class "float_element" ( s32_element )
function float_element:__init( name, value ) super( name, value )
  self.type  = types.float
  self.r_fun = "r_float"
  self.w_fun = "w_float"
end


class "bool_element" ( u8_element )
function bool_element:__init( name, value ) super( name, value )
  self.type  = types.bool
  self.r_fun = "r_bool"
  self.w_fun = "w_bool"
end

function bool_element:get_string()
  return tostring(self.value)
end


class "string_element" ( u8_element )
function string_element:__init( name, value ) super( name, value )
  self.type  = types.string
  self.r_fun = "r_stringZ"
  self.w_fun = "w_stringZ"
end

function string_element:get_string()
  return "'"..self.value.."'"
end

function string_element:data_size()
  return self.value:len() + 1
end

function string_element:fragment_value( max_size )
  local fragments     = {}
  local max_value_len = max_size - self:header_size() - 1
  local sum_len       = 0
  for i = 1, self.value:len(), max_value_len do
    local end_pos = i + max_value_len - 1
    local str
    if end_pos < self.value:len() then
      str = self.value:sub( i, end_pos )
    else
      str = self.value:sub( i )
    end
    table.insert( fragments, string_element( self.name, str ) )
    sum_len = sum_len + str:len()
  end
  ASSERT(
    sum_len == self.value:len(),
    "sum_len != self.value:len(): [%s] != [%s]", sum_len, self.value:len()
  )
  return fragments
end

function string_element:append_data_from( item )
  self.value = self.value .. item:get_value()
  self:update_size()
end


class "general_number" ( string_element )
function general_number:__init( name, value )
  self.type = types.number
  self.name = name
  if value then
    self.real_val = value
    self.value    = tostring( value )
    self:update_size()
  end
end

function general_number:get_value()
  return self.real_val
end

function general_number:get_string()
  return self.real_val
end

function general_number:read_value( r_packet )
  self.value    = r_packet:r_stringZ()
  self.real_val = tonumber( self.value )
  self:update_size()
  return self.real_val
end

function general_number:write_value( data )
  data:w_stringZ( self.value )
end


class "vector_element" ( u8_element )
function vector_element:__init( name, value )
  self.name = name
  if value then
    self.value = vector():set( value )
    self:update_size()
  end
  self.type = types.vector
end

function vector_element:get_value()
  return vector():set( self.value ) -- возвращаем копию
end

function vector_element:get_string()
  return ("%9.3f, %9.3f, %9.3f"):format(self.value.x, self.value.y, self.value.z)
end

function vector_element:read_value( data )
  self.value = data:r_vec3()
  self:update_size()
  return self.value
end

function vector_element:write_value( data )
  data:w_vec3( self.value )
end

function vector_element:data_size()
  return 12
end


class "time_element" ( u8_element )
function time_element:__init( name, value )
  self.name = name
  if value then
    self.value = game.CTime( value )
    self:update_size()
  end
  self.type = types.time
end

function time_element:get_string()
  return self.value:timeToString( 3 ) .. " " .. self.value:dateToString( 0 )
end

function time_element:read_value( data )
  self.value = data:r_CTime_ex()
  self:update_size()
  return self.value
end

function time_element:write_value( data )
  data:w_CTime_ex( self.value )
end

function time_element:get_value()
  return game.CTime( self.value ) -- возвращаем копию
end

function time_element:data_size()
  return 8
end


class "array_element" ( u8_element )
function array_element:__init( name, value, subtype )
  self.name = name
  if value then
    self.value = {}
    for _, v in ipairs( value ) do
      table.insert( self.value, create_item( "", v, subtype ) )
    end
    self:update_size()
  end
  self.type    = types.array
  self.subtype = subtype
end

if STORAGE_DBG then
  function array_element:get_string( ind )
	local s = "{" --Начало
	local end_res = ind and "\n"..ind.."}" or "\n}" --Конец
	local def_ind = "  " --Отступ от начала строки
	ind = ind and ind..def_ind or def_ind --Для каждой "таблицы внутри таблицы" отступ увеличивается в 2 раза
    --
    for i, v in ipairs( self.value ) do
      s = s.."\n"..ind.."["..i.."] = ("..type_id_tostring[v.type]..") "..v:get_string( ind )..","
    end
    return s..end_res
  end
else
  function array_element:get_string()
    return "[disabled for speed]"
  end
end

function array_element:read_value( data )
  self.value  = {}
  local count = data:r_u16()
  for i = 1, count do
    table.insert( self.value, read_item_from_packet( data ) )
  end
  self:update_size()
  return self.value
end

function array_element:write_value( data )
  data:w_u16( #self.value )
  for _, v in ipairs( self.value ) do
    write_item_to_packet( data, v )
  end
end

function array_element:data_size()
  local sz = 2
  for i, v in ipairs( self.value ) do
    sz = sz + v.size
  end
  return sz
end

function array_element:get_value()
  local t = {}
  for _, v in ipairs( self.value ) do
    table.insert( t, v:get_value() )
  end
  return t
end

function array_element:fragment_value( max_size )
  local fragments     = {}
  local max_value_len = max_size - self:header_size() - 2
  local tmp, sz       = {}, 0
  local check_sz      = 0
  for i, v in ipairs( self.value ) do
    if sz + v.size > max_value_len then
      local t = {}
      for _, v2 in ipairs( tmp ) do
        table.insert( t, v2:get_value() )
      end
      table.insert( fragments, array_element( self.name, t, self.subtype ) )
      check_sz = check_sz + sz
      tmp, sz  = { v }, v.size
    else
      table.insert( tmp, v )
      sz = sz + v.size
    end
  end
  if #tmp > 0 then
    local t = {}
    for _, v2 in ipairs( tmp ) do
      table.insert( t, v2:get_value() )
    end
    table.insert( fragments, array_element( self.name, t, self.subtype ) )
    check_sz = check_sz + sz
  end
  --ASSERT(
  --  check_sz + 2 == self:data_size(),
  --  "check_sz + 2 != self:data_size(): [%s], [%s]", check_sz, self:data_size()
  --)
  return fragments
end

function array_element:append_data_from( item )
  for _, v in ipairs( item.value ) do
    table.insert( self.value, v )
  end
  self:update_size()
end


class "table_element" ( array_element )
function table_element:__init( name, value )
  self.name = name
  if value then
    self.value = {}
    for k, v in pairs( value ) do
      table.insert( self.value, { create_item( "", k ), create_item( "", v ) } )
    end
    self:update_size()
  end
  self.type = types.table
end

if STORAGE_DBG then
  function table_element:get_string( ind )
	local s = "{" --Начало
	local end_res = ind and "\n"..ind.."}" or "\n}" --Конец
	local def_ind = "  " --Отступ от начала строки
	ind = ind and ind..def_ind or def_ind --Для каждой "таблицы внутри таблицы" отступ увеличивается в 2 раза
	--
    for _, v in ipairs( self.value ) do
      s = s.."\n"..ind.."["..v[1]:get_string( ind ).."] = "..v[2]:get_string( ind )..","
    end
    return s..end_res
  end
else
  function table_element:get_string()
    return "[disabled for speed]"
  end
end

function table_element:read_value( data )
  self.value  = {}
  local count = data:r_u16()
  for i = 1, count do
    table.insert(
      self.value,
      { read_item_from_packet( data ), read_item_from_packet( data ) }
    )
  end
  self:update_size()
  return self.value
end

function table_element:write_value( data )
  data:w_u16( #self.value )
  for _, v in ipairs( self.value ) do
    write_item_to_packet( data, v[ 1 ] )
    write_item_to_packet( data, v[ 2 ] )
  end
end

function table_element:data_size()
  local sz = 2
  for _, v in ipairs( self.value ) do
    sz = sz + v[ 1 ].size + v[ 2 ].size
  end
  return sz
end

function table_element:get_value()
  local t = {}
  for _, v in ipairs( self.value ) do
    t[ v[ 1 ]:get_value() ] = v[ 2 ]:get_value()
  end
  return t
end

function table_element:fragment_value( max_size )
  abort( "not implemented" )
end

function table_element:append_data_from( item )
  abort( "not implemented" )
end


------ объект пользовательского пакета ---------------
-- представляет собой блок бинарных данных в виде нетпакета с
-- установленной позицией чтения и записи позиция чтения
-- устанавливается в начало данных, позиция записи в конец, таким
-- образом обозначая полный размер данных. Данный тип элемента
-- является основой для создания пользовательских систем хранения.
class "chunk_element" ( u8_element )
function chunk_element:__init( name, value )
  self.type = types.chunk
  self.name = name
  if value ~= nil then
    self.value = self:clone_value( value ) -- копия нетпакета
    self:update_size()
  end
end

local function get_row_data( packet )
  local saved_reading_pos = packet:r_tell()
  local buf = {}
  while not packet:r_eof() do
    table.insert( buf, packet:r_u8() )
  end
  packet:r_seek( saved_reading_pos )
  return buf
end

function chunk_element:get_value()
  return self:clone_value( self.value )
end

function chunk_element:data_size()
  -- 2 байта на поле размера
  return self.value:w_tell() - self.value:r_tell() + 2
end

if STORAGE_DBG then
  function chunk_element:get_string()
    local buf  = get_row_data( self.value )
    local sbuf = {}
    for _, byte in ipairs( buf ) do
      table.insert( sbuf, ("%0x"):format(byte) )
    end
    return table.concat( sbuf, ' ' )
  end
else
  function chunk_element:get_string()
    return "[disabled for speed]"
  end
end

function chunk_element:read_value( r_packet )
  local count = r_packet:r_u16()
  self.value  = net_packet()
  self.value:w_begin( 123 )
  self.value:r_seek( self.value:w_tell() )
  for i = 1, count do
    self.value:w_u8( r_packet:r_u8() )
  end
  self:update_size()
  return self.value
end

function chunk_element:write_value( w_packet )
  local buf = get_row_data( self.value )
  w_packet:w_u16( #buf )
  for _, byte in ipairs( buf ) do
    w_packet:w_u8( byte )
  end
end

function chunk_element:clone_value( source )
  local new_packet = net_packet()
  new_packet:w_begin( 123 )
  -- в общем-то всегда будет 2, но типа так правильнее
  new_packet:r_seek( new_packet:w_tell() )
  local buf = get_row_data( source )
  for _, byte in ipairs( buf ) do
    new_packet:w_u8( byte )
  end
  return new_packet
end


local data_sizes = {
  [ "bool"   ] =  1,
  [ "float"  ] =  4,
  [ "s8"     ] =  1,
  [ "s16"    ] =  2,
  [ "s32"    ] =  4,
  [ "time"   ] =  8,
  [ "u8"     ] =  1,
  [ "u16"    ] =  2,
  [ "u32"    ] =  4,
  [ "vector" ] = 12,
}


class "chunk_template_element" ( u8_element )
function chunk_template_element:__init( template, value )
  self.template = template
  if value ~= nil then
    if type( value ) ~= "table" then
      value = { value }
    end
    self.value = {}
    for i, v in ipairs( self.template ) do
      if type( v ) == "table" then
        table.insert( self.value, create_item( "", value[ i ], unpack( v ) ) )
      elseif v == "vector" then
        table.insert( self.value, vector():set( value[ i ] ) )
      elseif v == "time" then
        table.insert( self.value, game.CTime( value[ i ] ) )
      else
        table.insert( self.value, value[ i ] )
      end
    end
    self:update_size()
  end
end

function chunk_template_element:get_value()
  local value = {}
  for i, v in ipairs( self.template ) do
    if type( v ) == "table" then
      table.insert( value, self.value[ i ]:get_value() )
    elseif v == "vector" then
      table.insert( value, vector():set( self.value[ i ] ) )
    elseif v == "time" then
      table.insert( value, game.CTime( self.value[ i ] ) )
    else
      table.insert( value, self.value[ i ] )
    end
  end
  return #value > 1 and value or value[ 1 ]
end

function chunk_template_element:data_size()
  local size = 0
  for i, v in ipairs( self.template ) do
    if type( v ) == "table" then
      -- мы не сохраняем имя и тип, поэтому нужно вычесть 2 байта
      size = size + self.value[ i ].size - 2
    elseif v == "string" then
      size = size + self.value[ i ]:len() + 1
    else
      ASSERT( data_sizes[ v ], "data size not found: %s", v )
      size = size + data_sizes[ v ]
    end
  end
  return size
end

function chunk_template_element:header_size()
  return 0
end

if STORAGE_DBG then
  function chunk_template_element:get_string( ind )
    local s = { "{" } --Начало
	local end_res = ind and "\n"..ind.."}" or "\n}" --Конец
	local def_ind = "  " --Отступ от начала строки
	ind = ind and ind..def_ind or def_ind --Для каждой "таблицы внутри таблицы" отступ увеличивается в 2 раза
	--
    for i, v in ipairs( self.template ) do
      local str
      if type( v ) == "table" then
        str = self.value[ i ]:get_string( ind )
	    v   = v[ 1 ]
      elseif v == "vector" then
        local val = self.value[ i ]
        str = ("%9.3f, %9.3f, %9.3f"):format( val.x, val.y, val.z )
      elseif v == "time" then
        local val = self.value[ i ]
        str = val:timeToString( 3 ) .. " " .. val:dateToString( 0 )
      elseif v == "string" then
        str = "'"..self.value[ i ].."'"
      elseif v == "bool" then
        str = tostring( self.value[ i ] )
      else
        str = self.value[ i ]
      end
      table.insert( s, ("\n"..ind.."[%s] = (%s) %s,"):format( i, v, str ) )
    end
    return table.concat( s )..end_res
  end
else
  function chunk_template_element:get_string()
    return "[disabled for speed]"
  end
end

function chunk_template_element:read_value( r_packet )
  self.value = {}
  for i = 1, #self.template do
    local v = self.template[ i ]
    if type( v ) == "table" then
      local item = create_item( "", nil, unpack( v ) )
      item:read_value( r_packet )
      table.insert( self.value, item )
    elseif v == "array" then
      local item = create_item( "", nil, v )
      item:read_value( r_packet )
      self.template[ i ] = { v }
      table.insert( self.value, item )
    elseif v == "array_template" then
      local item = create_item( "", nil, v )
      item:read_value( r_packet )
      self.template[ i ] = { v, item.template }
      table.insert( self.value, item )
    elseif v == "string" then
      table.insert( self.value, r_packet:r_stringZ() )
    elseif v == "vector" then
      table.insert( self.value, r_packet:r_vec3() )
    elseif v == "time" then
      table.insert( self.value, r_packet:r_CTime_ex() )
    else
      ASSERT( r_packet[ "r_" .. v ], "read function not found: %s", v )
      table.insert( self.value, r_packet[ "r_" .. v ]( r_packet ) )
    end
  end
  self:update_size()
  return self.value
end

function chunk_template_element:write_value( w_packet )
  for i, v in ipairs( self.template ) do
    if type( v ) == "table" then
      self.value[ i ]:write_value( w_packet )
    elseif v == "string" then
      w_packet:w_stringZ( self.value[ i ] )
    elseif v == "vector" then
      w_packet:w_vec3( self.value[ i ] )
    elseif v == "time" then
      w_packet:w_CTime_ex( self.value[ i ] )
    else
      ASSERT( w_packet[ "r_" .. v ], "write function not found: %s", v )
      w_packet[ "w_" .. v ]( w_packet, self.value[ i ] )
    end
  end
end


class "array_template_element" ( array_element )
function array_template_element:__init( name, value, template )
  self.name     = name
  self.template = template
  self.type     = types.array_template
  if value then
    self.value = {}
    for _, v in ipairs( value ) do
      table.insert(
        self.value, chunk_template_element( self.template, v )
      )
    end
    self:update_size()
  end
end

if STORAGE_DBG then
  function array_template_element:get_string( ind )
    local s = { "{" } --Начало
	local end_res = ind and "\n"..ind.."}" or "\n}" --Конец
	local def_ind = "  " --Отступ от начала строки
	ind = ind and ind..def_ind or def_ind --Для каждой "таблицы внутри таблицы" отступ увеличивается в 2 раза
	--
    for i, v in ipairs( self.value ) do
      table.insert( s, ('\n'..ind..'[%s] = %s,'):format( i, v:get_string( ind ) ) )
    end
    return table.concat( s )..end_res
  end
else
  function array_template_element:get_string()
    return "[disabled for speed]"
  end
end

function array_template_element:read_value( r_packet )
  local type_names = {}
  for name, id in pairs( types ) do
    type_names[ id ] = name
  end
  self.template = {}
  local count = r_packet:r_u16()
  for i = 1, count do
    local typ = r_packet:r_u8()
    ASSERT( typ, "unknown template type: %s", typ )
    table.insert( self.template, type_names[ typ ] )
  end
  self.value = {}
  count = r_packet:r_u16()
  for i = 1, count do
    local pos1 = r_packet:r_tell()
    local item = chunk_template_element( self.template )
    item:read_value( r_packet )
    local pos2 = r_packet:r_tell()
    ASSERT(
      pos2 - pos1 == item.size,
      "[array_template_element:read_value]: item reported size is different from actually readed data: value = %s item.size = %s readed = %s",
      item:get_string(), item.size, ( pos2 - pos1 )
    )
    table.insert( self.value, item )
  end
  self:update_size()
  return self.value
end

function array_template_element:write_value( w_packet )
  w_packet:w_u16( #self.template )
  for _, v in ipairs( self.template ) do
    if type( v ) == "table" then
      v = v[ 1 ]
    end
    ASSERT( types[ v ], "unknown template type: %s", v )
    w_packet:w_u8( types[ v ] )
  end
  w_packet:w_u16( #self.value )
  for _, item in ipairs( self.value ) do
    local pos1 = w_packet:w_tell()
    item:write_value( w_packet )
    local pos2 = w_packet:w_tell()
    ASSERT(
      pos2 - pos1 == item.size,
      "[array_template_element:write_value]: item reported size is different from actually written data: value = %s item.size = %s written = %s",
      item:get_string(), item.size, ( pos2 - pos1 )
    )
  end
end

function array_template_element:data_size()
  local sz = 4 + #self.template
  for i, v in ipairs( self.value ) do
    sz = sz + v.size
  end
  return sz
end

function array_template_element:fragment_value( max_size )
  local fragments     = {}
  local max_value_len = max_size - self:header_size() - ( 4 + #self.template )
  local tmp, sz       = {}, 0
  local check_sz      = 0
  for i, v in ipairs( self.value ) do
    if sz + v.size > max_value_len then
      local t = {}
      for _, v2 in ipairs( tmp ) do
        table.insert( t, v2:get_value() )
      end
      table.insert(
        fragments, array_template_element( self.name, t, self.template )
      )
      check_sz = check_sz + sz
      tmp, sz  = { v }, v.size
    else
      table.insert( tmp, v )
      sz = sz + v.size
    end
  end
  if #tmp > 0 then
    local t = {}
    for _, v2 in ipairs( tmp ) do
      table.insert( t, v2:get_value() )
    end
    table.insert(
      fragments, array_template_element( self.name, t, self.template )
    )
    check_sz = check_sz + sz
  end
  --ASSERT(
  --  check_sz + ( 4 + #self.template ) == self:data_size(),
  --  "wrong check_sz: %s, %s, %s",
  --  check_sz, #self.template, self:data_size()
  --)
  return fragments
end


item_types_registry = {
  [ types.string ] = this.string_element,
  [ types.number ] = this.general_number,
  [ types.bool   ] = this.bool_element,
  [ types.float  ] = this.float_element,
  [ types.vector ] = this.vector_element,
  [ types.u8     ] = this.u8_element,
  [ types.s8     ] = this.s8_element,
  [ types.u16    ] = this.u16_element,
  [ types.s16    ] = this.s16_element,
  [ types.u32    ] = this.u32_element,
  [ types.s32    ] = this.s32_element,
  [ types.time   ] = this.time_element,
  [ types.array  ] = this.array_element,
  [ types.table  ] = this.table_element,
  [ types.chunk  ] = this.chunk_element,
  [ types.array_template ] = this.array_template_element,
}


--------------| Публичный интерфейс модуля |------------------------------------

function value_exist( name )
  return ( storage[ name ] ~= nil )
end


function set_value( name, value, ... )
  ASSERT( ready, "ogse_unist.set_value: storage is not yet ready" )
  ASSERT( value ~= nil, "ogse_unist.set_value: trying set nil value for variable with name [%s]", name ) --nil в любом случае сохранять запрещено
  -- сначала в любом случае удаляем старое значение, если было
  if value_exist( name ) then
    remove_value( name )
  end
  -- создаём элемент
  local item = create_item( name, value, ... )
  -- сохраняем в глобальном хранилище
  storage[ item.name ] = item
end


function get_value( name, default_value, ... )
  ASSERT( ready, "ogse_unist.get_value: storage is not yet ready" )
  local item = storage[ name ]
  if not item then
    if default_value ~= nil then -- может быть равно false
      set_value( name, default_value, ... )
      return default_value
    end
    abort( "get_value: neither value [%s] is exist, nor default value is provided", name )
  end
  return item:get_value()
end


-- в случае, если не существует, просто вернуть nil
function get_value_safe( name )
  ASSERT( ready, "ogse_unist.get_value: storage is not yet ready" )
  local item = storage[ name ]
  if item then
    return item:get_value()
  end
  return nil
end


function remove_value( name )
  ASSERT( ready, "ogse_unist.remove_value: storage is not yet ready" )
  local item = storage[ name ]
  if not item then
    -- надо подумать, насколько это безобидная ситуация
    -- пока ставлю просто игнор
    return
    -- но возможно стоит поставить вылет
    -- abort("ogse_unist.remove_value: trying to remove nonexistent value '%s'", name)
  end
  -- удалить значение из общего хранилища
  storage[ name ] = nil
end


function set_or_remove_value( name, value, ... )
  if value then
    set_value( name, value, ... )
  else
    remove_value( name )
  end
end


function get_all_names()
  local names = {}
  for k, _ in pairs( storage ) do
    table.insert( names, k )
  end
  return names
end
