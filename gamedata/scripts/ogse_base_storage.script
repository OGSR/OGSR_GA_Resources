-- -*- mode: lua; coding: windows-1251-dos -*-
-------------------------------------------------------------------------------
--| ogse_base_storage.script                                                |--
--| Subsystem for creating base auxiliary objects for storing arbitrary     |--
--| user data                                                               |--
--| Malandrinus, OGS Evolution Team, 2011                                   |--
--| version 1.0                                                             |--
-------------------------------------------------------------------------------

-- модуль предоставляет сервис по созданию объектов, предназначенных для хранения произвольных данных
-- объекты имеют специальный класс (CUST_ST <-> clsid.custom_storage) и секцию 'custom_storage' 
-- и служат единственной цели хранить в них данные. Объекты создаются таким образом, чтобы никогда
-- не выходить в онлайн. Данные сохраняются в нетпакете серверного объекта.
-- данный модуль предоставляет только самый базовый сервис и является основой для построения 
-- более сложных систем.
-- Работа с объектами хранения происходит по следующему алгоритму.
-- 1. Запрашивается создание объекта-хранилища с помощью функции 
--    ogse_base_storage.get_storage(key)
--    здесь key - уникальный строковый идентификатор, однозначно соответствующий 
--    конкретному объекту-хранилищу. При первом получении объект создаётся невидимо 
--    для пользователя. При этом данный ключ записывается в кастомдату объекта. При дальнейших
--    обращениях к объекту-хранилищу он уже будет получаться из реестра по этому ключу.
--    Примечение: пользователь должен сам следить за тем, чтобы этот идентификатор был уникальным. 
--    В качестве идеи для надёжного обеспечения уникальности этих идентификаторов можно предложить 
--    использовать утилиту генерации GUID из состава Microsoft Visual Studio
-- 2. Для записи данных в объект надо получить из него специально подготовленный нетпакет. для
--    этого есть метод storage_object:w_reset(). Данный метод возвращает ссылку на нетпакет, 
--    в котором позиция записи установлена в то-же пололжение, что и начало свободной области в
--    самом объекте-хранилище. После получения этого нетпакета надо записать в него свои данные,
--    используя стандартные методы записи класса net_packet. 
--    При сохранении игры, данные из этого нетпакета будут переписаны в объект и таким образом
--    будут сохранены.
-- 3. Для чтения данных надо получить тот-же специальный нетпакет, но уже настроенный на чтение.
--    Для этого есть метод storage_object:r_reset(), который вернёт нетпакет, в котором позиция 
--    чтения установлена в начало пользовательских данных, а позиция записи - в конец. Как и при 
--    записи, чтение осуществляется стандартными методами чтения класса net_packet. Достижение
--    конца данных определяется методом r_eof, который сам по себе просто определяет достижение или
--    превышение позиции чтения над позицией записи.
--
--    Пример возможной стратегии записи/чтения:
--    Пусть надо сохранить некие данные, к примеру строку. Допустим, эту строку использует
--    класс актора. В биндере актора в методе load (или net_spawn, или reinit, неважно, лишь бы
--    вызывался один раз в начале) делаем примерно так:
--    local st = ogse_base_storage.get_storage("external_actor_storage") -- получили (или создали) само хранилище
--    -- "external_actor_storage" - это выбранный нами идентификатор хранилища.
--    local pk = st:r_reset() -- получили нетпакет для чтения
--    if pk:r_eof() then -- если в нетпакете пусто, значит до этого ничего туда не записывали
--        self.str = "" -- читать нечего, как-то создаём строку
--    else
--        self.str = pk:r_stringZ() -- читаем строку из нетпакета
--        -- подразумевается, что если данные есть, то это именно коректная строка.
--        -- Целостность и корректность данных естественно должны обеспечиваться пользователем.
--    end
--
--    теперь строка присутствует в биндере актора, используем её, меняем и т.д.
--    для записи используем метод save того же биндера (или net_destroy, опять же неважно,
--    лишь бы вызывался один раз при сохранении):
--    local st = ogse_base_storage.get_storage("external_actor_storage") -- получили хранилище,
--    -- используя выбранный ранее идентификатор
--    local pk = st:w_reset() -- получили нетпакет на запись
--    pk:w_stringZ(self.str) -- записали туда строку
--    ...
--    всё, далее строка сама сохранится в объекте и в дальнейшем уже прочитается в коде выше.

local registry = {}

local function create_storage_object( key )
  local st_obj = alife():create( "custom_storage", vector(), 0, 0 )
  local pk = get_netpk( st_obj, 1 )
  ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", st_obj:name() )
  local data = pk:get()
  data.custom_data:setTable({ main = { key = key } })
  pk:set( data )
  -- никогда не выйдет в онлайн
  st_obj:can_switch_online( false )
  st_obj:can_switch_offline( true )
  registry[ key ] = st_obj
  return st_obj
end


function get_storage(key)
	local st_obj = registry[key]
	if not st_obj then
		st_obj = create_storage_object(key)
	end
	return st_obj
end

function storage_exist(key)
	return registry[key] ~= nil
end


-- Из-за отсутствия в классе нетпакета метода w_seek приходится имитировать его действие.
-- Ограничение данного метода - устанавливает позицию записи не менее, чем в 2.
-- Также заполняет все пространство до указанной позиции каким-либо значением, 
-- в данном случае 123. В данном случае это неважно, поскольку эта область не используется.
local function w_seek( packet, pos )
  -- устанавливаем позицию чтения в начало. Точнее не в начало, 
  packet:w_begin()
  while packet:w_tell() ~= pos do
    packet:w_u8( 123 )
  end
end


-- класс специального серверного объекта для хранения данных
class "se_custom_storage" ( cse_alife_dynamic_object )
function se_custom_storage:__init( section ) super( section )
  self.ready     = false
  self.st_packet = net_packet()
  self.zero_pos  = 0
end


-- получение нетпакета, подготовленного для записи в него данных
-- в нетпакете места будет ровно столько, сколько в самом объекте
-- (чтобы не было возможности записать больше, чем может хранить объект)
function se_custom_storage:w_reset()
  -- синхронизируем позицию записи служебного нетпакета с началом свободной
  -- области в нашем объекте
  w_seek( self.st_packet, self.zero_pos )
  self.ready = true
  return self.st_packet -- возвращаем подготовленный для записи нетпакет
end


-- получение пакета с данными, ранее сохранёнными в объекте
function se_custom_storage:r_reset()
  -- устанавливаем позицию чтения в начало наших данных
  self.st_packet:r_seek( self.zero_pos )
  return self.st_packet -- возвращаем подготовленный для чтения пакет
end


-- при загрузке игры каждый объект зарегистрирует себя в глобальном хранилище
-- свой идентификатор объект прочитает из своей же кастомдаты, где мы сохранили
-- его ранее в секции main с именем параметра key
function se_custom_storage:on_register()
  cse_alife_dynamic_object.on_register( self )
  local sini = self:spawn_ini()
  if sini:section_exist( "main" ) then
    ASSERT(
      sini:line_exist( "main", "key" ),
      "se_custom_storage:on_register: storage object found with uninitialized custom data. Section main exists, but has no 'key' parameter."
    )
    registry[ sini:r_string( "main", "key" ) ] = self
  end
end


-- при загрузке объекта его сохранённые данные будут прочитаны в специальный нетпакет
function se_custom_storage:STATE_Read( packet, size )
  cse_alife_dynamic_object.STATE_Read( self, packet, size )
  -- позиция в нетпакете, с которой можно записывать свои данные
  self.zero_pos = packet:r_tell()
  self:w_reset() -- готовим пакет под данные
  while not packet:r_eof() do -- читаем данные из объекта
    self.st_packet:w_u8( packet:r_u8() ) -- и сохраняем их в отдельном пакете
  end
  self.end_pos = packet:w_tell() -- сохраняем позицию конца данных
end


-- при сохранении объекта в него будут скопированы данные из специального пакете
function se_custom_storage:STATE_Write( packet )
  cse_alife_dynamic_object.STATE_Write( self, packet )
  if not self.ready then return end
  self:r_reset() -- готовим специальный пакет для чтения
  while not self.st_packet:r_eof() do
  -- переписываем из него данные в нетпакет объекта
    packet:w_u8( self.st_packet:r_u8() )
  end
end


function se_custom_storage:can_save() -- этот объект всегда будет сохраняться
  return true
end
