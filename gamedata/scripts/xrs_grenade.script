---- AI Additions ----
---- xStream, Rulix aka Bak ----
---- 10.10.2016

-- radius	- оверрайд
-- kamikazze - доступна для психов-камикадзе
-- cond - throw condition function(npc,target)
-- aff - affector function(grenade_obj,data)
local grenade_params = {
	grenade_f1 = {kamikazze = true},
	grenade_rgd5 = {kamikazze = true},
	["grenade_gd-05"] = {radius = 6, cond = function(npc,trg) return npc.health > 0.8 and IsStalker(trg) end},
--	grenade_light = {radius = 10, cond = function() local h = level.get_time_hours() return h <= 5 or h >= 23 end},
}

for section,params in pairs(grenade_params) do
	local ini = system_ini()
	if not params.radius then
		local br = ini:r_float(section,"blast_r")
		local fr = ini:r_float(section,"frags_r")
		local fc = ini:r_s32(section,"frags")
		params.radius = math.max(br,math.min(fc,fr))	-- если осколков мало, то бояться их особо не стоит
	end
	params.explode_time = ini:r_s32(section,"destroy_time")
	params.snd_checkout = rx_sound.dihud_sound(section,"snd_checkout")
end

local grenades = {}
local get_grenade = level.object_by_id
local grenade_slot = 3

local gr_ini = ini_file([[misc\ai_additions\grenadier.ltx]])
ASSERTX(gr_ini:section_exist('default'),"no gr_ini")
local forbidden_factions = rx_utils.parse_list(gr_ini,"main","forbidden_factions",true)
local forbidden_npcs = rx_utils.collect_sections(gr_ini,{"forbidden_npcs"},nil,true)
local attack_classes = rx_utils.collect_sections(gr_ini,{"attack_classes"},nil,true)

local check_prd = rx_utils.read_from_ini(gr_ini,"main","check_period",2000)
local grenade_min_dist = rx_utils.read_from_ini(gr_ini,"main","min_dist",10)
local grenade_max_dist = rx_utils.read_from_ini(gr_ini,"main","max_dist",60)
grenade_mark_dist = rx_utils.read_from_ini(gr_ini,"main","mark_dist",30)
local dispersion_base = 11
local min_throw_interval = 5000	-- интервал между бросками
local min_enemy_memory_time = 2800	-- через сколько можно начинать шугать гранатой скрывшегося врага
local mid_enemy_memory_time = 11000	-- пора проверить, есть ли там еще враг
local max_enemy_memory_time = 36000	-- а тут пора уже заканчивать

-- настройки спавна гранат
local spawn_period = rx_utils.read_from_ini(gr_ini,"main","spawn_period",50)*1000
local spawn_period_gd_factor = 0.15	-- в минус
local spawn_chance_base = 0.5
local spawn_chance_rank_factor = 0.5	-- в плюс
local max_grenade_num = rx_utils.read_from_ini(gr_ini,"main","max_grenade_num",2,3)

-- настройки mon_psyh
local psyh_comms = rx_utils.parse_list(gr_ini,"psyh","factions",true)
local psyh_chance = rx_utils.read_from_ini(gr_ini,"psyh","chance",0.1)
local psyh_actor_only = rx_utils.read_from_ini(gr_ini,"psyh","actor_only",true,0)
local psyh_init_dist = 30*30
local psyh_grenade_dist = 11

local attack_clsids = {}
for name,cls_id in pairs(rx_utils.creatures_clslist) do
	attack_clsids[cls_id] = attack_classes[name]
end
attack_classes = nil

local profiles = {}
local function read_profile(section)
	if not gr_ini:section_exist(section) or gr_ini:line_count(section) == 0 then
		return profiles.default
	end
	if not profiles[section] then
		profiles[section] = {
		throw = gr_ini:r_bool(section,"throw"),
		evasion = gr_ini:r_bool(section,"evasion"),
		spawn_grenades = gr_ini:r_string(section,"spawn_grenades") or "",
		}
		local tmp,t,rnd = rx_utils.str_explode(",",profiles[section].spawn_grenades),{},0
		for _,v in ipairs(tmp) do
			local p = string.find(v,":",1,true)
			ASSERTX(p,"xrs_grenade: incorrect value spawn_grenades in %s",section)
			local gr = string.sub(v,1,p-1)
			ASSERTX(grenade_params[gr],"xrs_grenade: not registered grenade %s in %s",gr,section)
			t[gr] = tonumber(string.sub(v,p+1,-1))/100
			rnd = rnd + t[gr]
		end
		ASSERTX(rnd <= 100,"xrs_grenade: spawn chance sum > 100 in %s",section)
		profiles[section].spawn_grenades = t
	end
	return profiles[section]
end
read_profile('default')

function printf(s, ...)
--	rx_utils.printf("gre:"..s,...)
--	get_console():execute("flush")
end
----------------------------------------------------------------------------------------------------------------------
-- EVALUATORS
----------------------------------------------------------------------------------------------------------------------

class "evaluator_crazy_grenadier" (property_evaluator)
function evaluator_crazy_grenadier:__init(npc, name, storage, planner) super (nil, name)
	self.a = storage
	self.a.next_check_time = time_global()+math.random(4000,12000)
	self.a.throwing = false
	self.a.rank = rx_utils.rank_unit*npc:character_rank()
	self.disp = 2+math.max(1-self.a.rank,0)*dispersion_base
	self.planner = planner
	self.max_dist = grenade_max_dist*0.5+grenade_max_dist*0.5*math.min(self.a.rank,1)
	self.spawn_update_time = self.a.next_check_time+spawn_period*0.5
	rx_ai.subscribe_for_events(npc,self)
end
function evaluator_crazy_grenadier:evaluate()
	local npc = self.object

	if self.a.throwing then
		local be = npc:best_enemy()
		local enemy_wounded = be and xr_wounded.is_wounded(be) and (not rx_kill_wounded or self.storage:property(rx_kill_wounded.evid_enemy_wounded))
		if self.a.psyh_action or not be or enemy_wounded or npc:critically_wounded() or self.action_time < time_global() and self.planner:current_action_id() ~= actid_crazy_fire_in_the_hole then
			self.a.next_check_time = time_global() + check_prd*2
			self.a.throwing = false
			return false
		end
		return true
	end

	if not self.a.throw_enabled then
		return false
	end

	if self.testing then
		local testres,pos = self:update_test()
		if testres ~= nil then
			self.a.result_pos = pos
			self.a.throwing = testres
			self.action_time = testres and time_global()+3000 or nil	-- на переход к действию только 3 секунды, не успел - начинай сначала
			if grenades[self.test_grenade] then
				grenades[self.test_grenade].time = -1
			end
			self.test_grenade = nil
			self.testing = false
			self.a.next_check_time = time_global() + check_prd
			self.wait_for_online = nil
		end
		return false
	end

	local tg = time_global()
	if self.a.next_check_time > tg then
		return false
	end
	self.a.next_check_time = tg + check_prd

	local be = npc:best_enemy()
	if not be then
		spawn_grenade(self)
		self.a.next_check_time = tg + math.random(10000,50000)	-- случайная задержка от начала боя
		return false
	end

	if npc:critically_wounded() or xr_wounded.is_wounded(npc) or self.a.psyh_action then
		return false
	end

	if not attack_clsids[be:clsid()] or xr_wounded.is_wounded(be) then
		self.a.next_check_time = tg + check_prd*2
		return false
	end

	-- определим цель
	local see,memory_time,target_pos = npc:see(be)
	if IsStalker(be) then
		-- одна ячейка памяти
		if see then
			self.memory_id = be:id()
			self.memory_time = tg
			self.memory_pos = be:position()
			return false
		elseif self.memory_id == be:id() and tg-self.memory_time < min_enemy_memory_time then
			return false
		end
		memory_time = tg-npc:memory_time(be)
		if memory_time < 0 then
			-- подключить индивидуальную память
			if self.memory_id == be:id() then
				target_pos = self.memory_pos
				memory_time = tg-self.memory_time
			else
				memory_time = max_enemy_memory_time
--				return false
			end
		end
		if memory_time >= max_enemy_memory_time then
			return false
		end
		if npc:movement_type() == move.run and npc:mental_state() ~= anim.panic then
			return false
		end
	elseif not see then
		return false
	end
	local target_pos = target_pos or see and be:position() or npc:memory_position(be)
	-- выберем из имеющихся гранат нужную
	local avail_grenades = {}
	for sect,t in pairs(grenade_params) do
		local gr = npc:object(sect)
		if gr and (t.cond == nil or t.cond(npc,be)) then
			table.insert(avail_grenades,sect)
		end
	end
	if #avail_grenades < 1 then
		spawn_grenade(self)
		return false
	end
--	table.sort(avail_grenades,function(a,b) return grenade_params[a].radius > grenade_params[b].radius end)
	local choosen = avail_grenades[math.random(#avail_grenades)]
	-- проверим расстояние
	local npc_pos = npc:position()
	local dist = npc_pos:distance_to(target_pos)
	if dist > self.max_dist or dist < grenade_min_dist then
		self.a.next_check_time = tg + check_prd*2
		return false
	end

	if not npc:throw_target( target_pos, be ) then
		return false
	end

	-- выберем точку
	local dev = self.disp*(dist+90)
--	local pp = vector():set(target_pos)
	target_pos:add(vector():set(math.random(-dev,dev)*0.01,math.random(-dev,dev)*0.004,math.random(-dev,dev)*0.01))
	-- эй, есть там кто
	local radius = grenade_params[choosen].radius+1
	if not check_victims(npc,npc_pos,target_pos,radius,not see and memory_time>mid_enemy_memory_time and dev*0.01<radius) then	--,memory_time>mid_enemy_memory_time and dev*0.01<radius
		return false
	end
	--можно швыряться - вероятность никого не задеть (кроме врагов) достаточно велика
	self.a.from_vert = npc:level_vertex_id()
	self.a.from_pos = npc_pos
	self.a.target_point = target_pos
	self.a.grenade = choosen
	local from_dir = vector():sub(self.a.target_point,self.a.from_pos):normalize()
	self.a.grenades_from_pos = npc:bone_position("bip01_head"):add(from_dir:div(3))

	local obj = create_grenade(choosen.."_test", self.a.grenades_from_pos, npc:level_vertex_id(), npc:game_vertex_id())
	level.client_spawn_manager():add(obj.id,-1,throw,self.a)
	self.a.grenade_data = {time = 3000,section = choosen,test = true}
	self.wait_for_online = tg+600
	self.a.throwing_type = tg%3
	self.a.crouch = npc:body_state() == move.crouch
	self.test_grenade = obj.id
	self.a.test_end_time = nil
	self.testing = true
	if ui_grenade_marks then
		self.a.mark = be:id() == 0 and 'red' or npc:relation(db.actor) ~= game_object.enemy and 'green' or nil
	end
	return false
end
function evaluator_crazy_grenadier:death_callback()
	if self.test_grenade and grenades[self.test_grenade] then
		grenades[self.test_grenade].time = -1
		self.test_grenade = nil
	end
end

function evaluator_crazy_grenadier:update_test()
	local id = self.test_grenade
	local npc,st = self.object,self.a
	local sobj = alife():object(id)
	if not sobj then
		printf("[%s]test:fail sobj[%s], obj %s",npc:name(),id,get_grenade(id))
		return false
	end
	local obj = id and get_grenade(id)
	if not obj then
		if self.wait_for_online > time_global() then
			return
		end
		printf("[%s]test:fail obj %s (%s)",npc:character_name(),id,sobj)
		return false
	end
	if not grenades[id] then
		printf("[%s]fail grenades[%s]",self.object:name(),id)
		return false
	end
	if obj:parent() then
		printf("[%s]test:fail [%s] parent %s",npc:name(),obj:name(),obj:parent():name())
		return false
	end
	if not self.a.test_end_time then
		self.a.test_end_time = time_global() + grenade_params[grenades[id].section].explode_time
	end
	local ps,vel = obj:get_physics_shell(),vector()
	ps:get_linear_vel(vel)
	if st.test_end_time < time_global() or vel:magnitude() < 0.1 then
		local pos = obj:position()
		local radius = grenade_params[grenades[id].section].radius
		if npc:object(st.grenade) and pos:distance_to(st.target_point) < radius and check_victims(npc,st.from_pos,pos,radius,math.random()<0.5) then
			return true,pos
		end
		return false
	end
end

class "evaluator_aaa_grenade" (property_evaluator)
function evaluator_aaa_grenade:__init(npc, name, storage) super (nil, name)
	self.a = storage
end
function evaluator_aaa_grenade:evaluate()
	if not self.a.evasion_enabled then
		return false
	end
	local npc,tg = self.object,time_global()
	if npc:critically_wounded() then
		return false
	end
	if self.danger_inert and self.danger_inert > tg then
		return true
	end
	if not npc:best_enemy() and db.storage[npc:id()].active_scheme == "remark" then
		return false
	end
	local npc_pos
	for k,v in pairs(grenades) do
		if not v.test and v.time > tg+200 then
			local grenade = get_grenade(k)
			if grenade then
				npc_pos = npc_pos or npc:position()
				local gdist = grenade:position():distance_to(npc_pos)
				if gdist < 25 then
					local radius = grenade_params[v.section].radius+2
					local who = v.initiator and get_grenade(v.initiator)
					if who and npc:relation(who) ~= game_object.enemy then	-- "своя" граната
						if gdist < radius then
							local vel = vector()
							grenade:get_physics_shell():get_linear_vel(vel)
							if vel:magnitude() < 5 then
								self.a.danger = grenade:position():add(vel)
								self.a.danger_r = radius
								self.a.danger_id = grenade:id()
								self.a.danger_friendly = v.initiator ~= npc:id()
								self.last_danger_time = tg
								return true
							end
						end
					else
						if gdist < radius then
							self.a.danger = grenade:position()	--v.target
							self.a.danger_r = radius
							self.a.danger_id = grenade:id()
							self.a.danger_friendly = nil
							self.last_danger_time = tg
							return true
						elseif npc:see(grenade) and v.target:distance_to(npc_pos) < radius then
							self.a.danger = v.target
							self.a.danger_r = radius
							self.a.danger_id = grenade:id()
							self.a.danger_friendly = nil
							self.last_danger_time = tg
							return true
						end
					end
				end
			end
		end
	end
	if (self.last_danger_time or 0)+1000 > tg then
		if npc:position():distance_to(self.a.danger) < self.a.danger_r then
			self.danger_inert = tg+1500
			return true
		end
		self.a.danger = nil
		self.a.danger_r = nil
		self.last_danger_time = nil
	end
	return false
end

class "evaluator_psyh" (property_evaluator)
function evaluator_psyh:__init(npc, name, storage) super (nil, name)
	self.a = storage
	self.a.psyh_active = rx_ai.get_var(npc,"gr_psyh",nil)
	if self.a.psyh_active == nil then
		self.a.psyh_active = rx_ai.save_var(npc,"gr_psyh",math.random() < psyh_chance)	-- and not rx_utils.is_story_object(npc)
	end
	self.rand_time = math.random(4000,6000)
	self.a.psyh_delay = time_global()+10000
end
function evaluator_psyh:evaluate()
	if not self.a.psyh_active then
		return false
	end
	local npc = self.object
	if self.a.psyh_delay > time_global() then
		return false
	end
	local enemy = npc:best_enemy()
	if not enemy then
		self.a.psyh_delay = time_global() + 4200
		return false
	end
	if self.a.psyh_action then
		return true
	end
	self.a.psyh_delay = time_global() + self.rand_time
	if not (IsStalker(enemy) and (not psyh_actor_only or rx_utils.is_actor(enemy))) then
		return false
	end
	local time = time_global()-npc:memory_time(enemy)
	if time < 5000 and time >= 0 and npc:position():distance_to_sqr(npc:memory_position(enemy)) < psyh_init_dist then
		if not (self.a.psyh_grenade and npc:object(self.a.psyh_grenade)) then
			local avail_grenades = {}
			for sect,t in pairs(grenade_params) do
				local gr = npc:object(sect)
				if gr and t.kamikazze then
					table.insert(avail_grenades,sect)
				end
			end
			if #avail_grenades < 1 then
				return false
			end
			table.sort(avail_grenades,function(a,b) return grenade_params[a].radius > grenade_params[b].radius end)
			self.a.psyh_grenade = avail_grenades[1]
		end
		local lvid = enemy:level_vertex_id()
		if not npc:accessible(lvid) or level.vertex_position(lvid):distance_to_sqr(enemy:position()) > 4 then
			return false
		end
		self.a.psyh_delay = -1
--		self.a.psyh_target = enemy:id()
		return true
	end
	return false
end

----------------------------------------------------------------------------------------------------------------------
-- ACTIONS
----------------------------------------------------------------------------------------------------------------------

class "action_fire_in_the_hole" (action_base)
function action_fire_in_the_hole:__init (npc,action_name,storage) super (nil,action_name)
	self.a = storage
	self.aim_time = math.max(0, (1000 + math.random(2000)) / (1 + level.get_game_difficulty()) - 500 )
end
function action_fire_in_the_hole:initialize()
	action_base.initialize(self)
	self.at_pos = false
	self.begin_throw = false
	self.throw_end = false
	self.finalized = false
	self.act_grenade = nil
	self.time_back_to_pos = time_global()+5000

	local npc = self.object
	local wm = npc:get_wm(true)
	if wm then
		wm:disable()
	end
	state_mgr.lock(npc,true)
	npc:set_item(object.idle,npc:active_item())
	npc:set_desired_position()
	npc:set_desired_direction()
	npc:set_movement_type(move.run)
	npc:set_mental_state(anim.danger)
	npc:set_body_state(self.a.crouch and move.crouch or move.standing)
	npc:set_path_type(game_object.level_path)
	npc:clear_animations()
	rx_ai.subscribe_for_events(npc,self)
end
function action_fire_in_the_hole:execute()
	action_base.execute(self)
	if self.a.throwing == false then
		return
	end
	local npc = self.object

	if self.finalized then
		if npc:animation_count() == 0 then
			self.a.throwing = false
		end
		return
	end

	local grenade = self.a.grenade and npc:object(self.a.grenade)
	if not grenade then
		self.a.throwing = false
		return
	end

	npc:set_mental_state(anim.danger)
	local tg = time_global()

	if not self.at_pos then
		local npc_pos = npc:position()
		local dist = self.a.from_pos:distance_to(npc_pos)
		local active_item = npc:active_item()
		if dist < 2.4 then
			npc:set_sight(look.fire_point,self.a.target_point)
			npc:set_item(object.idle,nil)
			if not (self.act_grenade or active_item) then
				npc:play_cycle(self.a.crouch and "cr_torso_7_draw_0" or "norm_torso_7_draw_0")	-- mixin
				grenade:enable_attachable_item(true)
				self.act_grenade = grenade:id()
			end
			if not self.sound then
				self.sound = rx_sound.set_sound_play(npc:id(),"grenade_ready",nil,true)
			end
		else
			local be = npc:best_enemy()
			if be and npc:see(be) then
				if IsStalker(be) and be:see(npc) then
					self.a.throwing = false
					return
				end
				npc:set_sight(be,true,true)
				if active_item and rx_utils.item_is_fa(active_item) then
					if rx_ff and self.storage:property(rx_ff.evid_dont_shoot) then
						npc:set_item(object.aim1,active_item)
					else
						action_base.fire_(npc,active_item,npc_pos:distance_to(be:position()))
					end
				end
			elseif be and be:id()%2 == 0 then
				npc:set_sight(look.fire_point,self.a.target_point)
			else
				npc:set_sight(look.path_dir,nil,0)
			end
		end
		if tg > self.time_back_to_pos then
			self.a.throwing = false
			return
		end
		if (npc:path_completed() or dist < 0.5) and self.act_grenade then

			if not check_victims(npc,npc_pos,self.a.result_pos,grenade_params[self.a.grenade].radius) then
				self.a.throwing = false
				self.a.target_point = nil
				self.finalized = true
				return
			end

			local animtime1,animtime2,armtime
			npc:set_movement_type(move.stand)
			npc:clear_animations()
			if self.a.from_pos:distance_to(self.a.target_point) < grenade_max_dist*0.65 then
				if self.a.crouch then
					animtime1,animtime2,armtime = 1200,250,900
					npc:add_animation("cr_all_7_attack_0")
					npc:add_animation("cr_all_7_attack_1")
					npc:add_animation("cr_all_7_attack_1")
					npc:add_animation("cr_all_7_attack_1")
				else
					animtime1,animtime2,armtime = 1100,250,800
					npc:add_animation("norm_all_7_attack_0")
					npc:add_animation("norm_all_7_attack_1")
					npc:add_animation("norm_all_7_attack_1")
					npc:add_animation("norm_all_7_attack_1")
				end
				self.anim = 0
			else
				if self.a.crouch then
					animtime1,animtime2,armtime = 300,600,250
					npc:add_animation("cr_all_6_attack_0")
					npc:add_animation("cr_all_6_attack_1")
					npc:add_animation("cr_all_6_attack_1")
					npc:add_animation("cr_all_6_attack_1")
				else
					animtime1,animtime2,armtime = 300,500,250
					npc:add_animation("norm_all_6_attack_0")
					npc:add_animation("norm_all_6_attack_1")
					npc:add_animation("norm_all_6_attack_1")
					npc:add_animation("norm_all_6_attack_1")
				end
				self.anim = 1
			end

			self.throw_time = tg + animtime1 + self.aim_time
			self.end_time = self.throw_time + animtime2
			self.armed_time = tg + armtime

			self.at_pos = true
			return
		end
		npc:set_movement_type(move.run)
		npc:set_dest_level_vertex_id(self.a.from_vert)
		npc:set_desired_position(self.a.from_pos)
		return
	end

	npc:set_sight(look.point,self.a.target_point)

	if not self.sound_co and tg > self.armed_time-300 then
		grenade_params[self.a.grenade].snd_checkout:play(npc,grenade:position(),0,2.0)
		self.sound_co = true
	end

	if tg > self.throw_time and not self.begin_throw then
		npc:clear_animations()
		if self.a.crouch then
			npc:add_animation(self.anim == 1 and "cr_all_6_attack_2" or "cr_all_7_attack_2")
		else
			npc:add_animation(self.anim == 1 and "norm_all_6_attack_2" or "norm_all_7_attack_2")
		end
		self.begin_throw = true
		self.sound = nil
		return
	end

	if tg > self.end_time then
		local obj = create_grenade(grenade:section().."_fake",self.a.grenades_from_pos,npc:level_vertex_id(),npc:game_vertex_id())
		level.client_spawn_manager():add(obj.id,-1,throw,self.a)
		self.a.grenade_data = {section = grenade:section(),initiator = npc:id(),target = self.a.result_pos}
		local sgren = alife():object(grenade:id())
		if sgren then
			alife():release(sgren)
		end
		self.a.grenade = nil
		self.act_grenade = nil
		self.a.next_check_time = tg + min_throw_interval
		self.finalized = true
	end
end
function action_fire_in_the_hole:finalize()
	action_base.finalize(self)
	self.armed_time = nil
	self.sound_co = nil
	local npc = self.object
	if not npc:alive() then
		return
	end
	if not self.begin_throw then
		npc:clear_animations()
	end
	local grenade = self.act_grenade and get_grenade(self.act_grenade)
	if grenade then
		npc:play_cycle(npc:body_state() == move.crouch and "cr_torso_6_holster_0" or "norm_torso_7_holster_0")
		grenade:set_fastcall(hide_grenade,{time_global()+400,grenade:id()})
	end
	if self.sound then
		rx_sound.stop_sounds(npc)
	end
	self.act_grenade = nil
	self.sound = nil
	rx_ai.unsubscribe_from_events(npc:id(),self)
	rx_sound.block_alarm_sound(npc)
	state_mgr.lock(npc,false)
	local wm = npc:get_wm(true)
	if wm then
		wm:enable()
	end
end
function action_fire_in_the_hole:hit_callback(amount,dir,who,bone_id)
	if self.finalized then
		return
	end
	local npc = self.object
	if not self.act_grenade then
		self.a.throwing = false
		self.a.next_check_time = time_global() + check_prd*3
		self.finalized = true
	elseif bone_id == 0 and math.random() < amount or bone_id >= 31 and bone_id <= 43 then
		local grenade = get_grenade(self.act_grenade)
		if grenade and grenade:parent() then
			npc:drop_item(grenade)
			if self.armed_time and self.armed_time < time_global() then
				grenade:set_fastcall(spoof_grenade,{time_global()+700,grenade:id(),grenade:name()})	--,self.armed_time-time_global(),who and who:id()
			end
		end
		self.a.throwing = false
		self.a.next_check_time = time_global() + min_throw_interval
		self.finalized = true
		self.act_grenade = nil
	elseif self.at_pos and not self.begin_throw then
		local et = self.throw_time - time_global()
		if et > 0 then
			self.throw_time = self.throw_time - et
			self.end_time = self.end_time - et
--			self.a.target_point:add(math.random(3,6))
		end
	end
end
function action_fire_in_the_hole:death_callback()
	local grenade = self.act_grenade and get_grenade(self.act_grenade)
	if grenade and grenade:parent() then
		local npc = self.object
		if not self.finalized and self.armed_time and self.armed_time < time_global() then
			local obj = create_grenade(grenade:section().."_fake",npc:bone_position("bip01_r_hand"),npc:level_vertex_id(),npc:game_vertex_id())
			local d = {section = grenade:section(),target = grenade:position()}
			level.client_spawn_manager():add(obj.id,-1,throw,{grenade_data = d})
			table.insert(rx_ai.ids_to_remove,self.act_grenade)
		end
	end
end


class "action_run_from_grenade" (action_base)
function action_run_from_grenade:__init (npc,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_run_from_grenade:initialize()
	action_base.initialize(self)
	self.a.throwing = false
	self.vid_time = 0
	local npc = self.object
	local wm = npc:get_wm(true)
	if wm then
		wm:disable()
	end
	state_mgr.lock(npc,true,true)
	rx_sound.set_sound_play(npc:id(),self.a.danger_friendly and "friendly_grenade" or "grenade_alarm",nil,0)
	if npc:weapon_unstrapped() then
		npc:set_item(object.idle,rx_utils.get_weapon(npc))
	end
	npc:set_desired_position()
	npc:set_desired_direction()
	npc:set_movement_type(move.run)
	npc:set_mental_state(anim.danger)
	npc:set_path_type(game_object.level_path)
	npc:clear_animations()
	rx_ai.subscribe_for_events(npc,self)
end
function action_run_from_grenade:execute()
	action_base.execute (self)
	if not self.a.danger then
		return
	end
	local npc = self.object

	if self.a.danger_id ~= self.id then
		self.id = self.a.danger_id
		self.vid = nil
	end

	local npc_pos,dvert = npc:position()
	local dist = npc_pos:distance_to(self.a.danger)
	if self.vid and self.vid_time > time_global() then
		dvert = self.vid
	else
		local cover = npc:best_cover(npc_pos, self.a.danger, 18, math.min(10,self.a.danger_r), 170)
		if cover and npc:accessible(cover:level_vertex_id()) and (cover:position():distance_to(self.a.danger) > self.a.danger_r or cover:position():distance_to(npc_pos) < dist) then
			dvert = cover:level_vertex_id()
		else
			local npc_lvid = npc:level_vertex_id()
			local best_dist = 0
			local dir = vector():sub(npc_pos,self.a.danger):normalize()
			for i,a in ipairs({0,15,-15,30,-30,50,-50,70,-70,90,-90,110,-110}) do
				local ndir = vector_rotate_y(dir,a)
				local vert = npc:vertex_in_direction(npc_lvid,ndir,30)
				local ndist = level.vertex_position(vert):distance_to(self.a.danger)
				if ndist > best_dist then
					best_dist = ndist
					dvert = vert
					if ndist > self.a.danger_r+dist then
						break
					end
				end
			end
		end
		self.vid = dvert
		self.vid_time = time_global() + 4500
	end

	if self.fix_hit then
		self.fix_hit = nil
		return
	end

	npc:set_movement_type(move.run)
	if dvert and dist < self.a.danger_r*0.6 then
		npc:set_dest_level_vertex_id(dvert)
		if npc:path_completed() then
			npc:set_mental_state(anim.danger)
			npc:set_body_state(move.crouch)
		else
			npc:set_mental_state(anim.panic)
			npc:set_sight(look.path_dir,nil,0)
		end
		return
	end

	npc:set_mental_state(anim.danger)
	if dvert then
		npc:set_dest_level_vertex_id(dvert)
	else
		npc:set_dest_level_vertex_id(npc:level_vertex_id())
		npc:set_desired_position(npc_pos)
	end

	local be = npc:best_enemy()
	if be then
		if npc:see(be) then
			npc:set_sight(be,true,true)
			if rx_ff and self.storage:property(rx_ff.evid_dont_shoot) then
				npc:set_item(object.aim1,npc:active_item())
			else
				action_base.fire_(npc,npc:active_item(),npc_pos:distance_to(be:position()))
			end
		else
			if npc:path_completed() then
				npc:set_sight(look.point,npc:memory_position(be),true)
			else
				npc:set_sight(look.path_dir,nil,0)
			end
			npc:set_item(object.idle,npc:active_item())
		end
	elseif npc:weapon_unstrapped() then
		npc:set_item(object.idle,npc:active_item())
	end

	if npc:path_completed() then
		npc:set_body_state(move.crouch)
--		npc:set_movement_type(move.stand)
	end
end
function action_run_from_grenade:finalize()
	action_base.finalize(self)
	self.id = nil
	self.fix_hit = nil
	local npc = self.object
	if not npc:alive() then
		return
	end
	npc:set_movement_type(move.walk)
	npc:set_mental_state(anim.danger)
	npc:set_item(object.idle,npc:active_item())
	rx_sound.block_alarm_sound(npc)
	rx_ai.unsubscribe_from_events(npc:id(),self)
	state_mgr.lock(npc,false)
	local wm = npc:get_wm(true)
	if wm then
		wm:enable()
	end
end
function action_run_from_grenade:hit_callback(amount,dir,who,bone_id)
	if bone_id > 0 or amount < 0.05 then
		return
	end
	local npc = self.object
	if math.random() < amount+0.1 then
		rx_ai.play_animation(npc,{animation = "wounded_2_out",weapon = object.drop,sound_theme = 'npc_hit',mental = anim.danger})
		return
	end
	npc:set_mental_state(anim.danger)
	npc:set_movement_type(move.stand)
	self.fix_hit = true
end


class "action_psyh" (action_base)
function action_psyh:__init (npc,action_name,storage) super (nil,action_name)
	self.a = storage
end
function action_psyh:initialize()
	action_base.initialize(self)
	local npc = self.object
	local wm = npc:get_wm(true)
	if wm then
		wm:disable()
	end
	state_mgr.lock(npc,true,true)
	npc:set_desired_position()
	npc:set_desired_direction()
	npc:set_movement_type(move.run)
	npc:set_mental_state(anim.danger)
	npc:set_body_state(move.standing)
	npc:set_path_type(game_object.level_path)
	npc:clear_animations()
	self.a.psyh_action = true
	rx_ai.subscribe_for_events(npc,self)
end
function action_psyh:execute()
	action_base.execute(self)
	local npc = self.object
	local enemy = npc:best_enemy()
	if not enemy or xr_wounded.is_wounded(enemy) or not IsStalker(enemy) then
		self.a.psyh_action = nil
		self.a.psyh_delay = time_global()+5000
		return
	end
	local actual = time_global()-npc:memory_time(enemy) < 1000
	if not self.lvid or actual then
		self.lvid = enemy:level_vertex_id()
	end
	if not npc:accessible(self.lvid) or level.vertex_position(self.lvid):distance_to_sqr(enemy:position()) > 5 then
		self.a.psyh_action = nil
		self.a.psyh_delay = time_global()+2000
		return
	end
	local grenade = self.a.psyh_grenade and npc:object(self.a.psyh_grenade)
	if not grenade then
		self.a.psyh_grenade = nil
		self.a.psyh_action = nil
		self.a.psyh_delay = time_global()+1000
		return
	end

	local pos = npc:memory_position(enemy)
	local dist = npc:position():distance_to(pos)

	npc:set_dest_level_vertex_id(self.lvid)
	npc:set_desired_position(pos)

	if npc:path_completed() and npc:level_vertex_id() == self.lvid and not actual then
		self.a.psyh_action = nil
		self.a.psyh_delay = time_global()+6000
		return
	end

	if dist > psyh_grenade_dist then	-- сближение
		local wpn = rx_utils.get_weapon(npc)
		if npc:see(enemy) then
			npc:set_sight(enemy,true,true)
			action_base.fire_(npc,wpn,dist)
		else
			npc:set_sight(look.path_dir,nil,0)
			npc:set_item(object.idle,wpn)
		end
		npc:set_mental_state(anim.danger)
		self.armed_time = nil
		return
	end

	rx_sound.set_sound_play(npc:id(),"psyh_threat",nil,0)
	npc:set_sight(look.path_dir,nil,0)
	npc:set_item(object.idle,nil)
	if npc:active_item() == nil then
		npc:set_mental_state(anim.panic)
		grenade:enable_attachable_item(true)
		self.act_grenade = grenade:id()
	end

	if actual and not self.armed_time and dist < math.min(10,grenade_params[self.a.psyh_grenade].radius+1) then
		self.armed_time = time_global()
		grenade_params[self.a.psyh_grenade].snd_checkout:play(npc,grenade:position(),0,2.5)
	end

	if npc:see(enemy) and dist < 3 or npc:position():distance_to(enemy:position()) < 2.5 then
		if npc:id()%2 == 0 then
			npc:drop_item(grenade)
			if self.armed_time then
				grenade:set_fastcall(spoof_grenade,{time_global()+500,grenade:id(),grenade:name(),self.armed_time and self.armed_time-time_global()})
			end
			self.act_grenade = nil
			self.a.psyh_grenade = nil
			self.a.psyh_action = nil
			self.a.psyh_delay = time_global()+400
			return
		else
			npc:set_mental_state(anim.danger)
		end
	end

	if self.armed_time and time_global()-self.armed_time > grenade_params[self.a.psyh_grenade].explode_time then
		local obj = create_grenade(self.a.psyh_grenade.."_fake", npc:bone_position("bip01_r_hand"), npc:level_vertex_id(), npc:game_vertex_id())
		level.client_spawn_manager():add(obj.id,-1,explode,{section = self.a.psyh_grenade,initiator = npc:id()})
		local sgren = alife():object(grenade:id())
		if sgren then
			alife():release(sgren)
		end
		self.act_grenade = nil
		self.a.psyh_grenade = nil
		self.a.psyh_action = nil
		self.a.psyh_delay = time_global()+5000
	end
end
function action_psyh:finalize()
	action_base.finalize(self)
	local npc = self.object
	self.a.psyh_action = nil
	self.lvid = nil
	if not npc:alive() then
		return
	end
	local grenade = self.act_grenade and get_grenade(self.act_grenade)
	if grenade then
		grenade:enable_attachable_item(false)
		if self.armed_time then
			local enemy = npc:best_enemy()
			local pos = enemy and npc:memory_position(enemy)
			if pos and pos:distance_to(npc:position()) < 20 then
				local obj = create_grenade(grenade:section().."_fake",npc:bone_position("bip01_head"),npc:level_vertex_id(),npc:game_vertex_id())
				local d = {section = grenade:section(),target = pos,time = self.armed_time-time_global()}
				level.client_spawn_manager():add(obj.id,-1,throw,{grenade_data = d,throwing_type = 0,target_point = pos,mark = rx_utils.is_actor(enemy) and 'red' or nil})
				npc:play_cycle("norm_all_6_attack_2",true)
				table.insert(rx_ai.ids_to_remove,self.act_grenade)
			end
		end
	end
	self.act_grenade = nil
	self.armed_time = nil
	if self.a.psyh_delay <= time_global() then
		self.a.psyh_delay = time_global()+500
	end
	rx_ai.unsubscribe_from_events(npc:id(),self)
	rx_sound.block_alarm_sound(npc)
	state_mgr.lock(npc,false)
	local wm = npc:get_wm(true)
	if wm then
		wm:enable()
	end
end
function action_psyh:hit_callback(amount,dir,who,bone_id)
	if bone_id >= 31 and bone_id <= 43 then
		local grenade = self.act_grenade and get_grenade(self.act_grenade)
		if grenade and grenade:parent() then
			self.object:drop_item(grenade)
			if self.armed_time then
				grenade:set_fastcall(spoof_grenade,{time_global()+500,grenade:id(),grenade:name(),self.armed_time-time_global()})
			end
		end
		self.a.psyh_grenade = nil
		self.a.psyh_action = nil
		self.act_grenade = nil
	end
end
function action_psyh:death_callback()
	local grenade = self.act_grenade and get_grenade(self.act_grenade)
	if grenade and grenade:parent() then
		if self.armed_time then
			local npc = self.object
			local obj = create_grenade(grenade:section().."_fake",npc:bone_position("bip01_r_hand"),npc:level_vertex_id(),npc:game_vertex_id())
			local d = {section = grenade:section(),target = grenade:position(),time = self.armed_time-time_global()}
			level.client_spawn_manager():add(obj.id,-1,throw,{grenade_data = d,throwing_type = 4,target_point = npc:position():add(npc:direction():mul(4))})
			table.insert(rx_ai.ids_to_remove,self.act_grenade)
		end
	end
end

----------------------------------------------------------------------------------------------------------------------
-- BINDER
----------------------------------------------------------------------------------------------------------------------
evid_crazy_grenadier = 18670
evid_aaa_grenade = evid_crazy_grenadier + 1
evid_psyh = evid_aaa_grenade + 1

actid_crazy_fire_in_the_hole = evid_crazy_grenadier
actid_run_from_grenade = actid_crazy_fire_in_the_hole + 1
actid_psyh = actid_run_from_grenade + 1

rx_ai.reset_protected_actions[actid_crazy_fire_in_the_hole] = true
rx_ai.reset_protected_actions[actid_run_from_grenade] = true
rx_ai.reset_protected_actions[actid_psyh] = true
rx_ai.death_disable_evas[evid_crazy_grenadier] = false
rx_ai.death_disable_evas[evid_aaa_grenade] = false
rx_ai.death_disable_evas[evid_psyh] = false
if rx_knife then
	rx_knife.knife_actions_permitted[actid_run_from_grenade] = true
end

function add_to_binder(npc, ini, scheme, section, storage)
	local operators	= {}
	local properties  = {}
	local manager = npc:motivation_action_manager()

	operators["fire_in_the_hole"]			= actid_crazy_fire_in_the_hole
	operators["run_from_grenade"]			= actid_run_from_grenade
	operators["kamikazze"]					= actid_psyh

	properties["crazy_grenadier"]			= evid_crazy_grenadier
	properties["aaa_grenade"]				= evid_aaa_grenade
	properties["ya_psyh"]					= evid_psyh
	properties["state_mgr_off"]				= xr_evaluators_id.state_mgr+3


	local psyh = psyh_comms[npc:character_community()]

	if not (not forbidden_factions[npc:character_community()] and not forbidden_npcs[npc:name()] and not forbidden_npcs[npc:profile_name()] and npc:alive()) then
		manager:add_evaluator (properties["crazy_grenadier"], property_evaluator_const(false))
		manager:add_evaluator (properties["aaa_grenade"], property_evaluator_const(false))
		manager:add_evaluator (properties["ya_psyh"], property_evaluator_const(false))
		return
	else
		manager:add_evaluator (properties["crazy_grenadier"], evaluator_crazy_grenadier(npc, "crazy_grenadier", storage, manager))
		manager:add_evaluator (properties["aaa_grenade"], evaluator_aaa_grenade(npc, "aaa_grenade", storage))
		if psyh then
			manager:add_evaluator (properties["ya_psyh"], evaluator_psyh(npc, "aaa_grenade", storage))
		else
			manager:add_evaluator (properties["ya_psyh"], property_evaluator_const(false))
		end
	end

	local action = action_fire_in_the_hole (npc,"fire_in_the_hole", storage)
	action:add_precondition(world_property(stalker_ids.property_alive, true))
--	action:add_precondition(world_property(stalker_ids.property_critically_wounded, false))
	action:add_precondition(world_property(xr_evaluators_id.sidor_wounded_base, false))
	action:add_precondition	(world_property(properties["state_mgr_off"], true))
	action:add_precondition	(world_property(properties["aaa_grenade"], false))
	if rx_bandage then
		action:add_precondition(world_property(rx_bandage.evid_bandage,false))
	end
	if rx_facer then
		action:add_precondition(world_property(rx_facer.evid_facer,false))
	end
	if rx_gl then
		action:add_precondition(world_property(rx_gl.evid_gl_fire,false))
	end
	if rx_kill_wounded then
		action:add_precondition(world_property(rx_kill_wounded.evid_enemy_wounded,false))
	end
	action:add_precondition	(world_property(properties["crazy_grenadier"], true))
	action:add_effect (world_property(properties["crazy_grenadier"], false))
	manager:add_action (operators["fire_in_the_hole"], action)

	local action = action_run_from_grenade (npc,"run_from_grenade", storage)
	action:add_precondition(world_property(stalker_ids.property_alive, true))
--	action:add_precondition(world_property(stalker_ids.property_critically_wounded, false))
	action:add_precondition(world_property(xr_evaluators_id.sidor_wounded_base, false))
--	action:add_precondition	(world_property(properties["crazy_grenadier"], false))
	action:add_precondition	(world_property(properties["ya_psyh"], false))
	action:add_precondition	(world_property(properties["aaa_grenade"], true))
	action:add_effect (world_property(properties["aaa_grenade"], false))
	manager:add_action (operators["run_from_grenade"], action)

	if psyh then
	local action = action_psyh (npc,"kamikazze", storage)
	action:add_precondition(world_property(stalker_ids.property_alive, true))
--	action:add_precondition(world_property(stalker_ids.property_critically_wounded, false))
	action:add_precondition(world_property(xr_evaluators_id.sidor_wounded_base, false))
--	action:add_precondition	(world_property(properties["crazy_grenadier"], false))
	if rx_gl then
		action:add_precondition(world_property(rx_gl.evid_gl_fire,false))
	end
	action:add_precondition	(world_property(properties["ya_psyh"], true))
	action:add_effect (world_property(properties["ya_psyh"], false))
	manager:add_action (operators["kamikazze"], action)
	end

	-- включение в планировщик
	for i,id in ipairs({stalker_ids.action_combat_planner}) do
		action = manager:action(id)
		action:add_precondition(world_property(properties["crazy_grenadier"],false))
		action:add_precondition(world_property(properties["aaa_grenade"],false))
		if psyh then action:add_precondition(world_property(properties["ya_psyh"],false)) end
	end
	for i,id in ipairs({xr_actions_id.alife,stalker_ids.action_danger_planner}) do
		action = manager:action(id)
		action:add_precondition(world_property(properties["aaa_grenade"],false))
	end
end

function set_scheme(npc,ini,scheme,section_logic)
	local st = xr_logic.assign_storage_and_bind(npc,ini,scheme,scheme)
end

function reset_scheme(npc,scheme,st,section)
	local profile
	if st.ini:line_exist(section,"grenadier") then
		profile = st.ini:r_string(section,"grenadier")
	elseif st.ini:line_exist(st.section_logic,"grenadier") then
		profile = st.ini:r_string(st.section_logic,"grenadier")
	else
		profile = npc:character_community()
	end
	local a = st.grenadier
	if a.current_profile ~= profile then
		a.current_profile = profile
		local p = read_profile(profile)
		a.throw_enabled = p.throw
		a.evasion_enabled = p.evasion
		a.sets = p
	end
end

----------------------------------------------------------------------------------------------------------------------
-- HELPERS
----------------------------------------------------------------------------------------------------------------------

function check_victims(npc,self_pos,pos,radius,want_enemy)	-- нет ли в радиусе поражения друзей; а враги есть?
	radius = radius+1
	radius = radius*radius
	if self_pos:distance_to_sqr(pos) < radius then
		return false
	end
	local enemy
	if db.creatures then
		for id,obj in pairs(db.creatures) do
			if id ~= nid and obj and obj:alive() then
				if obj:position():distance_to_sqr(pos) < radius then
					if npc:relation(obj) == game_object.enemy then
						enemy = true
					else
						return false
					end
				end
			end
		end
	else
		local sst,mst = modules.stype_stalker,modules.stype_mobile
		for id,t in pairs(db.storage) do
			if (t.stype == sst or t.stype == mst or id == 0) and id ~= nid then
				local obj = level.object_by_id(id)
				if obj and obj:alive() then
					if obj:position():distance_to_sqr(pos) < radius then
						if npc:relation(obj) == game_object.enemy then
							enemy = true
						else
							return false
						end
					end
				end
			end
		end
	end
	if want_enemy then
		return enemy
	else
		return true
	end
end

function spawn_grenade(eva)
	local npc = eva.object
	if time_global() > eva.spawn_update_time then
		eva.spawn_update_time=time_global()+spawn_period+math.random(spawn_period*0.1)-spawn_period*level.get_game_difficulty()*spawn_period_gd_factor
--		printf("spawn_grnade[%s] set time %s , chance %s",npc:character_name(),(eva.spawn_update_time-time_global())/1000,spawn_chance_base+eva.a.rank*spawn_chance_rank_factor)
		if spawn_chance_base+eva.a.rank*spawn_chance_rank_factor < math.random() and npc:best_weapon() then
			return
		end
		local cnt,ht = 0,{}
		for s,_ in pairs(grenade_params) do
			local gr = npc:object(s)
			if gr then
				cnt = cnt+1
				if cnt >= max_grenade_num then
					return
				end
				ht[s] = true
			end
		end
		local spch,cn = {},0
		for s,c in pairs(eva.a.sets.spawn_grenades) do
			if not ht[s] then
				cn = cn + c
				table.insert(spch,{s,cn})
			end
		end
		local rnd = math.random()
		for _,t in ipairs(spch) do
			if rnd < t[2] then
--				printf("spawn_grenade[%s]:create %s",npc:character_name(),t[1])
				alife():create(t[1],npc:position(),npc:level_vertex_id(),npc:game_vertex_id(),npc:id())
				return
			end
		end
	end
end

function throw(st,id,obj)
	local ps = obj:get_physics_shell()
	if ps == nil then
		printf("try to throw[%s] no ps! parent %s typ %s",obj:name(),obj:parent(),typ)
	end
	if st.grenade_data.test then
--		level.map_add_object_spot(id,"red_location","")
	elseif ui_grenade_marks then
		ui_grenade_marks.add_new_marker(id,st.mark)
	else
		level.map_add_object_spot(id,"grenade_location","grenade")
	end
	if st.throwing_type then
		local dir = vector():sub(st.target_point,obj:position())
		if st.throwing_type == 0 then
			dir:mul(160)
			dir:add(vector():set(0,900,0))
		elseif st.throwing_type == 1 then
			dir:mul(125)
			dir:add(vector():set(0,1900,0))
		elseif st.throwing_type == 2 then
			dir:mul(110)
			dir:add(vector():set(0,2600,0))
		else
			dir:mul(250)
		end
		dir:mul(obj:mass())
--		printf("throw[%s] force %s dist %s mass %s",obj:name(),dir:magnitude(),st.target_point:distance_to(obj:position()),obj:mass())
		local bone = ps:get_element_by_bone_name("wpn_body")
		if bone then
			bone:apply_force(dir.x,dir.y,dir.z)
		end
	end
	st.grenade_data.time = time_global() + grenade_params[st.grenade_data.section].explode_time + (st.grenade_data.time or 0)
	grenades[id] = st.grenade_data
	st.grenade_data = nil
end

function explode(data,id,obj)
	if grenade_params[data.section].aff then
		grenade_params[data.section].aff(obj,data)
	end
--[[-- взрываем хитом для того, чтобы задать инициатора
	local hi = hit()
	hi.type = hit.fire_wound
	hi.power = 1000
	hi.impulse = 0
	hi.draftsman = data.initiator and level.object_by_id(data.initiator) or obj
	hi.direction = vector():set(0,0,0)
	obj:hit(hi)]]
	obj:explode(0)
end

-- 1 - время подмены, 2 - object id, 3 - object name, 4(опц) - добавка к задержке взрыва, 5(опц) - initiator id
function spoof_grenade(t)
	if t[1] < time_global() then
		local sobj,gobj = alife():object(t[2]),get_grenade(t[2])
		if sobj and gobj and not gobj:parent() and sobj:name() == t[3] then
			local obj = create_grenade(gobj:section().."_fake",gobj:position(),gobj:level_vertex_id(),gobj:game_vertex_id())
			local d = {section = gobj:section(),target = sobj.position,time = t[4],initiator = t[5]}
			level.client_spawn_manager():add(obj.id,-1,throw,{grenade_data = d})
			table.insert(rx_ai.ids_to_remove,sobj.id)
		end
		return true
	end
	return false
end

function hide_grenade(t)
	if t[1] < time_global() then
		local obj = get_grenade(t[2])
		if obj then
			obj:enable_attachable_item(false)
		end
		return true
	end
	return false
end

function create_grenade(section,pos,lv,gv)
	local sobj = alife():create(section,pos,lv,gv)

	local pk = get_netpk( sobj, 1 )
	ASSERT( ( pk and pk:isOk() ), "can't read netpacket of %s", sobj:name() )
	local data = pk:get()
	data.object_flags = bit_or(  data.object_flags, object_flags.SwitchOnline )
	data.object_flags = bit_and( data.object_flags, bit_not(object_flags.SwitchOffline) )
	data.object_flags = bit_and( data.object_flags, bit_not(object_flags.VisibleForAI) )
	data.object_flags = bit_and( data.object_flags, bit_not(object_flags.UsefulForAI) )
	data.object_flags = bit_and( data.object_flags, bit_not(object_flags.UsedAI_Locations) )
	data.object_flags = bit_and( data.object_flags, bit_not(object_flags.CanSave) )
	pk:set( data )

	return sobj
end

function update()
	for id,data in pairs(grenades) do
		if time_global() > data.time then
			local sobj = alife():object(id)
			if sobj then
				if data.test then
					alife():release(sobj)
				else
					local obj = get_grenade(id)
					if obj then
						explode(data,id,obj)
						if ui_grenade_marks then
							ui_grenade_marks.start_fading(id)
						else
							level.map_remove_object_spot(id,"grenade_location")
						end
					else
--						printf("explode[%s] fail: not obj!!!!!!!!",sobj:name())
					end
				end
				grenades[id] = nil
			else	-- возможно граната взорвалась сама?
--				printf("update[%s] not sobj %s !!!!",id)
				grenades[id] = nil
				if ui_grenade_marks then
					ui_grenade_marks.start_fading(id)
				end
			end
		end
	end
	if ui_grenade_marks then
		ui_grenade_marks.update_grenade_marks()
	end
end
