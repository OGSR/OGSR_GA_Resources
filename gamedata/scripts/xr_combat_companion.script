

----------------------------------------------------------------------------------------------------
-- Боевая схема напарника
----------------------------------------------------------------------------------------------------
-- Разработчик: KamikaZze kamikazze-ru@yandex.ru
----------------------------------------------------------------------------------------------------
-- Версия 1.95 (09/02/2015)
----------------------------------------------------------------------------------------------------

function attach( sm ) --Нужно для того, чтобы не было вылетов после перехода НПС в оффлайн/онлайн.
  sm:subscribe({ signal = "on_npc_spawn",		fun = this.on_npc_spawn })
  sm:subscribe({ signal = "on_npc_net_destroy",	fun = this.on_npc_net_destroy })
end

function on_npc_spawn( obj )
	local id = obj:id()
	if obj:alive() and xr_companion.is_companion(id) then
		subscribe( id )
		--log3("--[%s.on_npc_spawn] subscribed", script_name())
	end
end

function on_npc_net_destroy( obj )
	local id = obj:id()
	if obj:alive() and xr_companion.is_companion(id) then
		unsubscribe( id )
		--log3("~~[%s.on_npc_net_destroy] UNsubscribed", script_name())
	end
end


local sm = ogse_signals.get_mgr()
local subscribed
local subscribed_objs = {}

function subscribe( id )
	if not subscribed then
		subscribed = {
			{ signal = "on_hit", fun = this.on_hit },
			{ signal = "on_npc_hit", fun = this.on_npc_hit },
			{ signal = "on_npc_enemy_callback", fun = this.on_npc_enemy_callback },
		}
		for _, v in pairs(subscribed) do
			sm:subscribe( v )
		end
		--log3("--[%s] subscribed signal 'on_hit'", script_name())
	end

	if not subscribed_objs[id] then
		local s = {
			{ signal = "on_npc_update."..id, fun = this.on_npc_update },
		}
		for _, v in pairs(s) do
			sm:subscribe( v )
		end
		subscribed_objs[id] = s
		--log3("--[%s] subscribed signals", script_name())
	end
end

function unsubscribe( id )
	if subscribed and next(xr_companion.companions) == nil then
		for _, v in pairs(subscribed) do
			sm:unsubscribe( v )
		end
		subscribed = nil
		--log3("~~[%s] UNsubscribed signal 'on_hit'", script_name())
	end

	if subscribed_objs[id] then
		for _, v in pairs(subscribed_objs[id]) do
			sm:unsubscribe( v )
		end
		subscribed_objs[id] = nil
		--log3("~~[%s] UNsubscribed signals", script_name())
	end
end


function on_npc_update( obj )
	if xr_companion.is_companion(obj:id()) then
		reprioritize_targets(obj)
	end
end

function on_npc_hit(obj, amount, local_direction, who, bone_index)
	if xr_companion.is_companion(obj:id()) then
		hit_callback(obj, who, amount)
	end
end

function on_hit(obj, amount, local_direction, who, bone_index)
	for id, _ in pairs(xr_companion.companions) do
		local companion = level.object_by_id(id)
		if companion then
			hit_callback(companion, who, amount)
		end
	end
end

function on_npc_enemy_callback( obj, enemy, result )
  if
   ( xr_companion.is_companion(obj:id()) and enemy:relation(db.actor) ~= game_object.enemy ) --Если объект - напарник, проверяем отношение его врага к актору. Если это не враг актора, то и напарник не будет атаковать его.
	or ( xr_companion.is_companion(enemy:id()) and obj:relation(db.actor) ~= game_object.enemy ) --Запрещаем атаковать напарника актора, если атакующий не является врагом актора.
  then
    table.insert( result, false )
    return true
  end
end


function IsShotgun( object )
  if object then
    return get_u32( object:section(), "ef_weapon_type" ) == 7
  end
  return false
end

function IsSniperRifle( object )
  if object then
    return get_u32( object:section(), "ef_weapon_type" ) == 8
  end
  return false
end

-- локации где можно атаковать БТР и вертолеты
local armor_allowed_locations = { [ "l13_generators_ogse" ] = true }

function is_armor( target )
  local level_name = level.name()
  if not armor_allowed_locations[ level_name ] then return false end
  local heli = db.heli[ target:id() ]
  local car  = db.cars[ target:id() ]
  if heli or car then
    return true
  else
    return false
  end
end


----------------------------------------------------------------------------------------------------
-- Настройки схемы
----------------------------------------------------------------------------------------------------
local desired_combat_distance = 35	-- максимальный радиус отхода от ГГ
local close_combat_distance = 25	-- дистанция ближнего боя
local desired_offence_distance = 15 -- дистанция рассчетного расстояния поиска укрытия при атаке
local desired_defence_distance = 5	-- дистанция рассчетного расстояния поиска укрытия при обороне
local evade_distance = 10			-- радиус поиска точки для уклонения от выстрелов
local help_actor = 10				-- радиус следования за ГГ
local reprioritize_timeout = 1500 	-- интервал реприоретизации, мсек - нельзя делать слишком низким - будет судорожно метаться между целями
local time_to_change = 500			-- время переключения между врагами, мсек - нельзя делать слишком низким - будет проворачиваться через себя
local sound_prob = 0.03				-- вероятность сказать фразу
local time_to_hide = 7000			-- время, сколько примерно сидеть в укрытии, миллиссекунд
local time_to_maneuver = 2000		-- время, сколько бежать к точке маневрирования, миллиссекунд
local memory_timeout = 60000		-- время, сколько помнить о появлении врага, миллиссекунд
local remember_enemy = 6000			-- сколько помнить о последнем основном враге (нужно для предотвращения выхода из боя слишком рано), для неписей умножается на 3

local combat_mult_npc = 0.5			-- множитель веса ближней цели неписей
local combat_mult_monster = 0.3		-- множитель веса ближней цели неписей

local low_range_npc_aggr = 30
local far_range_mon_aggr = 25
local low_range_mon_aggr = 5

local far_range_npc_lowaggr = 60
local low_range_npc_lowaggr = 20
local far_range_mon_lowaggr = 25
local low_range_mon_lowaggr = 5

local far_range_npc_noaggr = 1
local low_range_npc_noaggr = 1
local far_range_mon_noaggr = 15
local low_range_mon_noaggr = 5

local max_invisible_range_npc = 12
local max_invisible_range_mon = 5

local use_raytrace = true
----------------------------------------------------------------------------------------------------
-- Служебные переменные
----------------------------------------------------------------------------------------------------
local last_reprioritize = nil 		-- время последней реприоретизации
local primary_target = nil 			-- кого окучивать будем, id
local last_target = {}				-- последняя цель, [id] = last_time 
local last_enemy_id = nil			-- ид последнего врага
local change_time = time_global()	-- последнее время смены целей
local last_time_send = nil			-- когда последний раз меняли точку
local last_enemy = nil				-- имя последнего врага, чисто для отладочных сообщений
local last_mode = 0					-- имя последнего режима, чисто для отладочных сообщений
local assist_point = nil			-- последняя точка маневрирования
local last_hideout = nil			-- последнее укрытие
dont_touch_us = true				-- флаг для неагрессивной схемы поведения, если выставлен в тру и схема неагрессивная - не трогаем никого... по хит коллбэку непися или актора выставляется в фалсе, взводится обратно основной схемой
local hit_memory 		= {}
local fighting_wounded 	= {}
local locked_actor_vertex = nil		-- занятые вертексы

--------------------------------------------------------------------------------------------------------------
-- Служебные таблички
--------------------------------------------------------------------------------------------------------------
local disabled_objects = {	-- заблокированные постоянно или временно объекты

}
local targets_list = {		-- список целей

}
------- структура записи таблицы
-- targets_list[npc_id] = {
	-- npc = непись или нет
	-- range = расстояние
	-- vis = видим или нет
-- }
----------------------------------------------------------------------------------------------------
-- Служебные функции для ведения реестра врагов
----------------------------------------------------------------------------------------------------
function disable_object(companion, enemy) -- забыть объект
	if companion and enemy then
		local id = enemy:id()
		if not disabled_objects[id] then
			companion:enable_memory_object( enemy, false )
			disabled_objects[id] = id
			hit_memory[id] = nil
		end
	end
end

function enable_object(companion, enemy) -- вспомнить объект
	if companion and enemy then
		local id = enemy:id()
		if disabled_objects[id] then
			companion:enable_memory_object( enemy, true )
			disabled_objects[id] = nil
		end
	end
end

function get_target(npc)
	local target_id = primary_target
	local target = nil
	if target_id then
		target = level.object_by_id(target_id)
	end
	return target
end

function hit_callback(companion, enemy, amount)
	-- если объект был ранее забыт - очухиваем его, если нету в табличке - записываем в табличку
	-- данная функция помещается в xr_motivator.hit_callback
	if --[[amount and amount > 0.02 and]] not enemy:is_actor() then
		xr_companion.being_attacked = true
		dont_touch_us = false
		enable_object(companion, enemy)
		process_enemy(companion, enemy)
		companion:make_object_visible_somewhen(enemy)
		if ( enemy:is_stalker() or enemy:is_actor() ) then
			primary_target = enemy:id()
			hit_memory[enemy:id()] = true
		end
		if xr_wounded.is_wounded(enemy) then
			fighting_wounded[enemy:id()] = true
		end
	end
end

function process_enemy(npc, enemy)
	-- проверка выбора врагом напарника или ГГ
	-- данная функция помещается в апдейты монстров и неписей
	if enemy and enemy.clsid and (IsStalker(enemy) or IsMonster(enemy)) and enemy:alive() and not xr_companion.is_companion(enemy:id()) then
		if we_are_under_attack(enemy) then
			-- человек ты иль монструшка
			register_as_target(enemy)
		else
			return
		end
	end
end

local chk_comp = {}

function we_are_under_attack(enemy)
	local target 		= enemy:best_enemy()
	chk_comp = {}
	if target then
		local actor_id		= db.actor:id()
		local companion_id	= 0
		for id, _ in pairs(xr_companion.companions) do
			local companion = level.object_by_id(id)
			if companion then
				chk_comp[id] = true
			end
		end
		if chk_comp == {} then
			return false
		else
			for k, v in pairs(chk_comp) do
				local npc = level.object_by_id(k)
				if npc then
					local enemy_status = check_is_enemy_of_me_or_actor(npc, enemy)
					local enemy_target = enemy:best_enemy()
					if (target:id() == actor_id or (enemy_target and enemy_target:id() == actor_id)) and not must_stay(npc) then
						if enemy_status then
							return true
						end						
					end
					if target:id() == npc:id() or (enemy_target and enemy_target:id() == npc:id()) then
						if enemy_status then
							return true
						end				
					end					
				end			
			end
			return false
		end
	else	
		return false
	end
end

function register_as_target(enemy)
	chk_comp = {}
	local id = enemy:id()
	if not targets_list[id] then
		for ids, _ in pairs(xr_companion.companions) do
			local companion = level.object_by_id(ids)
			if companion then
				chk_comp[ids] = true
			end
		end
		if chk_comp ~= {} then
			for companion_id, v in pairs(chk_comp) do
				if companion_id == id or enemy:is_actor() then
					return
				end
				local companion = level.object_by_id(companion_id)
				if companion and companion:alive() and not xr_wounded.is_wounded(companion) then
					local dist = companion:position():distance_to(enemy:position())
					local dist_2 = db.actor:position():distance_to(enemy:position())
					if dist_2 < dist and must_stay(companion) then
						dist = dist_2
					end
					local enemy_record = {
						npc = false,
						range = 0,
						vis = false		
					}
					enemy_record.npc = ( enemy:is_stalker() or enemy:is_actor() )
					enemy_record.range = dist
					enemy_record.vis = enemy:see(companion) or (enemy:see(db.actor) and not must_stay(companion))
					enemy_record.weight = 1000
					if enemy_record.vis == true and enemy_record.npc == true then
						enemy_record.last_time_seen = time_global()
						enemy_record.vertex = enemy:level_vertex_id()
					end
					targets_list[id] = enemy_record			
				else
					return
				end			
			end
		else
			return
		end
	end
end

function get_targets_from_memory(npc)
	if not npc then return end
	-- сбор врагов, вызывается из reprioritize_targets
	for o in npc:memory_visible_objects() do
		process_enemy(npc, o:object())
	end	
	for o in npc:memory_sound_objects() do
		process_enemy(npc, o:object())
	end
	if hit_memory then
		for enemy_id, _ in pairs(hit_memory) do
			local enemy = level.object_by_id(enemy_id)
			if enemy then
				process_enemy(npc, enemy)
			end
		end	
	end
end

function reprioritize_targets(companion)
	-- обновление основной цели, вызывается из апдейта напарника
	-- обновим предварительно реестр целей
	if db.actor then 
		locked_actor_vertex = db.actor:level_vertex_id()
	end
	
	if last_reprioritize and time_global() < (last_reprioritize+reprioritize_timeout) and primary_target then
		return
	end

	get_targets_from_memory(companion)
	refresh_targets(companion)
	
	-- На дистанциях выше 10 метров приоритет неписям, ближе 10 метров приоритет монстрам. При дистанции ниже пары метров объект сразу становится примари_таргет без вариантов. 
	-- При варианте далее 10 метров проверяем видимость, приоритет видимому.
	local last_weight 	= 1000
	
	for k, v in pairs(targets_list) do
		if v.vis == true then -- если цель видит нас
			local close_combat, far_combat = combat_ranges(companion, v.npc)
			local mult = combat_multiplier(v.npc)
			if v.npc == false then -- если она монстр
				if v.range >= close_combat and v.range < far_combat then -- и цель на средней дистанции
					v.weight = v.range * combat_multiplier(v.npc)
				elseif v.range < close_combat then -- а если вплотную
					v.weight = 0
				end
			else -- а если непись
				if v.range >= close_combat and v.range < far_combat then -- если не ближний бой
					v.weight = v.range
				elseif v.range < close_combat then -- а если ближний
					v.weight = v.range * combat_multiplier(v.npc)
				end
			end
		else -- если невидима
			if primary_target == k then
				last_target[primary_target] = time_global()
				primary_target = nil
			end
			if v.npc == false then -- если она монстр
				if v.range < max_invisible_range_mon then 
					v.weight = v.range * 2
				else
					v.weight = 1000
				end
			else -- а если непись
				if v.range < max_invisible_range_npc then -- если в радиусе "слуха"
					v.weight = v.range * 3
				elseif v.range < desired_combat_distance then -- если в радиусе максимального отхода от ГГ
					if v.last_time_seen and (v.last_time_seen + memory_timeout) > time_global() then -- если видели её не менее минуты назад
						v.weight = v.range * 4
					else	
						v.weight = 1000
					end					
				else
					v.weight = 1000
				end
			end
		end
	end

	for k, v in pairs(targets_list) do
		if v.weight < last_weight then
			last_weight = v.weight
			primary_target = k
			last_target = {}
		end	
	end
	
	if primary_target ~= nil then
		last_reprioritize = time_global()
		xr_companion.being_attacked = true
		return
	else
		local deadman = have_fresh_deadman()
		if deadman == false then
			last_time_send = nil
			last_enemy = nil
			last_enemy_id = nil
			primary_target = nil
			assist_point = nil
			last_target = {}
			-- НЕ ЗАКОММЕНТИРОВАТЬ НИ В КОЕМ СЛУЧАЕ!
			xr_companion.being_attacked = false
		end
	end

end

function refresh_targets(companion)
	-- обновление реестра врагов, вызывается из апдейта напарника
	local enemy_by_engine = companion:best_enemy()
	if enemy_by_engine and enemy_by_engine:alive() and not (xr_wounded.is_wounded(enemy_by_engine) and not fighting_wounded[enemy_by_engine:id()]) then
		if not targets_list[enemy_by_engine:id()] and (check_is_enemy_of_me_or_actor(companion, enemy_by_engine) or 
		(enemy_by_engine:best_enemy() and (enemy_by_engine:best_enemy():id() == companion_id or enemy_by_engine:best_enemy():id() == actor_id)))
		then
			register_as_target(enemy_by_engine)
		end
	end
	-- 
	for k, v in pairs(targets_list) do
		local check_target = level.object_by_id(k)
		if check_target and check_target:alive() and not (xr_wounded.is_wounded(check_target) and not fighting_wounded[check_target:id()]) then
			local dist	= companion:position():distance_to(check_target:position())
			local vis_1	= check_target:see(companion)
			local vis_2 = (check_target:see(db.actor) and not must_stay(companion))
			v.range	= dist
			if vis_1 or vis_2 then
				v.vis	= true
			else	
				v.vis	= false
			end
			if v.vis == false then
				if v.npc == false then
					if dist > 50 then
						disable_object(companion, check_target)
						if primary_target == k then
							last_target[primary_target] = time_global()
							primary_target = nil
						end
						targets_list[k] = nil
					end
				else
					if dist > 150 then
						disable_object(companion, check_target)
						if primary_target == k then
							last_target[primary_target] = time_global()
							primary_target = nil
						end	
						targets_list[k] = nil
					else
						if companion:see(check_target) then
							v.last_time_seen = time_global()
							v.vertex = check_target:level_vertex_id()
						end						
					end
				end
			else
				if v.npc == true then
					v.last_time_seen = time_global()
					v.vertex = check_target:level_vertex_id()
				end
			end
		elseif check_target then
			disable_object(companion, check_target)
			if primary_target == k then
				last_target[primary_target] = time_global()
				primary_target = nil
			end
			targets_list[k] = nil			
		else	
			if primary_target == k then
				primary_target = nil
				local self_hit = hit()
				self_hit.type = hit.strike
				self_hit.power = 0
				self_hit.impulse = 0.01
				self_hit.draftsman = companion
				self_hit.direction = vector():set(0,0,0)	
				companion:hit(self_hit)				
			end
			targets_list[k] = nil			
		end
	end
	table.sort(targets_list,function(a,b) return a.range < b.range end)
end

function get_max_weapon_range(companion)
	-- служебная для проверки достанет ли оружие
	if companion then
		local act_item = nil
		if companion:active_slot() ~= 255 then
			act_item = companion:item_in_slot(companion:active_slot())
		end
		if act_item then
			local sect = act_item:section()
			if sys_ini:section_exist(sect) and sys_ini:line_exist(sect, "max_radius") then
				return sys_ini:r_float(sect, "max_radius")
			elseif not sys_ini:section_exist(sect) then	
				return 36.0
			elseif not sys_ini:line_exist(sect, "max_radius") then	
				return 36.0
			end
		else
			return 36.0
		end
	else
		return 36.0
	end
end


function IsHighRecoilRapidFire( object )
  if object then
    return get_u32( object:section(), "ef_weapon_type" ) == 10
  end
  return false
end


function combat_ranges(npc, enemy_is_npc)
	if npc then
		local wpn_check_max_range = get_max_weapon_range(npc)
		if no_aggression(npc) then
			if dont_touch_us then
				-- не воюем пока не стукнули
				if enemy_is_npc then
					return low_range_npc_noaggr, far_range_npc_noaggr
				else
					return low_range_mon_noaggr, far_range_mon_noaggr
				end
			else
					-- берем всех
				if enemy_is_npc then
					return low_range_npc_aggr, wpn_check_max_range
				else
					return low_range_mon_aggr, far_range_mon_aggr
				end
			end		
		elseif low_aggression(npc) then
			if dont_touch_us then
				-- берем ближние цели
				if enemy_is_npc then
					return low_range_npc_lowaggr, far_range_npc_lowaggr
				else
					return low_range_mon_lowaggr, far_range_mon_lowaggr
				end
			else
				-- берем всех
				if enemy_is_npc then
					return low_range_npc_aggr, wpn_check_max_range
				else
					return low_range_mon_aggr, far_range_mon_aggr
				end
			end
		else
		-- берем всех
			if enemy_is_npc then
				return low_range_npc_aggr, wpn_check_max_range
			else
				return low_range_mon_aggr, far_range_mon_aggr
			end
		end
	else
		return 30, 150
	end
end

function combat_multiplier(enemy_is_npc)
	if enemy_is_npc then
		return combat_mult_npc
	else
		return combat_mult_monster
	end
end

function check_is_enemy_of_me_or_actor(npc, enemy)
	if not npc or not enemy then return false end
	if enemy:is_monster() then return true
	elseif enemy:is_stalker() then
		local is_engine_enemy = enemy:relation(npc) == game_object.enemy
		local is_engine_enemy_actor = enemy:relation(db.actor) == game_object.enemy
		if is_engine_enemy or is_engine_enemy_actor then
			return true
		end
	end
	return false
end

function set_weapons_fire(npc, enemy, weapon)
	if enemy:alive() and not (xr_wounded.is_wounded(enemy) and not fighting_wounded[enemy:id()]) then

		local type_of_fire = object.aim1

		if use_raytrace then		
			local be_pos = enemy:position()
			local npc_pos = weapon:position()
			local distance = npc_pos:distance_to(be_pos)
			
			if is_armor(enemy) then
				if string.find(enemy:name(),"btr") then
					be_pos = enemy:bone_position("mashine_gun_tower")
				else
					be_pos = enemy:bone_position("korpus1")
				end			
			else
				be_pos = enemy:bone_position(get_string(enemy:section(), "bone_head", "bip01_head"))
			end	

			local dir_enemy = utils.vector_copy_by_val(be_pos):sub(npc_pos)
			local aim_point = npc_pos:add(dir_enemy:normalize())
			
			local dist = distance+1
			local res = level.ray_query(aim_point, dir_enemy, dist, rq_target.rqtBoth, npc)
			local obj = res.object
			
			if obj then
				
				if obj and obj:id() == enemy:id() then
					type_of_fire = object.fire1
				else
					if obj then
						if check_is_enemy_of_me_or_actor(npc, obj) and not obj:is_actor() then
							type_of_fire = object.fire1
						else
							type_of_fire = object.aim1
						end
					else
						if npc:see(enemy) then
							type_of_fire = object.fire1
						end
					end
				end
				
			else	
				-- если рейтрейс не вернул результат
				type_of_fire = object.fire1
			end			
	
		else
			type_of_fire = object.fire1
		end
	
		if IsShotgun(weapon) then
			npc:set_item(type_of_fire, weapon, 1, 800)
		elseif IsSniperRifle(weapon) then
			npc:set_item(type_of_fire, weapon, 1, 500)
		elseif IsHighRecoilRapidFire(weapon) then	
			npc:set_item(type_of_fire, weapon, 5, 50)
		else
			npc:set_item(type_of_fire, weapon, 5, 250)
		end
	end
end

function set_combat_state(npc, enemy, transfer_flag, speed_flag, sneak_flag)

	-- transfer_flag:
	-- false - normal
	-- true - transfer
	
	-- speed_flag:
	-- false - normal
	-- true - fast
	
	-- sneak_flag:
	-- false - normal
	-- true - sneak
	
	local look = nil
	if enemy then
		look = {look_object = enemy}
	end	
	
	if transfer_flag then
		if speed_flag then
			if sneak_flag then
			-- быстрый, трансфер, ползком
				state_mgr.set_state( script_name(),  npc, "sneak_run_fire", nil, nil, look, {animation = true} )			
			else
			-- быстрый, трансфер, пешком
				state_mgr.set_state( script_name(),  npc, "raid_fire", nil, nil, look, {animation = true} )
			end		
		else
			if sneak_flag then
			-- медленный, трансфер, ползком
				state_mgr.set_state( script_name(),  npc, "sneak_fire", nil, nil, look, {animation = true} )
			else
			-- медленный, трансфер, пешком
				state_mgr.set_state( script_name(),  npc, "raid_fire", nil, nil, look, {animation = true} )
			end			
		end
	else
		if npc:animation_count() > 0 then
			state_mgr.set_state( script_name(),  npc, "idle", nil, nil, nil, {animation = true})
			return 
		end
		if speed_flag then
			if sneak_flag then
			-- быстрый, нормально, ползком
				state_mgr.set_state( script_name(),  npc, "sneak_run_fire", nil, nil, look )
			else
			-- быстрый, нормально, пешком
				if in_hideout(npc) then
					state_mgr.set_state( script_name(),  npc, "sneak_run_fire", nil, nil, look )
				else
					state_mgr.set_state( script_name(),  npc, "raid_fire", nil, nil, look )
				end
			end			
		else
			if sneak_flag then
			-- медленный, нормально, ползком
				state_mgr.set_state( script_name(),  npc, "sneak_fire", nil, nil, look )
			else
			-- медленный, нормально, пешком
				if in_hideout(npc) then
					state_mgr.set_state( script_name(),  npc, "sneak_fire", nil, nil, look )
				else
					state_mgr.set_state( script_name(),  npc, "raid_fire", nil, nil, look )
				end
			end		
		end
	end

end

function set_combat_sight(npc, enemy, weapon)
	
	local bone
	local enemy_pos = enemy:position()
	local npc_pos = npc:position()
	local direction = npc_pos:sub(enemy_pos)
	local bodystate = enemy:body_state()
	local distance = npc_pos:distance_to(enemy_pos)

	if ( enemy:is_stalker() or enemy:is_actor() ) then
		if IsShotgun(weapon) then
			if enemy_pos.y < (npc_pos.y - 1) then
				bone = get_string(enemy:section(), "bone_head", "bip01_head")
			else
				bone = "bip01_neck"
			end
		elseif IsSniperRifle(weapon) then
			bone = "eyelid_1"
		elseif not IsHighRecoilRapidFire(weapon) then
			if distance < 25 then
				if bodystate == move.crouch then
					bone = "bip01_pelvis"
				else
					if enemy_pos.y < (npc_pos.y - 1) then
						bone = get_string(enemy:section(), "bone_head", "bip01_head")
					else
						bone = "bip01_neck"
					end
				end
			elseif distance >= 25 and distance < 50 then
				if bodystate == move.crouch then
					bone = "bip01_pelvis"
				else
					bone = get_string(enemy:section(), "bone_head", "bip01_head")
				end
			else	
				bone = "bip01_spine"
			end
		else	
			bone = "bip01_pelvis"
		end
	else	
		if IsSniperRifle(weapon) then
			if enemy_pos.y < (npc_pos.y - 1) then
				bone = get_string(enemy:section(), "bone_head", "bip01_head")
			else
				--bone = "bip01_neck"
			end
		--elseif not IsHighRecoilRapidFire(weapon) then
		--	bone = "bip01_spine"
		--else
		--	bone = "bip01_pelvis"
		end
	end

  local look_pos
  if bone then
    look_pos = enemy:bone_position( bone )
  end

  npc:set_desired_direction()
  if look_pos then
    npc:set_sight( look.fire_point, look_pos )
  else
    npc:set_sight( enemy, true, true )
  end
end
----------------------------------------------------------------------------------------------------
-- Служебные функции для маневрирования
----------------------------------------------------------------------------------------------------
function select_position(npc, target, stay_flag)

	-- по умолчанию (ничего не указано) пляшем от актора
	-- если указан stay_flag, и не указан target то от себя
	-- если указан target то от target
	
	if last_time_send and last_time_send > time_global() then
		return
	end	

	local around_object = npc
	
	if stay_flag == false then
		around_object = db.actor
	end
	
	if target then
		around_object = target
	end	

	local node_1_vertex_id = nil
	local node_1_distance = nil
	local node_2_vertex_id = nil
	local node_2_distance = nil

	-- проверяем точку слева
	desired_direction = vector_rotate_y(around_object:direction(), math.random(50,60) )
	node_1_vertex_id = level.vertex_in_direction(around_object:level_vertex_id(),
		desired_direction,
		close_combat_distance)
	if npc:accessible(node_1_vertex_id) ~= true or node_1_vertex_id == around_object:level_vertex_id() or (locked_actor_vertex and node_1_vertex_id == locked_actor_vertex) then			
		node_1_vertex_id = nil
	end
	-- проверяем точку справа
	desired_direction = vector_rotate_y(around_object:direction(), -math.random(50,60) )
	node_2_vertex_id = level.vertex_in_direction (  around_object:level_vertex_id(),
		desired_direction,
		close_combat_distance )
	if npc:accessible(node_2_vertex_id) ~= true or node_2_vertex_id == around_object:level_vertex_id() or (locked_actor_vertex and node_2_vertex_id == locked_actor_vertex) then			
		node_2_vertex_id = nil
	end
	
	-- Проверяем растояния до точек
	if node_1_vertex_id ~= nil then
		node_1_distance = npc:position():distance_to_sqr(level.vertex_position(node_1_vertex_id))
	else
		node_1_distance = -1
	end
	if node_2_vertex_id ~= nil then
		node_2_distance = npc:position():distance_to_sqr(level.vertex_position(node_2_vertex_id))
	else
		node_2_distance = -1
	end
	
	-- Выбираем ближайшую из существующих
	if node_1_distance == -1 and node_2_distance == -1 then
		--' Не смогли найти точку, ругаться
		return nil
	end
	if node_1_distance == -1 then
		last_time_send = time_global() + time_to_maneuver
		return node_2_vertex_id
	end
	if node_2_distance == -1 then
		last_time_send = time_global() + time_to_maneuver
		return node_1_vertex_id
	end
	if node_1_distance < node_2_distance then
		last_time_send = time_global() + time_to_maneuver
		return node_1_vertex_id
	else
		last_time_send = time_global() + time_to_maneuver
		return node_2_vertex_id
	end
end

function find_cover(npc, enemy, mode)

	-- список режимов:
	
	-- mode = 1 - атака
	-- mode = 0 - оборона (удержание позиции)
	
	-- cover_point* best_cover(vector self_position, vector enemy_position, float radius, float min_enemy_distance, float max_enemy_distance) – возвращает лучшую точку прикрытия от врага в заданном радиусе от своей позиции и на нужном расстояниии от врага
	-- cover_point* safe_cover(const vector& self_position, float radius, float min_distance) – возвращает лучшую точку прикрытия в заданном радиусе от своей позиции и не ближе min_distance. Прикрытость учитывается со всех направлений.	
	
	-- C++ class cover_point {
		-- function level_vertex_id() const;
		-- function position() const;
	-- };
	
	-- если НЕТ точки или НЕТ последнего времени посыла, либо время есть но меньше чем time_global - ИЩЕМ укрытие
	-- если ЕСТЬ точка И ЕСТЬ последнее время посыла И оно больше чем time_global - не ищем

	if last_time_send and last_time_send > time_global() then
		return
	end
	
	if must_stay(npc) then -- оставленный непись всегда обороняется
		mode = 0
	end	

	local dist_to_actor = npc:position():distance_to(db.actor:position())
	if not must_stay(npc) and dist_to_actor > 50 then
		return select_position(npc, nil, false)
	end		

	local best_cover = nil
	if npc and enemy then
	
		local npc_pos = npc:position()
		local enemy_pos = enemy:position()
		local distance_to_enemy = npc_pos:distance_to(enemy_pos)
		local min_enemy_distance = distance_to_enemy / 3
		local max_enemy_distance = distance_to_enemy / 2
		local radius = distance_to_enemy - (distance_to_enemy / 3)
		local cover = nil
		local hide_flag = in_ambush(npc)
		
		if mode == 1 then
			cover = npc:best_cover(npc_pos, enemy_pos, radius, min_enemy_distance, max_enemy_distance)
		elseif mode == 0 then
			cover = npc:safe_cover(npc_pos, 5, 0)
		end
		
		if cover then
			local cover_vertex = cover:level_vertex_id()
			local dist_to_cover = cover:position():distance_to(npc_pos)
			local move_speed = 1.8
			if hide_flag then
				move_speed = 2.5
			end
			local move_time = dist_to_cover / move_speed
			if locked_actor_vertex and cover_vertex == locked_actor_vertex then
				return select_position(npc, nil, true)
			end
			last_time_send = time_global() + move_time + time_to_hide
			last_hideout = cover_vertex
			return cover_vertex
		else	
			return select_position(npc, nil, true)
		end
		
	else
		return nil
	end
	
end


function combat_send(npc, assist_point)
	if assist_point then
		utils.send_to_nearest_accessible_vertex(npc, assist_point)
	end
end

function defensive_send(npc, enemy, stay)
	local assist_point = select_position(npc, nil, stay)
	if assist_point then
		utils.send_to_nearest_accessible_vertex(npc, assist_point)
	else
		assist_point =  select_position(npc, nil, true)
		if assist_point then
			utils.send_to_nearest_accessible_vertex(npc, assist_point)
		else	
			assist_point = find_cover(npc, enemy, 0)
			if assist_point then
				utils.send_to_nearest_accessible_vertex(npc, assist_point)
			end
		end
	end
end

function must_stay(npc)
	if npc then
		local st = db.storage[npc:id()]
		local behavior = 0
		if st and st.companion then
			behavior = st.companion.behavior
		end
		local dist_to_actor = npc:position():distance_to(db.actor:position())
		if (behavior == 3 or
		behavior == 5 or
		behavior == 6 or
		behavior == 7 or
		behavior == 10 or
		behavior == 11) and 
		(dist_to_actor > 100 or
		(dist_to_actor <= 100 and dist_to_actor > 50 and not npc:see(db.actor))) 
		then
			return true
		end
	end
	return false
end

function in_ambush(npc)
	if npc then
		local st = db.storage[npc:id()]
		local behavior = 0
		if st and st.companion then
			behavior = st.companion.behavior
		end
		if behavior == 1 or
		behavior == 4 or
		behavior == 6 or
		behavior == 7 or
		behavior == 9 or
		behavior == 11 then
			return true
		end
	end
	return false
end

function low_aggression(npc)
	if npc then
		local st = db.storage[npc:id()]
		local behavior = 0
		if st and st.companion then
			behavior = st.companion.behavior
		end
		if behavior == 8 or
		behavior == 9 or
		behavior == 10 or
		behavior == 11 then
			return true
		end
	end
	return false
end

function no_aggression(npc)
	if npc then
		local st = db.storage[npc:id()]
		local behavior = 0
		if st and st.companion then
			behavior = st.companion.behavior
		end
		if behavior == 2 or
		behavior == 4 or
		behavior == 5 or
		behavior == 7 then
			return true
		end
	end
	return false
end

function in_hideout(npc)
	if last_hideout and npc then
		local npc_pos = npc:position()
		local npc_vert = npc:level_vertex_id()
		local hideout_pos = level.vertex_position(last_hideout)
		local distance_to_cover = npc_pos:distance_to(hideout_pos)
		if distance_to_cover < 3 or npc_vert == last_hideout then
			return true
		end
	end
	return false
end


function have_fresh_deadman()
	local target = false
	for k, v in pairs(last_target) do
		local obj = level.object_by_id(k)
		local timeout = remember_enemy
		if obj and ( obj:is_stalker() or obj:is_actor() ) then
			timeout = timeout*3
		end
		local time_check = time_global() - remember_enemy
		if v and v > time_check then
			target = k
		else
			last_target[k] = nil
		end
	end
	return target
end
----------------------------------------------------------------------------------------------------
-- Эвалуаторы и свойства
----------------------------------------------------------------------------------------------------
-- evaluator_combat_activity	- продолжаем вооруженное общение до умиротворения объекта
----------------------------------------------------------------------------------------------------
-- Экшены и свойства
----------------------------------------------------------------------------------------------------
-- action_combat_activity		- выставляем стрельбу по врагу - точку, состояние зависимо от режима поведения. Маневрируем.
----------------------------------------------------------------------------------------------------
local count_update 			= 0	-- Счетчик апдейтов. Нельзя чтобы схема стартовала включенной сразу же, иначе 
local engage_after_update 	= 3 -- будут глюки на переключении схем и выборе оружия
--------------------------------------------------------------------------------------------------------------
class "evaluator_combat_activity" ( property_evaluator ) -- продолжаем вооруженное общение до умиротворения объекта

function evaluator_combat_activity:__init( name, storage ) super ( nil, name )
	self.st = storage
end

function evaluator_combat_activity:evaluate()
	if not self.object:alive() or xr_wounded.is_wounded(self.object) or not xr_companion.is_companion(self.object:id()) then
		return false
	end
	if count_update <= engage_after_update then
		count_update = count_update + 1
		return false
	end
	if no_aggression(self.object) and dont_touch_us	then
		return false
	end
	local targ = have_fresh_deadman()
	if primary_target ~= nil then
		local best_enemy = level.object_by_id(primary_target)
		if best_enemy 
		and best_enemy:alive() 
		and not (xr_wounded.is_wounded(best_enemy) and not fighting_wounded[best_enemy:id()])
		then
			ogse_debug.add_active_eval( self.object, script_name(), "combat_activity" )
			xr_companion.being_attacked = true
			self.object:set_mental_state(anim.danger)
			return true
		else
			if targ ~= false then
				ogse_debug.add_active_eval( self.object, script_name(), "combat_activity_2" )
				xr_companion.being_attacked = true
				return true
			end
			return false
		end
	else
		if targ ~= false then
			ogse_debug.add_active_eval( self.object, script_name(), "combat_activity_3" )
			xr_companion.being_attacked = true
			self.object:set_mental_state(anim.danger)
			return true
		end
		return false
	end
end
--------------------------------------------------------------------------------------------------------------
class "action_combat_activity" ( action_base ) -- выставляем стрельбу по врагу - точку, состояние зависимо от режима поведения. Маневрируем.

function action_combat_activity:__init( name, storage )  super ( nil, name )
	self.st = storage
end

function action_combat_activity:initialize()
	action_base.initialize( self )
	if not xr_wounded.is_wounded(self.object) then
		self.object.health = 1
	end
end

function action_combat_activity:execute()
	action_base.execute( self )
	
	if xr_wounded.is_wounded(self.object) then -- если ранен, то обнулим все переменные для перезапуска схемы
		last_time_send = nil
		last_enemy = nil
		last_enemy_id = nil
		assist_point = nil
		xr_sound.set_sound(self.object, nil)
		return
	end

	self.object:movement_enabled(true)

	self.object:set_desired_direction()
	self.object:set_desired_position ()
	self.object:set_detail_path_type ( move.curve )
	self.object:set_path_type        ( game_object.level_path )	
	
	local enemy = nil 				-- текущий враг
	local change_flag = false		-- флаг смены цели
	
	local deadman = have_fresh_deadman()
	
	if primary_target ~= nil then	-- если есть целеуказание от селектора
		enemy = level.object_by_id(primary_target)	-- получим объект цели
	end
	if not enemy and deadman == false then
		last_time_send = nil
		last_enemy = nil
		last_enemy_id = nil
		primary_target = nil
		assist_point = nil
		last_reprioritize = nil
		xr_companion.being_attacked = false
		return
	end
	
	-- получим текущее оружие
	local weap_lost, vtx, lost_id = xr_companion.check_lost_weapon(self.object)
	if weap_lost then
		assist_point = vtx
		local last_weapon_obj = level.object_by_id(lost_id)
		if last_weapon_obj and self.object:position():distance_to(last_weapon_obj:position()) > 1.3 then
			set_combat_state(self.object, nil, true, true, true)
			combat_send(self.object, assist_point)
		elseif last_weapon_obj then
			last_weapon_obj:transfer_item(last_weapon_obj,self.object)
		end
		return
	end	

	local act_item = nil
	if self.object:active_slot() ~= 255 then
		act_item = self.object:item_in_slot(self.object:active_slot())
	end

	local bw = nil
	if not act_item or act_item:is_knife() then
		local wm = rx_wmgr and self.object:get_wm(true)
		bw = (wm and wm:get_weapon()) or self.object:best_weapon()
	else
		bw = act_item
	end
	
	if not bw then bw = self.object:best_weapon() end
	
	if not bw and enemy then 
		set_combat_state(self.object, enemy, true, true, true)
		if ( enemy:is_stalker() or enemy:is_actor() ) then
			assist_point = find_cover(self.object, enemy, 0)
		else
			assist_point = select_position(self.object, nil, true)
		end
		defensive_send(self.object, enemy, stay)
		return	
	end		
	
	local stay = must_stay(self.object)
	
	-- если ещё свежий труп
	if primary_target == nil and deadman ~= false then
		local deadman_target = level.object_by_id(deadman)
		if deadman_target then
			set_combat_state(self.object, deadman_target, false, false, in_ambush(self.object))
			set_combat_sight(self.object, deadman_target, bw)
			self.object:set_item(object.aim1, bw)
			defensive_send(self.object, deadman_target, stay)
			return			
		else
			last_target[deadman] = nil
			last_time_send = nil
			last_enemy = nil
			last_enemy_id = nil
			primary_target = nil
			assist_point = nil
			last_reprioritize = nil
			xr_companion.being_attacked = false
			return
		end
	end
	
	-- инициализация боя
	
	if enemy and (not last_enemy_id or enemy:id() ~= last_enemy_id) then
	
		last_enemy_id = enemy:id()
		change_flag = true
		change_time = time_global() + time_to_change
		xr_sound.set_sound(self.object, nil)
		self.object:clear_animations()
		self.object.health = 1
		
		state_mgr.set_state( script_name(),  self.object, "idle", nil, nil, nil, {animation = true})
		
		enable_object(self.object, enemy)
		local h = hit()
		h.power = 0
		h.direction = self.object:direction()
		h.bone = "bip01_spine"
		h.draftsman = enemy
		h.impulse = 0
		h.type = hit.wound
		self.object:hit(h)
		
		self.object:set_relation(game_object.enemy, enemy)		
		self.object:set_item(object.aim2, bw)
	end
	
	-- переключение между целями
	
	if change_flag or change_time > time_global() then
	
		set_combat_state(self.object, enemy, true, true, in_ambush(self.object))
		set_combat_sight(self.object, enemy, bw)
		-- set_weapons_fire(self.object, enemy, bw)
		if ( enemy:is_stalker() or enemy:is_actor() ) then
			assist_point = find_cover(self.object, enemy, 0)
		else
			assist_point = select_position(self.object, nil, true)
		end
		combat_send(self.object, assist_point)
		
		return
	end
	
	-- если бой инициализирован, продолжаем
	local see_enemy = self.object:see(enemy)	-- видим ли цель
	local have_seen = enemy:see(self.object)	-- видит ли нас цель	
	
	-- боевка
	if see_enemy then
		-- если видим врага
		if have_seen then
			local mode = 0
			if math.random() < sound_prob and not in_ambush(self.object) then
				xr_sound.set_sound(self.object, "fight_enemy")
			end
			-- и он нас видит - мочим и отходим
			set_combat_state(self.object, enemy, false, true, in_ambush(self.object))
			if ( enemy:is_stalker() or enemy:is_actor() ) and math.random() > 0.5 then
				assist_point = find_cover(self.object, enemy, 1)
			else
				assist_point = select_position(self.object, nil, stay)
			end
			set_combat_sight(self.object, enemy, bw)
			set_weapons_fire(self.object, enemy, bw)
			combat_send(self.object, assist_point)
		else
			local mode = 1
			if math.random() < sound_prob and not in_ambush(self.object) then
				xr_sound.set_sound(self.object, "fight_attack")
			end		
			-- и он нас не видит - мочим гада
			set_combat_state(self.object, enemy, false, false, in_ambush(self.object))
			if ( enemy:is_stalker() or enemy:is_actor() ) then
				assist_point = self.object:level_vertex_id()
			else
				assist_point = select_position(self.object, nil, stay)
			end			
			last_time_send = time_global() + time_to_hide
			set_combat_sight(self.object, enemy, bw)
			set_weapons_fire(self.object, enemy, bw)	
			combat_send(self.object, assist_point)
		end	
	else
		-- если не видим врага
		if have_seen then
			local mode = 2
			if math.random() < sound_prob and not in_ambush(self.object) then
				xr_sound.set_sound(self.object, "fight_enemy")
			end			
			-- и он нас видит - пугающе постреливаем и уходим
			set_combat_state(self.object, enemy, false, false, in_ambush(self.object))
			if ( enemy:is_stalker() or enemy:is_actor() ) and math.random() > 0.5 then
				assist_point = find_cover(self.object, enemy, 0)
			else
				assist_point = select_position(self.object, nil, stay)
			end			
			set_combat_sight(self.object, enemy, bw)
			set_weapons_fire(self.object, enemy, bw)
			combat_send(self.object, assist_point)
		else
			local mode = 3
			if math.random() < sound_prob and not in_ambush(self.object) then
				xr_sound.set_sound(self.object, "fight_search")
			end			
			-- и он нас не видит - поступаем по настройкам агрессивности
			set_combat_state(self.object, enemy, false, true, in_ambush(self.object))
			set_combat_sight(self.object, enemy, bw)
			self.object:set_item(object.aim1,bw)
			assist_point = select_position(self.object, nil, stay)
			if ( enemy:is_stalker() or enemy:is_actor() ) then
				defensive_send(self.object, enemy, stay)
			else
				combat_send(self.object, assist_point)
			end
			
		end	
	end
end

function action_combat_activity:finalize()
	action_base.finalize( self )
	xr_sound.set_sound(self.object, nil)
end
--------------------------------------------------------------------------------------------------------------
class "action_join_actor" ( action_base ) -- направляем поближе к ГГ если чего-то далековато

function action_join_actor:__init( name, storage )  super ( nil, name )
	self.st = storage
end

function action_join_actor:initialize()
	action_base.initialize( self )
	if xr_wounded.is_wounded(self.object) then
		return
	end
	self.object:set_desired_direction()
	self.object:set_desired_position ()
	self.object:clear_animations()
	self.object:set_detail_path_type ( move.curve )
	self.object:set_path_type        ( game_object.level_path )
	if in_ambush(self.object) then
		state_mgr.set_state( script_name(),  self.object, "sneak_run_fire" )
	else
		state_mgr.set_state( script_name(),  self.object, "raid_fire" )
	end
end

function action_join_actor:execute()
	action_base.execute( self )
	if xr_wounded.is_wounded(self.object) then
		return
	end
	assist_point = select_position(self.object, nil, false)
	if not assist_point then
		return
	end
	self.object:movement_enabled(true)
	self.object:set_desired_direction()
	self.object:set_desired_position ()
	self.object:set_detail_path_type ( move.curve )
	self.object:set_path_type        ( game_object.level_path )		
	utils.send_to_nearest_accessible_vertex(self.object, assist_point)
end

function action_join_actor:finalize()
	action_base.finalize( self )
end

--------------------------------------------------------------------------------------------------------------
-- Идентификаторы эвалуаторов схемы
--------------------------------------------------------------------------------------------------------------
local base = 87450
prop_enable 		= base + 0
prop_combat	  		= base + 2
prop_join		  	= base + 3

local base_act = 87490
act_combat			= base_act + 1
act_join			= base_act + 2
--------------------------------------------------------------------------------------------------------------
-- Многострадальный биндер
--------------------------------------------------------------------------------------------------------------
function add_to_binder( object, char_ini, scheme, section, st )

	local manager = object:motivation_action_manager()

	local property_wounded 			= xr_evaluators_id.sidor_wounded_base
	local state_mgr_to_idle_combat 	= xr_actions_id.state_mgr + 1
	local state_mgr_to_idle_alife 	= xr_actions_id.state_mgr + 2
	
	manager:remove_evaluator( prop_combat )

	manager:add_evaluator( prop_combat,		evaluator_combat_activity	( "evaluator_combat_activity",        st ) )
	
	local action = action_combat_activity( "action_combat_activity", st )
	action:add_precondition( world_property( stalker_ids.property_alive,     true  ) )
	action:add_precondition( world_property( property_wounded,				 false ) )
	if xrs_grenade then
		action:add_precondition(world_property(xrs_grenade.evid_aaa_grenade,false))
	end
	--if rx_bandage then
	--	action:add_precondition (world_property(rx_bandage.evid_bandage,	false))
	--end
	--if rx_facer then
	--	action:add_precondition( world_property( rx_facer.evid_facer,				false ) )
	--end
	if rx_gl then
		action:add_precondition (world_property(rx_gl.evid_gl_reload,		false))
	end
	if rx_kill_wounded then
		action:add_precondition(world_property(rx_kill_wounded.evid_enemy_wounded,false))
	end

	action:add_precondition( world_property( prop_combat,          	         true  ) )
	action:add_effect      ( world_property( prop_combat,   				 false ) )
	action:add_effect(world_property( stalker_ids.property_enemy, false ))	
	manager:add_action( act_combat, action )
	
	action = manager:action(stalker_ids.action_combat_planner)	
	action:add_precondition(world_property(prop_combat, false))

	action = manager:action(state_mgr_to_idle_alife)
	action:add_precondition(world_property(prop_combat, false))

	action = manager:action(state_mgr_to_idle_combat)
	action:add_precondition(world_property(prop_combat, false))

	action = manager:action(stalker_ids.action_alife_planner)
	action:add_precondition(world_property(prop_combat, false))

	action = manager:action(stalker_ids.action_retreat_from_enemy)
	action:add_precondition(world_property(prop_combat, false))
	
end

-- Функции включения/выключения схемы
function enable_scheme(npc, ini)
	local st = xr_logic.assign_storage_and_bind(npc, ini, "companion_combat")
	local flag = xr_companion.load_var_companion(npc:id(), "is_companion", 0)
	if st then
		if tostring(flag) == "1" then
			st.enabled = true
		else
			st.enabled = false
		end
	end
end
function disable_scheme(npc, scheme)
	local st = db.storage[npc:id()][scheme]
	if st then
		st.enabled = false
	end
end
