-- -*- mode: lua; coding: windows-1251-dos -*-

----------------------------------------------------------------------------------------------------
-- Script switching logic
----------------------------------------------------------------------------------------------------
-- Разработчик: Andrey Fidrya (Zmey) af@svitonline.com
----------------------------------------------------------------------------------------------------

--[[

----------------------------------------------------------------------------------------------------
-- ФУНКЦИИ, КОТОРЫЕ РАЗРЕШЕНО ВЫЗЫВАТЬ ИЗ ДРУГИХ СКРИПТОВ
----------------------------------------------------------------------------------------------------
	Активация схем производится с помощью функций:

function gulag_activate(npc, ini, section, gulag_name, death, combat, actor_dialogs, trade, hit)
Предназначение:
	активирует заданную схему, используется схемой гулаг. Тип скрипта определяется автоматически по имени секции.
Здесь:
	npc - персонаж, для которого будет активирована схема
	ini - его customdata
	section - имя секции, которая должна быть активирована
	gulag_name - имя гулага, которое будет добавлено спереди к именам путей
	death, combat, actor_dialogs, trade, hit - имена секций, задающих поведение при смерти и в бою

function assign_storage_and_bind(npc, ini, scheme, section)
Предназначение:
	Вызывает функцию add_to_binder схемы, а также создает (если его еще нет) и возвращает ссылку на storage
	для схемы. Примечание: в storage при этом могут оставаться старые данные, схема должна очистить его
	самостоятельно.

function subscribe_action_for_events(npc, storage, new_action)
Предназначение:
	Регистрирует класс для получения нотификаций о таких событиях как сброс схемы, сохранение и т.д.
	Класс реализует соответствующие функции (reset_scheme() и т.д.), которые будут вызываться из xr_logic
	в нужные моменты.

function pick_section_from_condlist(actor, npc, condlist)
Предназначение:
	Проверяет условия condlist, и если они успешны - ставит указанные infoportions и возвращает текст.
	Если условия не выполняются - возвращает nil.

function try_switch_to_another_section(npc, st, actor)
Предназчанение:
	Используя настройки xr_logic из storage персонажа, пытается переключить его на другую схему, если
	хоть одно из условий переключения сработало. Обычно вызывается из метода update класса персонажа.

function is_active(npc, st)
Предназначение:
	Вызывается из evaluator-а (или в самом начале update у предметов и монстров) для проверки, что данная
	схема сейчас активна (схема определяется по данным в storage).

function cfg_get_switch_conditions(ini, section, npc)
Предназначение:
	Считывает все возможные условия переключения схем.

function parse_condlist(npc, section, field, src)
Предназначение:
	Распарсивает условия вида: {+infop1} section1 %-infop2%, {+infop3 -infop4} section2 ... в таблицу.
	Параметры section и field используются только в сообщениях об ошибках. Если строка src считана не из файла,
	а передается в эту функцию гулагом, то нужно задать следующие параметры:
--]]
--		section = "[[[gulag_tasks.script]]]"
--		field = "[[[gulag_name=имя_гулага]]]"
--[[
----------------------------------------------------------------------------------------------------
-- ПРИВАТНЫЕ ФУНКЦИИ
----------------------------------------------------------------------------------------------------

function activate_by_section(npc, ini, section, loading)
Предназначение:
	Активирует указанную секцию. Если в данный момент какая-либо секция уже активирована, сообщает об ошибке.

function switch_to_section(npc, st, section)
Предназначение:
	Выполняет переключение с одной секции на другую, если новая секция не nil. Если же она nil, остается
	активной старая секция.

function abort_syntax_error_in_cond(npc, section, field)
Предназначение:
	Сообщает о синтаксической ошибке в условиях переключения схем секции section и поля field, и останавливает
	игру.

function parse_infop(rslt, str)
Предназначение:
	Распарсивает условия вида " +infop1 =func -infop2 " и т.д. (все не перечислены) в таблицу.

function cfg_get_number_and_condlist(ini, section, field, npc)
function cfg_get_string_and_condlist(ini, section, field, npc)
function cfg_get_condlist(ini, section, field, npc)
Предназначение:
	Считывает из customdata различные условия переключения схем.

function add_condition(lst, at, cond)
Предназначение:
	Добавляет условие в список условий переключения схем.

function cfg_get_overrides(ini, section, npc)
Предназначение:
	Считывает настройки для схем общего поведения.

function generic_scheme_overrides(npc)
Предназначение:
	Возвращает ссылку на настройки схем общего поведения, актуальные для работающей в данный момент схемы,
	либо nil, если ни одна из секций не активна, либо настройки не заданы.

--]]

--[[
-- Предназначение:
--      вызывается при включении набора скриптов через секцию logic у персонажа. Если в секции logic присутствует только
--      поле cfg, использует конфигурационный файл, заданный в этом поле, и возвращает новый ini file.
-- Здесь:
--	npc - персонаж, для которого будет активирована схема
--	ini - его customdata
--	stype - тип скрипта. Поскольку имя секции все еще неизвестно, его нужно задавать явно. Допустимые значения
--	        перечислены в файле modules.script.
--	section - имя секции logic
--	gulag_name - имя гулага, если скрипт включается гулагом, а не биндером
--]]
function configure_schemes(npc, ini, ini_filename, stype, section_logic, gulag_name)
	--log3( "xr_logic.configure_schemes: [%s]: ini_filename = [%s], section_logic = [%s], gulag_name = [%s]", npc:name(), tostring(ini_filename), tostring(section_logic), tostring(gulag_name) )
	local npc_id = npc:id()
	local st     = db.storage[npc_id]
	
	if not st then
		db.storage[npc_id] = {}
		st = db.storage[npc_id]
	end

	-- если какая-то схема была до этого активна, деактивировать её
	if st.active_section then
		issue_event(npc, st[st.active_scheme], "deactivate", npc)
	end

	local actual_ini, actual_ini_filename
	if not ini:section_exist(section_logic) then
		if not gulag_name then
			-- Общие схемы должны работать и без logic:
			actual_ini_filename = ini_filename
			actual_ini = ini -- персонаж не обязательно должен иметь секцию logic
		else
			-- Иначе это персонаж Gulag-а и ему не задали работу:
			abort("ERROR: object '%s': unable to find section '%s'", npc:name(), section_logic)
		end
	else
		local filename = utils.cfg_get_string(ini, section_logic, "cfg", npc, false, "")
		if filename then
			-- Рекурсивно обработать конфигурационный файл, на который ссылается поле cfg
			actual_ini_filename = filename
			actual_ini = dsh.cached_ini_file(filename)
			ASSERT(actual_ini, "no file with external logic for %s", npc:name())
			return configure_schemes(npc, actual_ini, actual_ini_filename, stype, section_logic, gulag_name)
			--[[
			if actual_ini:line_count(section_logic) == 0 then
				abort("file '%s' does not exist or is empty, or has no section '%s'",
					filename, section_logic)
			end
			--]]
		else
			actual_ini_filename = ini_filename
			actual_ini = ini
		end
	end

	-- Поскольку в момент активации схемы могли работать ранее установленные общие схемы, нужно их все отключить:
	disable_generic_schemes(npc, stype)
	-- Включаем все общие схемы (раненный, коллбек на попадание и т.д.):
	enable_generic_schemes(actual_ini, npc, stype, section_logic)

	-- Инициализация торговли
	if stype == modules.stype_stalker or npc:clsid() == clsid.script_trader then
		local trade_ini = utils.cfg_get_string(actual_ini, section_logic, "trade", npc, false, "", "misc\\trade_generic.ltx")
		if xr_companion.is_companion(npc_id) then
			trade_manager.trade_init(npc, "misc\\trade_obmen.ltx")
		else
			trade_manager.trade_init(npc, trade_ini)
		end	
	end
	
	st.active_section = nil
	st.active_scheme = nil
	if gulag_name then
		st.gulag_name = gulag_name
	else
		st.gulag_name = ""
	end
	st.stype = stype
	st.ini = actual_ini
	st.ini_filename = actual_ini_filename
	st.section_logic = section_logic

	return st.ini
end

-- Вызывается биндером с целью определить первую активную схему
function determine_section_to_activate(npc, ini, section_logic, actor)
	if not ini:section_exist(section_logic) then return "nil" end

	-- Распарсить строку выбора активной секции с учетом команд, заключенных в %%
	local active_section_cond = cfg_get_condlist(ini, section_logic, "active", npc)
	local active_section
	if not active_section_cond then
		return "nil"
		-- abort("object '%s': section '%s': unable to find field 'active'", npc:name(), section_logic)
	else
		active_section = pick_section_from_condlist(actor, npc, active_section_cond.condlist)
		if not active_section then
			return "nil"
			-- abort("object '%s': section '%s': section 'active' has no conditionless else clause", npc:name(), section_logic)
		end
	end
--[=[ --KRodin: в ОГСЕ этого не было. Если надо будет, включить.
  if
    active_section
    and db.storage[ npc:id() ].stype
    and db.storage[ npc:id() ].stype <= 1
    and db.storage[ npc:id() ].stype ~= stypes[ utils.get_scheme_by_section( active_section ) ]
  then
    -- Блокируем активацию схемы для зверушек в человеческих гулагах. Dirty Hack.
    return "nil"
  else
--]=]
    return active_section
   --end
end

------------------------------------------------------------------------------------------------------------
-- ВНОСЯ ИЗМЕНЕНИЯ В ЭТУ ФУНКЦИЮ, НЕ ЗАБЫВАЙТЕ ДОБАВЛЯТЬ СООТВЕТСТВУЮЩИЕ СТРОКИ И В enable_generic_schemes
------------------------------------------------------------------------------------------------------------
function disable_generic_schemes(npc, stype)
	if stype == modules.stype_stalker then
		xr_combat.disable_scheme(npc, "combat")
		if ogsm_hideout then
			ogsm_hideout.disable_scheme(npc, "ogsm_hideout")
		end
		if rx_ai then rx_ai.disable_schemes(npc) end
    	xr_use.disable_scheme(npc, "use")
		xr_hit.disable_scheme(npc, "hit")
		xr_meet.disable_scheme(npc, "actor_dialogs")
		xr_heli_hunter.disable_scheme(npc, "heli_hunter")
		xr_combat_ignore.disable_scheme(npc, "combat_ignore")
		xr_companion.disable_scheme(npc, "companion")
		xr_combat_companion.disable_scheme(npc, "companion_combat")
	elseif stype == modules.stype_mobile then
		mob_combat.disable_scheme(npc, "mob_combat")
		mob_trade.disable_scheme(npc, "mob_trade")
	elseif stype == modules.stype_item then
		ph_on_hit.disable_scheme(npc, "ph_on_hit")
	elseif stype == modules.stype_heli then
		xr_hit.disable_scheme(npc, "hit")
	end
end

------------------------------------------------------------------------------------------------------------
-- ВНОСЯ ИЗМЕНЕНИЯ В ЭТУ ФУНКЦИЮ, НЕ ЗАБЫВАЙТЕ ДОБАВЛЯТЬ СООТВЕТСТВУЮЩИЕ СТРОКИ И В disable_generic_schemes
------------------------------------------------------------------------------------------------------------
function enable_generic_schemes(ini, npc, stype, section)
	if stype == modules.stype_stalker then
		if ogsm_hideout then
			ogsm_hideout.enable_scheme(npc, ini, "ogsm_hideout", section)
		end

		xr_danger.set_danger(npc, ini, "danger", "danger")
		xr_companion.enable_scheme(npc, ini, "companion", section)
		xr_combat_companion.enable_scheme(npc, ini, "companion_combat", section)

		local combat_section = utils.cfg_get_string(ini, section, "on_combat", npc, false, "")
		xr_combat.set_combat_checker(npc, ini, "combat", combat_section)

		local use_section = utils.cfg_get_string(ini, section, "on_use", npc, false, "")
		if use_section then
			xr_use.set_use_checker(npc, ini, "use", use_section)
		end
		local info_section = utils.cfg_get_string(ini, section, "info", npc, false, "")
		if info_section then
			stalker_generic.set_npc_info(npc, ini, "info", info_section)
		end

		local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
		if hit_section then
			xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
		end

		local actor_dialogs_section = utils.cfg_get_string (ini, section, "actor_dialogs", npc, false, "")
		if actor_dialogs_section then
			xr_meet.set_actor_dialogs(npc, ini, "actor_dialogs", actor_dialogs_section)
		end

		local wounded_section = utils.cfg_get_string (ini, section, "wounded", npc, false, "")
		xr_wounded.set_wounded (npc, ini, "wounded", wounded_section)

		xr_abuse.set_abuse(npc, ini, "abuse", section)

		local meet_section = utils.cfg_get_string (ini, section, "meet", npc, false, "")
		xr_meet.set_meet (npc, ini, "meet", meet_section)

		local death_section = utils.cfg_get_string (ini, section, "on_death", npc, false, "")
		xr_death.set_death (npc, ini, "death", death_section)

		local heli_hunter_section = utils.cfg_get_string(ini, section, "heli_hunter", npc, false, "")
		xr_heli_hunter.set_scheme(npc, ini, "heli_hunter", heli_hunter_section)

		local combat_ignore_section = utils.cfg_get_string(ini, section, "combat_ignore", npc, false, "")
		if combat_ignore_section then
			xr_combat_ignore.set_combat_ignore_checker(npc, ini, "combat_ignore", combat_ignore_section)
		end

		if rx_ai then rx_ai.enable_schemes(ini,npc,section) end

	elseif stype == modules.stype_mobile then
		local combat_section = utils.cfg_get_string(ini, section, "on_combat", npc, false, "")
		if combat_section then
			mob_combat.set_scheme(npc, ini, "mob_combat", combat_section)
		end

		local death_section = utils.cfg_get_string(ini, section, "on_death", npc, false, "")
		mob_death.set_scheme(npc, ini, "mob_death", death_section)

		local trade_section = utils.cfg_get_string(ini, section, "on_trade", npc, false, "")
		if trade_section then
			mob_trade.set_scheme(npc, ini, "mob_trade", trade_section)
		end

		local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
		if hit_section then
			xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
		end

		mob_panic.set_scheme(npc, ini, "mob_panic")

	elseif stype == modules.stype_item then
		local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
		if hit_section then
			ph_on_hit.set_scheme(npc, ini, "ph_on_hit", hit_section)
		end

	elseif stype == modules.stype_heli then
		local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
		if hit_section then
			xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
		end
	end
end

function activate_by_section(npc, ini, section, loading)
	--log3("DEBUG: object '%s': activate_by_section: looking for section '%s'", npc:name(), section)

	if loading == nil then
		abort("xr_logic: activate_by_section: loading field is nil, true or false expected")
	end

	local npc_id = npc:id()
	if db.storage[npc_id].active_section then
		abort("xr_logic: activate_by_section: while processing section '%s': character '%s': trying to " ..
			"activate more than one schemes at once (section '%s' is active)",
			section, npc:name(), db.storage[npc_id].active_section)
	end

	if not loading then
		db.storage[npc_id].activation_time = time_global()
		-- GAMETIME added by Stohe.
		db.storage[npc_id].activation_game_time = game.get_game_time()
	end

	if section == "nil" then
		db.storage[npc_id].overrides = nil
		reset_generic_schemes_on_scheme_switch(npc, "nil", "nil")
		db.storage[npc_id].active_section = nil
		db.storage[npc_id].active_scheme = nil
		return
	end

	--log1("!!XR_LOGIC DEBUG ["..tostring(npc:name()).."] sect ["..tostring(section).."]")

	if not section or not ini:section_exist(section) then section = "nil" end

	if ini:section_exist(section) then
		local scheme = utils.get_scheme_by_section(section)
		if scheme == nil then
			abort("object '%s': unable to determine scheme name from section name '%s'",
				npc:name(), section)
		end

		-- schemes[scheme] даст имя файла (модуля), в котором реализована схема
		local filename = schemes[scheme]
		if filename == nil then
			log3("!!xr_logic: scheme %s is not registered in modules.script", scheme)
			return
		end

		-- Загрузить оверрайды:
		db.storage[npc_id].overrides = cfg_get_overrides(ini, section, npc)

		-- Сбросить общие схемы:
		reset_generic_schemes_on_scheme_switch(npc, scheme, section)

		-- _G[] даст указатель на неймспейс (таблицу) этого модуля
		if not _G[filename] then
			abort("xr_logic: can't call %s.set_scheme() - a nil value", filename)
		end
		_G[filename].set_scheme(npc, ini, scheme, section, db.storage[npc_id]["gulag_name"])
		db.storage[npc_id].active_section = section
		db.storage[npc_id].active_scheme = scheme

		if db.storage[npc_id].stype == modules.stype_stalker then
			-- чтобы избежать дальнейшего движения по пути при установке рестрикторов
			utils.send_to_nearest_accessible_vertex(npc, npc:level_vertex_id())

			issue_event(npc, db.storage[npc_id][scheme], "activate_scheme", loading, npc)
		else
			issue_event(npc, db.storage[npc_id][scheme], "reset_scheme", loading, npc)
		end
	--else
		--- abort("object '%s': activate_by_section: section '%s' does not exist", npc:name(), section)
	end
end

--[[
-- Предназначение:
--	Производит сброс состояния объекта (снимает коллбеки, отключает разговор) непосредственно перед включением
--	новой схемы.
--]]
function reset_generic_schemes_on_scheme_switch(npc, scheme, section)
	local st = db.storage[npc:id()]

	if not st.stype then return end

	if st.stype == modules.stype_stalker then
		xr_meet.dialog_manager_reset(npc, st.stype)
		xr_meet.reset_meet(npc, scheme, st, section)		
		xr_abuse.reset_abuse(npc, scheme, st, section)
		xr_wounded.reset_wounded(npc, scheme, st, section)
		xr_death.reset_death(npc, scheme, st, section)
		xr_danger.reset_danger(npc, scheme, st, section)
		if not xr_companion.is_companion(npc:id()) then
			stalker_generic.reset_threshold(npc, scheme, st, section)
			stalker_generic.reset_show_spot(npc, scheme, st, section)
		end
		if rx_ai then rx_ai.reset_schemes(npc, scheme, st, section) end
	elseif st.stype == modules.stype_mobile then
		xr_meet.dialog_manager_reset(npc, st.stype)
		mob_release(npc)
		if get_clsid(npc) == clsid.bloodsucker_s then
			npc:set_manual_invisibility(scheme ~= "nil")
		end
		mob_panic.reset_panic(npc, scheme, st, section)

	elseif st.stype == modules.stype_item then
		local is_light = npc:is_lamp() or npc:is_projector()
		if not is_light then
			npc:set_callback(callback.use_object, nil)
		end
		npc:set_nonscript_usable(true)
		if get_clsid(npc) == clsid.car then
			-- Другие объекты под скрипт не берутся, поэтому для них не надо сбрасывать
			npc:destroy_car()
			mob_release(npc)
		end
	end
end

function assign_storage_and_bind(npc, ini, scheme, section)
	local npc_id = npc:id()
	local st

	if not db.storage[npc_id][scheme] then
		db.storage[npc_id][scheme] = {}
		st = db.storage[npc_id][scheme]

		st["npc"] = npc

		-- Схема стартует впервые - прибиндить
		_G[schemes[scheme]].add_to_binder(npc, ini, scheme, section, st)
	else
		st = db.storage[npc_id][scheme]
	end

	st["scheme"] = scheme
	st["section"] = section
	st["ini"] = ini

	return st
end

function subscribe_action_for_events(npc, storage, new_action)

	if not storage.actions then
		storage.actions = {}
	end

	storage.actions[new_action] = true
end

function unsubscribe_action_from_events(npc, storage, new_action)
	if not storage.actions then
		storage.actions = {}
	end

	storage.actions[new_action] = nil
end

-- st - storage активной схемы
function issue_event(npc, st, event_fn, ...)
	if not st or not st.actions then return end
	local activation_count = 0
	local action_ptr, is_active = 0, 0
	for action_ptr, is_active in pairs(st.actions) do
		if is_active and action_ptr[event_fn] then
			action_ptr[event_fn](action_ptr, ...)
			activation_count = activation_count + 1
		end
	end
end

function pick_section_from_condlist(actor, npc, condlist)
	if type(condlist) ~= "table" then return nil end

	for n, cond in pairs(condlist) do
		local infop_conditions_met = true -- изначально считаем, что все условия переключения удовлетворены

		for inum, infop in pairs(cond.infop_check) do
			if infop.prob then
				if infop.prob < math.random(100) then
					infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
					break
				end
			elseif infop.func then
				-- log2( "_bp: infop.func = %s", infop.fname )
				if infop.func( actor, npc, infop.params ) then
					if not infop.expected then
						-- инфопоршен есть, но не должен присутствовать
						infop_conditions_met = false
						break
					end
				else
					if infop.expected then
						-- инфопоршен есть, но не должен присутствовать
						infop_conditions_met = false
						break
					end
				end
			elseif has_alife_info(infop.name) then
				if not infop.required then
					infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
					break
				end
			else
				if infop.required then
					infop_conditions_met = false -- инфопоршена нет, но он нужен
					break
				end
			end
		end

		if infop_conditions_met then
			-- Условия выполнены. Независимо от того, задана ли секция, нужно проставить требуемые infoportions:
			for inum, infop in pairs(cond.infop_set) do
				ASSERT(db.actor, "TRYING TO SET INFOS THEN ACTOR IS NIL")
				if infop.func then
					infop.func( actor, npc, infop.params )
				elseif infop.required then
					if not has_alife_info(infop.name) then
						actor:give_info_portion(infop.name)
					end
				else
					if has_alife_info(infop.name) then
						actor:disable_info_portion(infop.name)
					end
				end
			end
			if cond.section == "never" then
				return nil
			else
				return cond.section
			end
		end
	end

	return nil
end

-- Выполняет переключение на указанную секцию, если задана.
-- Если section == nil, остается работать старая секция.
function switch_to_section(npc, st, section)
	if section == nil or section == "" then return false end

	local npc_storage    = db.storage[npc:id()]
	local active_section = npc_storage.active_section

    if active_section == section then return false end

    if active_section then
		issue_event(npc, npc_storage[npc_storage.active_scheme], "deactivate", npc)
    end

	npc_storage.active_section = nil
	npc_storage.active_scheme = nil

	activate_by_section(npc, st.ini, section, false)

	return true
end

local sect_tbl = {
	["on_actor_dist_le"] =		function(npc, actor, c)
		return npc:alive() and npc:see(actor) and distance_between(actor, npc) <= c.v1
	end,
	["on_actor_dist_le_nvis"] =	function(npc, actor, c)
		return distance_between(actor, npc) <= c.v1
	end,
	["on_actor_dist_ge"] =		function(npc, actor, c)
		return npc:alive() and npc:see(actor) and distance_between(actor, npc) > c.v1
	end,
	["on_actor_dist_ge_nvis"] =	function(npc, actor, c)
		return distance_between(actor, npc) > c.v1
	end,
	["on_signal"] =				function(npc, actor, c, st)
		return st.signals and st.signals[c.v1]
	end,
	["on_info"] =				function()
		return true
	end,
	["on_timer"] =				function(npc, actor, c)
		local npc_id = npc:id()
		return time_global() >= db.storage[npc_id].activation_time + c.v1
	end,
	["on_game_timer"] =			function(npc, actor, c)
		local npc_id = npc:id()
		return game.get_game_time():diffSec(db.storage[npc_id].activation_game_time) >= c.v1
	end,
	["on_actor_in_zone"] =		function(npc, actor, c)
		return utils.npc_in_zone(actor, db.zone_by_name[c.v1])
	end,
	["on_actor_not_in_zone"] =	function(npc, actor, c)
		return not utils.npc_in_zone(actor, db.zone_by_name[c.v1])
	end,
	["on_npc_in_zone"] =		function(npc, actor, c)
		local npc_id = npc:id()
		return utils.npc_in_zone(level.object_by_id(c.npc_id), db.zone_by_name[c.v2])
	end,
	["on_npc_not_in_zone"] =	function(npc, actor, c)
		local npc_id = npc:id()
		return not utils.npc_in_zone(level.object_by_id(c.npc_id), db.zone_by_name[c.v2])
	end,
	["on_actor_inside"] =		function(npc, actor)
		return utils.npc_in_zone(actor, npc)
	end,
	["on_actor_outside"] =		function(npc, actor)
		return not utils.npc_in_zone(actor, npc)
	end
}

function try_switch_to_another_section(npc, st, actor)
	if not actor then return end

	local l = st.logic or abort("try_switch_to_another_section, invalid logic, scheme: [%s] (%s)",
		st.active_scheme or "none", ( npc and npc:name() ) or "script")

	for _, c in pairs(l) do
		local chk = sect_tbl[c.field]
		if chk then
			if chk(npc, actor, c, st) then
				if switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist)) then
					return true
				end
			end
		else
			abort("try_switch_to_another_section: invalid condition: [%s] (%s)", c.name, npc:name())
		end
	end

	return false
end

function is_active(npc, st)
	if st.section == nil then
		abort("npc '%s': st.section is nil, active section is '%s'",
			npc:name(), utils.to_str(db.storage[npc:id()].active_section))
	end
	local is_act = (st.section == db.storage[npc:id()].active_section)

	-- Текущая секция активна и не сработало ни одно из условий переключения на другие секции
	return is_act
end


function abort_syntax_error_in_cond(npc, section, field)
	abort("object '%s': section '%s': field '%s': syntax error in switch condition",
		( npc and npc:name() ) or "script", section or "none", field or "none")
end

function parse_func_params(str)
	local lst = {}
	for par in string.gmatch(str, "%s*([^:]+)%s*") do
		table.insert(lst, tonumber(par) or par)
	end
	return lst
end

function parse_func_name( str, is_check )
  local func
  local module, fname = string.match( str, "(.+)[.](.+)" )
  if not fname then
    if is_check then
      func = xr_conditions[ str ]
    else
      func = xr_effects[ str ]
    end
  else
    if _G[ module ] and _G[ module ][ fname ] then
      func = _G[ module ][ fname ]
    end
  end
  ASSERT( func, "function '%s' not found: is_check = %s", str, is_check )
  return func
end

function parse_infop(rslt, str, is_check)
	if str then
		local infop_n = 1
		for s in string.gmatch(str, "%s*([%-%+%~%=%!][^%-%+%~%=%!%s]+)%s*") do
			local sign = string.sub(s, 1, 1)
			local infop_name = string.sub(s, 2)
			local params = nil
			-- парсим параметры функций
			local at = string.find(infop_name, "%(")
			if at then
				if string.sub(infop_name, -1) ~= ")" then
					abort("wrong condlist %s", (str or "none"))
				end
				if at < string.len(infop_name) - 1 then
					params = parse_func_params(string.sub(infop_name, at + 1, -2))
				else
					params = {}
				end
				infop_name = string.sub(infop_name, 1, at - 1)
			end

			if sign == "+" then
				rslt[infop_n] = { name = infop_name, required = true }
			elseif sign == "-" then
				rslt[infop_n] = { name = infop_name, required = false }
			elseif sign == "~" then
				rslt[infop_n] = { prob = tonumber(infop_name) }
			elseif sign == "=" then
				rslt[ infop_n ] = {
					fname    = infop_name,
					func     = parse_func_name( infop_name, is_check ),
					expected = true,
					params   = params
				}
			elseif sign == "!" then
				rslt[ infop_n ] = {
					fname    = infop_name,
					func     = parse_func_name( infop_name, is_check ),
					expected = false,
					params   = params
				}
			else
				abort("XR_LOGIC - ERROR in function parse_infop")
			end
			infop_n = infop_n + 1
		end
	end
end

-- Распарсивает строку src вида:
-- {+infop1} section1 %-infop2%, {+infop3 -infop4} section2 ...
-- в таблицу:
-- {
--   1 = { infop_check = { 1 = {"infop1" = true} }, infop_set = { 1 = {"infop2" = false } }, section = "section1" },
--   2 = { infop_check = { 1 = {"infop3" = true}, 2 = {"infop4" = false} }, infop_set = {}, section = "section2" },
-- }
function parse_condlist(npc, section, field, src)
	ASSERT(src, "xr_logic.parse_condlist: 'src' is a nil reference")
	local lst = {}

	-- 1) Разбиваем на разделенные запятыми части:
	local at, to, infop_check_lst, remainings, infop_set_lst, newsect


	local n = 1
	for fld in string.gmatch(src, "%s*([^,]+)%s*") do
		-- Здесь fld это набор infoportions в {} и имя секции, на которую переключиться.
		lst[n] = {}

		-- Выделяем список infoportions для проверки:
		at, to, infop_check_lst = string.find(fld, "{%s*(.*)%s*}")
		if infop_check_lst then

			-- Выделяем оставшуюся часть поля, т.е. имя секции плюс список infoportions для установки:
			remainings = string.sub(fld, 1, at - 1) .. string.sub(fld, to + 1)
		else
			-- Список infoportions для проверки не был задан, следовательно, ничего не удаляем:
			remainings = fld
		end

		-- Выделяем список infoportions для установки из remainings:
		at, to, infop_set_lst = string.find(remainings, "%%%s*(.*)%s*%%")
		if infop_set_lst then
			-- Выделяем оставшуюся часть поля, т.е. имя секции:
			newsect = string.sub(remainings, 1, at - 1) .. string.sub(remainings, to + 1)
		else
			-- Список infoportions для установки не был задан, следовательно, remainings и есть имя секции.
			newsect = remainings
		end

		-- И сразу trim имя секции:
		at, to, newsect = string.find(newsect, "%s*(.*)%s*")
		if not newsect then
			abort_syntax_error_in_cond(npc, section, field)
		end

		-- Имя секции теперь можно сохранить:
		lst[n].section = newsect

		-- Теперь нужно распарсить infoportions в строке infop_check_lst и
		-- заполнить массив infop_check: { "infop_name" = true/false }.
		-- На входе имеем строку вида "  +infop1  -infop2 +infop3 ... "
		lst[n].infop_check = {}
		parse_infop(lst[n].infop_check, infop_check_lst, true)

		-- То же самое для устанавливаемых infoportions:
		lst[n].infop_set = {}
		parse_infop(lst[n].infop_set, infop_set_lst, false)

		n = n + 1
	end

	return lst
end

function cfg_get_number_and_condlist(ini, section, field, npc)
	local str = utils.cfg_get_string(ini, section, field, npc, false, "")
	if not str then return nil end

	local par = utils.parse_params(str)
	if not par[1] or not par[2] then
		abort_syntax_error_in_cond(npc, section, field)
	end
	local t = {}
	t.name = field
	t.v1 = tonumber(par[1])
	t.condlist = parse_condlist(npc, section, field, par[2])

	return t
end

function cfg_get_string_and_condlist(ini, section, field, npc)
	local str = utils.cfg_get_string(ini, section, field, npc, false, "")
	if not str then return nil end

	local par = utils.parse_params(str)
	if not par[1] or not par[2] then
		abort_syntax_error_in_cond(npc, section, field)
	end
	local t = {}
	t.name = field
	t.v1 = par[1]
	t.condlist = parse_condlist(npc, section, field, par[2])

	return t
end

function cfg_get_two_strings_and_condlist(ini, section, field, npc)
	local str = utils.cfg_get_string(ini, section, field, npc, false, "")
	if not str then return nil end

	local par = utils.parse_params(str)
	if not par[1] or not par[2] or not par[3] then
		abort_syntax_error_in_cond(npc, section, field)
	end
	local t = {}
	t.name = field
	t.v1 = par[1]
	t.v2 = par[2]
	t.condlist = parse_condlist(npc, section, field, par[3])

	return t
end

function cfg_get_condlist(ini, section, field, npc)
	local str = utils.cfg_get_string(ini, section, field, npc, false, "")
	if not str then return nil end

	local par = utils.parse_params(str)
	if not par[1] then
		abort_syntax_error_in_cond(npc, section, field)
	end
	local t = {}
	t.name = field
	t.condlist = parse_condlist(npc, section, field, par[1])
	t.cached_condlist = dsh.cached_condlist( t.condlist, 1000 )
	return t
end

function add_condition(lst, at, cond)
	if cond then
		lst[at] = cond
		return at + 1
	end
	return at
end


function cfg_get_switch_conditions(ini, section, npc)
	local l = {}
	local n = 1

	local function add_conditions(func, cond)
		local i = 1
		local c = func(ini, section, cond, npc)
		while c ~= nil do
			c.field = cond
			n = add_condition(l, n, c, npc)
			i = i + 1
			c = func(ini, section, cond..i, npc)
		end
	end

	add_conditions( cfg_get_number_and_condlist, "on_actor_dist_le"      )
	add_conditions( cfg_get_number_and_condlist, "on_actor_dist_le_nvis" )
	add_conditions( cfg_get_number_and_condlist, "on_actor_dist_ge"      )
	add_conditions( cfg_get_number_and_condlist, "on_actor_dist_ge_nvis" )
	add_conditions( cfg_get_string_and_condlist, "on_signal"             )
	add_conditions( cfg_get_condlist           , "on_info"               )
	add_conditions( cfg_get_number_and_condlist, "on_timer"              )
	add_conditions( cfg_get_number_and_condlist, "on_game_timer"         )
	add_conditions( cfg_get_string_and_condlist, "on_actor_in_zone"      )
	add_conditions( cfg_get_string_and_condlist, "on_actor_not_in_zone"  )
	add_conditions( cfg_get_condlist           , "on_actor_inside"       )
	add_conditions( cfg_get_condlist           , "on_actor_outside"      )
	add_conditions( cfg_get_npc_and_zone       , "on_npc_in_zone"        )
	add_conditions( cfg_get_npc_and_zone       , "on_npc_not_in_zone"    )

	return l
end

function cfg_get_overrides(ini, section, npc)
	local l = {}

	local tmp			= utils.cfg_get_string(ini, section, "heli_hunter", npc, false, "")
	if tmp then
		l.heli_hunter	= xr_logic.parse_condlist(npc, section, "heli_hunter", tmp)
	end

	l.combat_ignore     = cfg_get_condlist(ini, section, "combat_ignore_cond", npc)
	l.combat_ignore_keep_when_attacked = utils.cfg_get_bool(ini, section, "combat_ignore_keep_when_attacked", npc, false)
	l.combat_type       = cfg_get_condlist(ini, section, "combat_type", npc)
	l.on_combat         = cfg_get_condlist(ini, section, "on_combat", npc)
	l.companion_enabled = utils.cfg_get_bool(ini, section, "companion_enabled", npc, false)
	l.soundgroup		= utils.cfg_get_string(ini, section, section:find("kamp") and "center_point" or "soundgroup", npc, false, "")

	return l
end

function cfg_get_npc_and_zone(ini, section, field, npc)
	local t = cfg_get_two_strings_and_condlist(ini, section, field, npc)
	if t then
		local sim = alife()
		if sim then
			local se_obj = sim:story_object(tonumber(t.v1) or abort(""))
			if se_obj then
				t.npc_id = se_obj.id
			else
				t.npc_id = -1
			end
		else
			t.npc_id = -1
		end
	end

	return t
end

-- Возвращает ссылку на оверрайды, зарегистрированные в активной на данный момент секции,
-- либо nil, если ни одна из секций не активна, или оверрайдов нет.
function generic_scheme_overrides(npc)
	return db.storage[npc:id()].overrides
end

function mob_release(mob)
	if mob:get_script() then
		mob:script(false, script_name())
	end
end

function mob_capture(mob, reset_actions)
	if reset_actions == nil then
		abort("mob_capture: reset_actions parameter's value is not specified")
	end

	if reset_actions then
		if mob:get_script() then
			mob:script(false, script_name())
		end
		mob:script(true, script_name())
	else
		if not mob:get_script() then
			mob:script(true, script_name())
		end
	end
end

function mob_captured(mob)
	return mob:get_script()
end

function save_logic(obj, packet)
	local npc_id = obj:id()
	local activation_time = db.storage[npc_id].activation_time
	if not activation_time then activation_time = 0 end
 	packet:w_s32(activation_time - time_global())
	-- GAMETIME added by Stohe.
	utils.w_CTime(packet, db.storage[npc_id].activation_game_time)
end

function load_logic(obj, reader)
	local npc_id = obj:id()

	db.storage[npc_id].activation_time = reader:r_s32() + time_global()
	-- GAMETIME added by Stohe.
	db.storage[npc_id].activation_game_time = utils.r_CTime(reader)
end

local pstor_number = 0
local pstor_string = 1
local pstor_boolean = 2
local registered_types = {
	["boolean"] = true,
	["string"]  = true,
	["number"]  = true,
}

function pstor_store(obj, varname, val)
	if not obj then return end
	local npc_id = obj:id()
	
	if db.storage[npc_id].pstor == nil then
		db.storage[npc_id].pstor = {}
	end
	local tv = type(val)
	if registered_types[tv] then
		db.storage[npc_id].pstor[varname] = val
	--else
		-- log1("xr_logic: pstor_store: not registered type encountered - write in pstor_store cancalled")
	end	
end

function pstor_retrieve(obj, varname, defval)
    if not obj then return defval end
	local npc_id = obj:id()
	
	if db.storage[npc_id].pstor ~= nil then
		local val = db.storage[npc_id].pstor[varname]
		if val ~= nil then
			return val
		end
	end
	if defval ~= nil then
		return defval
	end
	return nil
end

function pstor_save_all(obj, packet)
	local npc_id = obj:id()
	local pstor = db.storage[npc_id].pstor
	if not pstor then
		pstor = {}
		db.storage[npc_id].pstor = pstor
	end

	if obj:is_actor() then
		--log3("[%s] Saved actor pstor: %s", script_name(), pstor)
		ogse.save_var( script_name()..".pstor_actor", pstor, "table" )
	else
		local ctr = 0
		for k, v in pairs(pstor) do
			ctr = ctr + 1
		end
		packet:w_u32(ctr)

		for k, v in pairs(pstor) do
			packet:w_stringZ(k)
			local tv = type(v)
			if tv == "number" then
				packet:w_u8(pstor_number)
				packet:w_float(v)
			elseif tv == "string" then
				packet:w_u8(pstor_string)
				packet:w_stringZ(v)
			elseif tv == "boolean" then
				packet:w_u8(pstor_boolean)
				packet:w_bool(v)
			else
				abort("xr_logic: pstor_save_all: not registered type encountered in ", " NPC "..tostring(obj:name()).." varname "..tostring(k).." value "..tostring(v))
			end
		end
	end
end

function pstor_load_all(obj, reader)
	local npc_id = obj:id()
	local pstor = db.storage[npc_id].pstor
	if not pstor then
		pstor = {}
		db.storage[npc_id].pstor = pstor
	end

	if obj:is_actor() and ogse.var_exists( script_name() .. ".pstor_actor" ) then
		db.storage[npc_id].pstor = ogse.load_var( script_name() .. ".pstor_actor" )
		--log3("[%s] Loaded actor pstor: %s", script_name(), db.storage[npc_id].pstor)
	else
		if obj:is_actor() then --Такое может быть при НИ
			return
		end

		local ctr = reader:r_u32()

		if ctr > 20  then
			log3("!![pstor_load_all] Something strange in object [%s]", obj:name())
			ctr = 20 		
		end		

		for i = 1, ctr do
			local varname = reader:r_stringZ()
			local tn = reader:r_u8()
			if tn == pstor_number then
				pstor[varname] = reader:r_float()
			elseif tn == pstor_string then
				pstor[varname] = reader:r_stringZ()
			elseif tn == pstor_boolean then
				pstor[varname] = reader:r_bool()
			else
				pstor[varname] = nil
				--("xr_logic: pstor_load_all: not registered type encountered in ", " NPC "..tostring(obj:name()).." varname "..tostring(varname).." value "..tostring(tn))
			end
		end
	end
end


local st_loaded_keys = {
  [ "ini_filename"   ] = "loaded_ini_filename",
  [ "section_logic"  ] = "loaded_section_logic",
  [ "active_section" ] = "loaded_active_section",
  [ "gulag_name"     ] = "loaded_gulag_name",
}

function get_st_loaded_value( st, k )
  ASSERT(
    st_loaded_keys[ k ],
    "[%s]: '%s' not found in st_loaded_keys", script_name(), tostring( k )
  )
  return st[ st_loaded_keys[ k ] ]
end

function get_st_value( st, k )
  return st[ k ]
end

local save_obj_keys = {
  "ini_filename", "section_logic", "active_section", "gulag_name"
}

function save_obj( obj, packet, loaded )
  -- log3(
  --   "xr_logic.save_obj: obj:name() = '%s', loaded = %s",
  --   obj:name(), tostring( loaded )
  -- )
  local npc_id = obj:id()
  local st     = db.storage[ npc_id ]
  local get_st = loaded and this.get_st_loaded_value or this.get_st_value

--[=[ --KRodin: В ОГСЕ это, вроде бы, не нужно.
  -- сообщение по побившейся логике физобъектов и вертолетов
  local s_ini  = obj:spawn_ini()
  if
    ( not get_st( st, "ini_filename" ) )
    and s_ini and logic_not_empty( obj, s_ini )
  then
    if
      obj:clsid() == clsid.script_phys or obj:clsid() == clsid.script_heli
    then
      abort(
        "У объекта %s повисла логика. Удалите созданное только что сохранение и переиграйте с предыдущего.",
        obj:name()
      )
    end
  end
--]=]

  for _, k in ipairs( save_obj_keys ) do
    local v = get_st( st, k )
    -- log3( "xr_logic.save_obj: %s = %s", k, v )
    packet:w_stringZ( v or "" )
  end
  save_logic( obj, packet )
  if st.active_scheme then
    issue_event( obj, db.storage[ npc_id ][ st.active_scheme ], "save" )
  end
  pstor_save_all( obj, packet )
end


function load_obj(obj, reader)
	local npc_id = obj:id()
	local st = db.storage[npc_id]
	local ini_filename = reader:r_stringZ()
	--log1("!!LOGIC_LOAD ["..obj:name().."] log=["..tostring(ini_filename).."]")
	if ini_filename == "" then ini_filename = nil end

	local section_logic = reader:r_stringZ()
	--log1("!!LOGIC_LOAD_SECT ["..obj:name().."] log=["..tostring(section_logic).."]")
	if section_logic == "" then section_logic = nil end

	local active_section = reader:r_stringZ()
	--log1("!!LOGIC_LOAD_ACT ["..obj:name().."] log=["..tostring(active_section).."]")

	-- В activate_by_section нужно передать строку "nil", а не nil, чтобы не активировать ни одной из схем.
	-- При этом реальная active_section станет равной nil.
	if active_section == "" then active_section = "nil" end

	local gulag_name = reader:r_stringZ()
	if gulag_name == "" then gulag_name = nil end

	st.loaded_ini_filename = ini_filename
	st.loaded_section_logic = section_logic
	st.loaded_active_section = active_section
	st.loaded_gulag_name = gulag_name

	load_logic(obj, reader)
	pstor_load_all(obj, reader)
end

function get_customdata_or_ini_file(npc, filename)
  local dsh_sect = "dsh.xr_logic.get_customdata_or_ini_file"
  if sys_ini:section_exist( dsh_sect ) then
    local npc_sect
    if type( npc.id ) == "function" then
      npc_sect = npc:section()
    else
      npc_sect = npc:section_name()
    end
    local ini_fname = get_string( dsh_sect, npc_sect )
    if not ini_fname then
      ini_fname = get_string( dsh_sect, npc:name() )
    end
    if ini_fname then
      local new_ini = dsh.cached_ini_file( ini_fname )
      if logic_not_empty(npc, new_ini) then --!KRodin: если логика вышла в nil, её не используем! Ведь в этом случае персонаж уже может находиться под логикой какого-нибудь гулага.
        return new_ini
      end
    end
  end
  --
	if filename == "<customdata>" then
		return npc:spawn_ini() or dsh.cached_ini_file("scripts\\dummy.ltx")
	elseif string.find( filename, "*" ) == 1 then --динамический ltx
		local p = string.find( filename, "*", 2 )
		return gulag_tasks.loadLtx( string.sub(filename, 2, p-1), string.sub(filename, p+1) )
	else
		return dsh.cached_ini_file(filename)
	end
end

function initialize_obj(obj, st, loaded, actor, stype)
	if not loaded then
		local ini_filename = "<customdata>"
		local ini = get_customdata_or_ini_file(obj, ini_filename)
		ini = xr_logic.configure_schemes(obj, ini, ini_filename, stype, "logic", nil)
		local sect = xr_logic.determine_section_to_activate(obj, ini, "logic", actor)
		xr_logic.activate_by_section(obj, ini, sect, false)
	else
		local ini_filename = st.loaded_ini_filename
		if ini_filename then
			local ini = get_customdata_or_ini_file(obj, ini_filename)
			if not ini:section_exist( st.loaded_section_logic ) and st.loaded_gulag_name then --Костыль, чтобы не требовалась НИ при изменении логики гулагов
				log3("!![%s.initialize_obj] object [%s] unable to find gulag logic section [%s] Reloading logic...", script_name(), obj:name(), st.loaded_section_logic)
				ogse.reset_npc_logic(obj)
				xr_gulag.resetJob(obj)
				local sobj = alife():object(obj:id())
				ASSERT(sobj, "")
				smart_terrain.unregister_npc( sobj )
				sobj:brain():update()
				return
			else
				ini = xr_logic.configure_schemes(obj, ini, ini_filename, stype, st.loaded_section_logic, st.loaded_gulag_name)
				xr_logic.activate_by_section(obj, ini, st.loaded_active_section, true)
			end
		end
	end
end

-- у объекта есть "непустая" логика
function logic_not_empty(npc, ini)
	if ini:section_exist("logic") and ini:line_exist("logic", "cfg") then
		ini = dsh.cached_ini_file( get_string("logic", "cfg", "scripts\\dummy.ltx", ini) )
	end
	return determine_section_to_activate(npc, ini, "logic", db.actor) ~= "nil"
end

function save_logic_online(obj)
	local npc_id = obj:id()
	local st = db.storage[npc_id]
	local gulag = xr_gulag.get_npc_gulag(obj)
	local sobj = alife():object(obj:id())
	if sobj and not gulag then
		if sobj.s_storage and sobj.s_storage ~= "_" then
			local npc_data = m_netpk.custom_data(sobj.s_storage)
			npc_data = npc_data:getTable()
			if not npc_data.logic_data then
				npc_data.logic_data = {}
			end
			if st.ini_filename then
				npc_data.logic_data["ini"] = st.ini_filename
			else
				npc_data.logic_data["ini"] = ""
			end
			if st.section_logic then
				npc_data.logic_data["sec"] = st.section_logic
			else
				npc_data.logic_data["sec"] = ""
			end
			if st.active_section then
				npc_data.logic_data["act"] = st.active_section
			else
				npc_data.logic_data["act"] = ""
			end
			local activation_time = st.activation_time
			if not activation_time then
				activation_time = 0
			end
			local cur_tm = time_global()
			activation_time = activation_time - cur_tm
			npc_data.logic_data["act_time"] = activation_time
			local gtime = st.activation_game_time
			local str_gtime = nil
			if gtime then
				str_gtime = pack_time_to_string(gtime)
				if str_gtime then
					npc_data.logic_data["act_g_time"] = str_gtime
				end            
			end
			local data_parsed = m_netpk.custom_data(npc_data)
			sobj.s_storage = data_parsed:getString()
		else
			local npc_data = {}
			npc_data.logic_data = {}
			if st.ini_filename then
				npc_data.logic_data["ini"] = st.ini_filename
			else
				npc_data.logic_data["ini"] = ""
			end
			if st.section_logic then
				npc_data.logic_data["sec"] = st.section_logic
			else
				npc_data.logic_data["sec"] = ""
			end
			if st.active_section then
				npc_data.logic_data["act"] = st.active_section
			else
				npc_data.logic_data["act"] = ""
			end
			local activation_time = st.activation_time
			if not activation_time then
				activation_time = 0
			end
			local cur_tm = time_global()
			activation_time = activation_time - cur_tm
			npc_data.logic_data["act_time"] = tostring(activation_time)
			local gtime = st.activation_game_time
			local str_gtime = nil
			if gtime then
				str_gtime = pack_time_to_string(gtime)
				if str_gtime then
					npc_data.logic_data["act_g_time"] = str_gtime
				end            
			end      
			local data_parsed = m_netpk.custom_data(npc_data)
			sobj.s_storage = data_parsed:getString()
		end
	end   
end

function load_logic_online(obj)
	local npc_id = obj:id()
	local st = db.storage[npc_id]
	local gulag = xr_gulag.get_npc_gulag(obj)
	local sobj = alife():object(obj:id())
	if sobj and not gulag and sobj.s_storage and sobj.s_storage ~= "_" then
		local npc_data = m_netpk.custom_data(sobj.s_storage)
		npc_data = npc_data:getTable()
		if npc_data.logic_data then
			if npc_data.logic_data["ini"] and npc_data.logic_data["ini"] ~= "" then
				st.ini_filename = npc_data.logic_data["ini"]
			end
			if npc_data.logic_data["sec"] and npc_data.logic_data["sec"] ~= "" then
				st.section_logic = npc_data.logic_data["sec"]
			end
			if npc_data.logic_data["act"] and npc_data.logic_data["act"] ~= "" then
				st.active_section = npc_data.logic_data["act"]
			else
				st.active_section = "nil" --В activate_by_section нужно передать строку "nil", а не nil, чтобы не активировать ни одной из схем.
			end   
			if npc_data.logic_data["act_time"] and npc_data.logic_data["act_time"] ~= "" then
				local cur_tm = time_global()
				st.activation_time = tonumber(npc_data.logic_data["act_time"]) + cur_tm         
			end
			if npc_data.logic_data["act_g_time"] and npc_data.logic_data["act_g_time"] ~= "" then
				local unpack_ctime = unpack_time_from_string(npc_data.logic_data["act_g_time"])
				st.activation_game_time = unpack_ctime   
			end
			return true		 
		end
	end
	return false
end